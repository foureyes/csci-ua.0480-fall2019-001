I"~{<section class="intro-slide">
  <h1 id="higher-order-functions-continued">Higher Order Functions (Continued)</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="abstraction">Abstraction</h2>

  <p><strong>What&#39;s abstraction again?</strong> &#8594;</p>

  <div class="img">
    <p><img src="../../resources/img/pollock.jpg" alt="pollock" /></p>
  </div>

  <p class="fragment"><strong>Abstraction</strong> is the process of hiding away necessary, yet immaterial details so that the programmer can focus on solving the actual higher-level problem&#8230;</p>

  <p class="fragment"><strong>What are some <em>features</em> in JavaScript that facilitate abstraction?</strong> &#8594;</p>

  <ul class="fragment">
    <li>(obvs) functions</li>
    <li>functions as first-class objects</li>
    <li><strong>higher order functions</strong></li>
  </ul>
</section>

<section>
  <h2 id="higher-order-functions">Higher Order Functions</h2>

  <p>Greeeaaaat. <strong>What&#39;s a higher order function, though?</strong> &#8594;</p>

  <p class="fragment">A <strong>higher order function</strong> is a function that does at least one of the following things: &#8594;</p>

  <ul class="fragment">
    <li>accepts a function or functions as a parameter</li>
    <li>returns a function</li>
  </ul>
</section>

<section>
  <h2 id="array-methods">Array Methods</h2>

  <p>We learned about (and even <em>re-implemented</em>) four array methods that accepted functions as arguments (specifically as <em>callback</em> functions). <strong>What were these array methods, and what do they do?</strong> &#8594;</p>

  <ul class="fragment">
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach]">forEach</a> - calls callback on each array element</li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">filter</a> - returns a new filtered array based on test/callback</li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a> - returns a new transformed array based on callback</li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">reduce</a> - reduces original array to single value based on callback</li>
  </ul>
</section>

<section>
  <h2 id="foreach">forEach</h2>

  <p>An array&#39;s <strong>forEach</strong> method executes a callback on every array element.</p>

  <ul>
    <li><strong>1 parameter</strong> - a callback function that is executed with the current element, index and original array</li>
    <li><strong>returns</strong> undefined</li>
    <li><strong>example</strong> &#8594;</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
// log double the value of every element in the array
const numbers = [3, 4, 5];
numbers.forEach(function(element) {
	console.log(element);
});
</code></pre>

  <p class="fragment">Also, our homegrown implementation as a standalone function.</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function forEach(arr, action) {
	for (let i = 0; i &lt; arr.length; i++) {
		action(arr[i]); 
	}
}
</code></pre>
</section>

<section>
  <h2 id="filter">filter</h2>

  <p>An array&#39;s <strong>filter</strong> method returns a new array of elements that each pass some test/callback.</p>

  <ul>
    <li><strong>1 parameter</strong> a function, test, that is executed with the current element, index and original array&#8230; and returns either true or false</li>
    <li><strong>returns</strong> a new filtered array</li>
    <li><strong>example</strong> (note&#8230;  <code>indexOf</code> returns the index of a substring in a string&#8230; and it returns -1 if the substring is not found)</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
// only give back the strings that start with 'ba'

const words = ['foo', 'bar', 'baz', 'qux'];
const filtered_words = words.filter(function(word) {
	return word.indexOf('ba') !== -1;
});
console.log(filtered_words);
</code></pre>

</section>

<section>
  <h2 id="a-diy-filter-function">A DIY Filter Function</h2>

  <p>We implemented <code>filter</code> as a standalone function as well. <strong>The algorithm was fairly compact; what was it?</strong> &#8594;</p>

  <ol class="fragment">
    <li>create a new array to hold the filtered elements</li>
    <li>go through every element in the original array</li>
    <li>check to see if it passes the test (execute the callback on it)</li>
    <li>if it passes, add it to the new array</li>
  </ol>

  <p class="fragment"><br />
<strong>And the implementation&#8230;</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function filter(arr, test) {
	const filtered = [];
	arr.forEach(function(element) {
		if(test(element)) {
			filtered.push(element)
		}
	});
	return filtered;
}
</code></pre>
</section>

<section>
  <h1 id="now-lets-check-out-map-and-reduce">Now let&#39;s check out map and reduce.</h1>

  <h3 id="lets-build-our-own-version-of-each-first-">Let&#39;s build our own version of each first &#8230;</h3>
</section>

<section>
  <h2 id="transforming-with-map">Transforming with Map</h2>

  <p><strong>Create a function called map that creates a new array based on calling a function on each element of an array passed in:</strong> &#8594;</p>

  <ul>
    <li><strong>2 parameters</strong> - an array to base new array off of and a function to transform each element</li>
    <li><strong>returns</strong> a new array with each element of original transformed by callback function</li>
    <li>test it by creating an array of words and transforming that array into an array of words each with two exclamation points at the end</li>
  </ul>

  <p><br />
<strong>What would the algorithm be?</strong>&#8594;</p>

  <ol class="fragment">
    <li>create a new array to hold the transformed elements</li>
    <li>go over every element in the original array</li>
    <li>call the function on each element</li>
    <li>add the result of calling the function to the other array</li>
  </ol>
</section>

<section>
  <h2 id="map-continued">Map Continued</h2>

  <p><strong>Here&#39;s a potential implementation, along with example usage, of our own <code>map</code> implementation.</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
function map(arr, transform) {
	const transformed = [];
	arr.forEach(function(element) {
		transformed.push(transform(element));
	});
	return transformed;
}
const result = map(['hello', 'hey', 'hi'], function(greeting) {return greeting + '!!'});
console.log(result);
</code></pre>
</section>

<section>
  <h2 id="using-an-arrays-map-method">Using an Array&#39;s Map Method</h2>

  <p>Again, JavaScript arrays already have a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map method</a>&#8230;</p>

  <ul>
    <li><strong>1 parameter</strong> - a callback (the function that transforms each element)</li>
    <li>the <em>callback</em> is executed with the current value, index and original array</li>
    <li>the <em>callback</em> <strong>returns</strong> a new value/object to be added</li>
    <li>map <strong>returns</strong> a new array with every element transformed</li>
  </ul>

  <p><br />
<strong>Try using it to change every word in the list <code>['hey','yo','sup']</code> to uppercase with an exclamation point.</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
words = ['hey', 'yo', 'sup']
const shoutedWords = words.map(function(word) {
	return word.toUpperCase() + '!';
});
console.log(shoutedWords);
</code></pre>
</section>

<section>
  <h2 id="reducing-an-array-to-a-single-value">Reducing an Array to a Single Value</h2>

  <p><strong>Create a function called reduce&#8230; that repeatedly calls a function to reduce an array to a single value.</strong> &#8594;</p>

  <ul>
    <li><strong>3 parameters</strong>
      <ul>
        <li>the original array</li>
        <li>a callback function to perform the reduction</li>
        <li>a start value to initialize the variable that will hold the single value to be returned</li>
      </ul>
    </li>
    <li>the <em>callback</em> should
      <ul>
        <li>take both the current <em>accumulated</em> value, and the current element</li>
        <li>return the new <em>accumulated</em> value</li>
      </ul>
    </li>
    <li>an <strong>example</strong> in the next slide&#8230; &#8594;</li>
  </ul>

</section>

<section>
  <h2 id="reduce-continued">Reduce Continued</h2>

  <pre><code data-trim="" contenteditable="">
// result is 20
console.log(reduce([4, 12, 5], function(accum, ele) {
  return accum + ele;  
}, 0));
</code></pre>

  <p><strong>What do you think the algorithm for reduce would look like?</strong> &#8594;</p>

  <ol class="fragment">
    <li>create a variable, an accumulator, that will be returned</li>
    <li>initialize it to <em>start</em></li>
    <li>for every element in the original array&#8230;</li>
    <li>apply the callback&#8230;</li>
    <li>set the accumulator to the result of the callback</li>
    <li>return the accumulator</li>
  </ol>
</section>

<section>
  <h2 id="our-version-of-reduce">Our Version of Reduce</h2>

  <pre><code data-trim="" contenteditable="">
function reduce(arr, combine, start) {
  const accum = start;
  arr.forEach(function(ele){
    accum = combine(accum, ele); 
  }); 
  return accum;
}

console.log(reduce([4, 12, 5], function(accum, ele) {
  return accum + ele;  
}, 0));

</code></pre>
</section>

<section>
  <h2 id="reduce-continued-1">Reduce Continued</h2>

  <p>Here&#39;s an example of finding the minimum (uses first element as initial min) with reduce:</p>

  <pre><code data-trim="" contenteditable="">
const numbers = [-5, -2, -1, -10, -3];

console.log(reduce(numbers, function(accum, ele) {
  if(accum &lt; ele) {
    return accum;
  } else {
    return ele; 
  }
}, numbers[0]));
</code></pre>
</section>

<section>
  <h2 id="using-an-arrays-reduce-method">Using an Array&#39;s Reduce Method</h2>

  <p>JavaScript arrays have a built-in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">reduce method</a>. (Note that in other functional languages, <strong>reduce</strong> is sometimes called <strong>fold</strong>.)</p>

  <ul>
    <li><strong>2 parameters</strong> a callback function (the function that <em>reduces</em> the array) and the optional start value of the accumulator (if the start doesn&#39;t exist, it uses the first element of the array that it was called on)</li>
    <li>callback is executed with accumulator, element value, element index and original array object</li>
    <li>callback returns a value (the new value for the internal accumulator)</li>
    <li>reduce <strong>returns</strong> a single value (that value can be an Array, Object, etc.)</li>
  </ul>

  <p><br />
<strong>Try using it to calculate the product of all of the elements in <code>[2, 5, 4, 3,]</code>.</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
[2, 5, 4, 3,].reduce(function(product, currentNumber ){
	return product * currentNumber;
}, 1);
</code></pre>
</section>

<section>
  <h2 id="aaaaand-freestyle">Aaaaand Freestyle</h2>

  <p>Using <code>forEach</code>, <code>filter</code>, <code>map</code>, and/or <code>reduce</code>, <strong>can you try to count all of the face cards in the following array?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
const cards = [{'suit':'♦', 'face':'4'},
             {'suit':'♠', 'face':'J'},
             {'suit':'♠', 'face':'Q'},
             {'suit':'♣', 'face':'Q'},
             {'suit':'♠', 'face':'2'},
             {'suit':'♦', 'face':'7'},
             {'suit':'♥', 'face':'K'}];
</code></pre>
  <div class="img">
    <p><img src="../../resources/img/jack.png" alt="jack" /></p>
  </div>
</section>

<section>
  <h2 id="counting-face-cards">Counting Face Cards</h2>

  <p><strong>Let&#39;s try the most convential way&#8230; together</strong>.</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
let count = 0;
cards.forEach(function(card) {
	if (['K', 'Q', 'J'].indexOf(card.face) !== -1) {
		count += 1;
	} 
});
console.log(count);
</code></pre>

  <p class="fragment"><strong>Now write your own versions using the following two methods&#8230;</strong>  &#8594;</p>

  <ol>
    <li class="fragment">with an <code>Array</code>&#39;s <code>filter</code> method</li>
    <li class="fragment">&#8230;and an <code>Array</code>&#39;s <code>reduce</code> method</li>
  </ol>

</section>

<section>
  <h2 id="composability--chaining">Composability / Chaining</h2>

  <p><strong>Try using all 3 methods to run an analysis on some stats from game 5 of the 2014 NBA finals.</strong>  &#8594;</p>

  <ul>
    <li>print out the <strong>average shooting percentage for each team</strong>, the Spurs and the Heat</li>
    <li>use the object below as the data set</li>
    <li>each player is associated with either team through the <code>"team"</code> property</li>
    <li>shooting percentage is field goals made (<code>"FGM"</code>) divided by field goals attempted (<code>"FGA"</code>)</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
const players = [
{"lastName":"Duncan", "team":"Spurs", "FGM":5, "FGA":10},
{"lastName":"Parker", "team":"Spurs", "FGM":7, "FGA":18},
{"lastName":"Ginobili", "team":"Spurs", "FGM":6, "FGA":11},
{"lastName":"James", "team":"Heat", "FGM":10, "FGA":21},
{"lastName":"Wade", "team":"Heat", "FGM":4, "FGA":12},
{"lastName":"Bosh", "team":"Heat", "FGM":6, "FGA":14}
];
</code></pre>
</section>

<section>
  <h2 id="shooting-percentages-for-the-spurs-and-heat">Shooting Percentages for The Spurs and Heat</h2>

  <p>Note that you can continue to chain calls to <code>map</code>, <code>filter</code>, and <code>reduce</code> as long as you get an array back.</p>

  <p><strong>Here&#39;s a potential solution. There are a few utility functions declared for clarity and readability.</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
function heat(player) { return player.team === 'Heat'; }
function spurs(player) { return player.team === 'Spurs'; }
function shootingPercentage(player) { return player.FGM / player.FGA; }
function sum(curTotal, num) { return curTotal + num}
function average(arr) { return arr.reduce(sum, 0) / arr.length; }

console.log(average(players.filter(heat).map(shootingPercentage)).toFixed(2));
console.log(average(players.filter(spurs).map(shootingPercentage)).toFixed(2));
</code></pre>

  <p><strong>Seems to map more closely to what we&#39;re actually trying to do rather than creating a bunch of for loops.</strong></p>

</section>

<section>
  <h2 id="two-separate-functions-for-filtering">Two Separate Functions for Filtering?</h2>

  <p>Maybe having a function that checks against a hardcoded string doesn&#39;t sit well with you. Admittedly, <code>heat(player)</code> and <code>spurs(player)</code> do seem like throw away functions.</p>

  <p><strong>Is there a way that we can replace both of those functions with one?</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function inTeam(teamName) {
  return function(player) { return player.team === teamName; }
}
console.log(average(players.filter(inTeam('Heat')).map(shootingPercentage)).toFixed(2));
console.log(average(players.filter(inTeam('Spurs')).map(shootingPercentage)).toFixed(2));

</code></pre>
</section>
<section>
  <h2 id="ginobili">GINOBILI!!!</h2>

  <p>A quick side note: that guy <strong>Ginobili</strong> is an Argentinian basketball player that once hit a flying bat out of the air during a game.</p>

  <div class="img fragment">
    <p><img src="../../resources/img/ginobili.gif" alt="ginobili" /></p>
  </div>

  <p class="fragment">(BTW, I don&#39;t condone hurting animals, but I do love animated gifs <em>a lot</em>)</p>

</section>

<section>
  <h2 id="a-quick-summary-of-the-methods-we-just-saw">A Quick Summary of the Methods we Just Saw</h2>

  <ul>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach]">forEach</a> - calls callback on each array element</li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">filter</a> - returns a new filtered array based on test/callback</li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a> - returns a new transformed array based on callback</li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">reduce</a> - reduces original array to single value based on callback</li>
  </ul>
</section>

<section>
  <h2 id="performance">Performance</h2>

  <h3 id="were-gaining-readability-expressiveness-etc--at-the-cost-of-performance">We&#39;re gaining readability, expressiveness, etc. &#8230; at the cost of performance</h3>

  <p><strong>We make that trade-off all the time</strong>, which is why we&#39;re not writing with super-fast machine code, but with <em>slower</em> high-level languages, like JavaScript or Python.</p>

  <ul>
    <li>a <code>for</code> loop will likely outperform <code>forEach</code>, <code>map</code>, <code>filter</code> and <code>reduce</code></li>
    <li>some of it may stem from the overhead of repeatedly executing functions</li>
    <li>but&#8230; for general cases, modern-day computers are fast enough where it&#39;s not really a perceptible difference (depending on the data set and number of iterations, of course)</li>
  </ul>
</section>

<section>
  <h2 id="an-aside-on-arrow-function-usage">An Aside on Arrow Function Usage</h2>

  <p>For now, <strong>we&#39;ll use arrow functions as:</strong> &#8594;</p>

  <ul>
    <li class="fragment">a quick way of creating anonymous callback functions&#8230;</li>
    <li class="fragment">for example, if we need to pass a one-time use function as an argument to a higher order function (like map):
      <pre><code data-trim="" contenteditable="">const nums = [1, 2, 3, 4, 5];
console.log(nums.filter(x =&gt; x % 2 === 0));
</code></pre>
    </li>
    <li class="fragment">or&#8230; occasionally, we can use them to define <em>regular</em> functions as well:
      <pre><code data-trim="" contenteditable="">
const isEven = (x) =&gt; {return x % 2 === 0;};
</code></pre>
    </li>
    <li class="fragment">we&#39;ll see later that arrow functions are sometimes useful because the <code class="highlighter-rouge">this</code> value within its body is the same as <code class="highlighter-rouge">this</code> in the scope that it was created in (this will make more sense when we discuss <code class="highlighter-rouge">this</code>!)</li>
  </ul>

</section>

<section>
  <h2 id="functions-as-objects">Functions as Objects</h2>

  <p><strong>Continuing on with the notion that functions are just values or objects&#8230; do you think functions also have properties and methods?</strong></p>

  <p class="fragment">Why yes - functions have both <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function#Properties">properties</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function#Methods">methods</a>!  For example:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const f = function(x, y, z) {
	return x - y + z;
}
console.log(f.length);
</code></pre>

  <p class="fragment">Let&#39;s check out some <strong>methods</strong> that you can call on function objects:</p>

  <ul class="fragment">
    <li><code>bind</code></li>
    <li><code>apply</code></li>
    <li><code>call</code></li>
  </ul>
</section>

<section>
  <h2 id="methods-on-function-objects">Methods on Function Objects</h2>

  <p>So, what do these methods do?</p>

  <ul>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call</a> - calls a function with given <code>this</code> and individual arguments</li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply</a> - calls a function with given <code>this</code> and array as arguments</li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a> - creates a new function with given <code>this</code>, and optionally with set argument values</li>
  </ul>

  <p><br />
(we&#39;ll talk about <strong>this</strong> in a moment)</p>

</section>
<section>
  <h2 id="call-and-apply">Call and Apply</h2>

  <p><strong>Both <code>call</code> and <code>apply</code> immediately execute the function that they&#39;re called on.</strong></p>

  <ul>
    <li>they differ in the way that arguments are passed to the original function object (<code>call</code> passes each argument individually, while <code>apply</code> passes an array)</li>
    <li>the example below sets <code>this</code> to null - we&#39;ll see more about <code>this</code> later</li>
  </ul>
  <pre><code data-trim="" contenteditable="">
function areaTriangle(base, height) {
	return (1 / 2 ) * base * height;
}

const result1 = areaTriangle.call(null, 10, 20);
console.log(result1);
const result2 = areaTriangle.apply(null, [10, 20]);
console.log(result2);
</code></pre>

</section>

<section>
  <h2 id="bind">Bind</h2>

  <p>Unlike the previous methods, <strong><code>bind</code></strong> doesn&#39;t execute the function that it&#39;s called on. Instead, <code>bind</code>:</p>

  <ul>
    <li>takes a <code>this</code> argument</li>
    <li>and an optional set of fixed parameters</li>
    <li>returns a new function</li>
  </ul>

  <p><br />
It&#39;s actually an implementation of <strong>partial application</strong>&#8230;</p>

  <ul>
    <li><strong>partial application</strong> - fixing a number of arguments to a function, producing another function of smaller <strong>arity</strong></li>
    <li><strong>arity</strong> - the number of arguments or operands that a function or operation accepts</li>
  </ul>
</section>

<section>
  <h2 id="bind-example">Bind Example</h2>

  <p><strong>Fixing the first parameter, called <code>base</code>, of our function.</strong></p>

  <pre><code data-trim="" contenteditable="">
const areaTriangleBase100 = areaTriangle.bind(null, 100);

// call with only one argument now
console.log(areaTriangleBase100(3));
</code></pre>

  <p><br />
Note that you&#39;ll also see <code>bind</code> used to fix/set a function or method&#39;s <code>this</code>.</p>
</section>

<section>
  <h2 id="es6-spread-and-rest">ES6 Spread and Rest</h2>

  <p>Hey&#8230; so remember the rest operator, <code class="highlighter-rouge">...args</code>? <strong>What was it?</strong> &#8594;</p>

  <ul>
    <li class="fragment">if the last named argument of a function has <code class="highlighter-rouge">...</code> before it (the <code class="highlighter-rouge">rest</code> operator)</li>
    <li class="fragment">then the arguments passed in at that position are condensed into a single <code class="highlighter-rouge">Array</code></li>
    <li class="fragment">for example:
      <pre><code data-trim="" contenteditable="">
function f(a, b, ...args) { console.log(args); }
f('foo', 'bar', 'baz', 'qux'); // prints out ['baz', 'qux']
</code></pre>
    </li>
    <li class="fragment">notice that every value after and including the 3rd argument are collected into an Array</li>
    <li class="fragment">again, this allows for an arbitrary number of trailing arguments to be passed in to a function</li>
    <li class="fragment">(this is called a <strong>variadic</strong> function, a function that can have and indefinite number of arguments / arity!)</li>
  </ul>

</section>

<section>
  <h2 id="es6-spread-and-rest-continued">ES6 Spread and Rest Continued</h2>

  <p>An operator that shares the same syntax but <strong>does the opposite of the rest operator</strong> is the <strong>spread operator</strong>.</p>

  <ul>
    <li class="fragment">the spread operator takes an Array and breaks it up into parts!</li>
    <li class="fragment">this can be used in function calls: <code class="highlighter-rouge">f(...someArray)</code></li>
    <li class="fragment">as well as in <code class="highlighter-rouge">Array</code> literals: <code class="highlighter-rouge">[1, 2, ...someArray]</code></li>
  </ul>

</section>

<section>
  <h2 id="spread-operator-in-function-calls">Spread Operator in Function Calls</h2>

  <p>The parameters for res are value and radix&#8230; and in this case, we&#39;re able to expand the incoming Array to fit the arguments by using the <strong>spread operator</strong>:</p>

  <pre><code data-trim="" contenteditable="">
const stuff = ['101', 2];
const res = parseInt(...stuff);
console.log(res);
</code></pre>

  <ul>
    <li class="fragment">the first element of stuff becomes the first argument to <code class="highlighter-rouge">parseInt</code>, the second becomes the last argument</li>
    <li class="fragment">if there are too few or too many elements in the <code class="highlighter-rouge">Array</code>, JavaScript will behave as if there were too few or too many arguments</li>
    <li class="fragment">which is to say&#8230; <em>fine</em> - excess arguments are ignored and arguments not given a value are undefined&#8230;</li>
  </ul>

</section>

<section>
  <h2 id="spread-operator-in-function-calls-continued">Spread Operator in Function Calls Continued</h2>

  <p><strong>What does the following code print out?</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const words = ['foo', 'bar'];
function logThreeThings(a, b, c) {
    console.log(a, b, c); 
}
logThreeThings(...words); 
</code></pre>

  <p class="fragment"><code class="highlighter-rouge">foo bar undefined</code></p>
</section>

<section>
  <h2 id="spread-operator-in-array-literals">Spread Operator in Array Literals</h2>

  <p>The <strong>spread operator</strong> can also be used to expand Arrays within Array literals:</p>

  <pre><code data-trim="" contenteditable="">
const words = ['foo', 'bar', 'baz'];
const moreWords = ['start', ...words, 'end']
console.log(moreWords);
// [ 'start', 'foo', 'bar', 'baz', 'end']
</code></pre>

  <p>You can also use the spread operator to make a shallow copy of an Array:</p>

  <pre><code data-trim="" contenteditable="">
const arrs = [[1, 2], [3, 4]];
const newArrs = [...arrs];
console.log(newArrs); // yay copied!

arrs[0].push('surprise!');
console.log(newArrs); // beware, shallow!
</code></pre>
</section>

<section>
  <h2 id="now-back-to-higher-order-functions-we-can-make-our-own">Now Back to Higher Order Functions; We Can Make Our Own!</h2>

  <h3 id="as-we-saw-with-our-own-implementations-of-some-array-methods">(As we saw with our own implementations of some array methods)</h3>

  <ul>
    <li>create functions that return entirely new functions (we&#39;ve done this)</li>
    <li>create functions that wrap or <em>decorate</em> other functions</li>
  </ul>
</section>

<section>
  <h2 id="lets-try-creating-a-wrapping-function">Let&#39;s Try Creating a Wrapping Function</h2>

  <p><strong>How about creating a function that logs how much time a function takes to execute?</strong> &#8594;</p>

  <ul>
    <li>create a function, <code>logExecutionTime</code>, that takes a function, <code>f</code>, as an argument</li>
    <li>it returns a new version of <code>f</code> that logs how much time it took to execute (in addition to doing whatever it usually does as a function, of course!)</li>
    <li>we can use <code>console.time</code> and <code>console.timeEnd</code> to take the timings</li>
  </ul>

</section>
<section>
  <h2 id="function-timing-implementation">Function Timing Implementation</h2>

  <p><strong>Here&#39;s one possible way to do it.</strong> &#8594;</p>

  <ul>
    <li>create a function that just calls the function passed into it</li>
    <li>and gives back whatever that function returns</li>
    <li>the only extra thing that it will do is take the time before and after the function call</li>
  </ul>

  <pre class="fragment"><code data-trim="" contenteditable="">
function logExecutionTime(f) {
	return function(arg) {
		console.time('function timing');
		const val = f(arg);
		console.timeEnd('function timing');
		return val; 
	};
}

function wasteTime(limit) { for(let i=0;i &lt; limit; i++) { }}
wasteTime = logExecutionTime(wasteTime);
wasteTime(5000000);
</code></pre>
</section>

<section>
  <h2 id="another-look-at-function-timing">Another Look at Function Timing</h2>

  <p>Hm. So&#8230; there&#39;s a limitation with regards to the kinds of functions that we can time. <strong>Can you spot it?</strong> &#8594;</p>

  <p class="fragment"><br />
<strong>Hint</strong>: <strong>How would it handle the following function?</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function wasteTime2(start, limit) { 
	for(let i = start; i &lt; limit; i++) { } 
}
</code></pre>

  <p class="fragment"><br />
<strong>What if the timed function needs more than one argument?</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function logExecutionTime(f) {
	return function(...args) {
		console.time('function timing');
        // use spread and rest
        val = f(...args);

        // old way with es5, with apply
		// const val = f.apply(null, arguments);
		console.timeEnd('function timing');
		return val; 
	};
}
wasteTime = logExecutionTime(wasteTime);
wasteTime(-5000000, 5000000);
</code></pre>

</section>

<section>
  <h2 id="decorators">Decorators</h2>

  <p>A function that accepts another function as a parameter, wraps its call in another function, and returns that wrapper as a new function&#8230; is called a <strong>function decorator</strong>.</p>

  <p><strong>Why might function decorators be a useful? When would it make sense to implement a decorator rather than to modify an actual function?</strong> &#8594;</p>

  <ul>
    <li class="fragment">they allow us to modify how a function runs, even one that we did not write!</li>
    <li class="fragment">decorators can be reused! for example, you can make any function a timed function, but should you need to change the implementation of timing, you only change it in one place</li>
    <li class="fragment">there&#39;s potential for combining / chaining decoratiors!</li>
  </ul>
</section>

<section>
  <h2 id="practical-applications">Practical Applications</h2>

  <p><strong>Decorators might come in handy whenever you want to do something before or after a function runs.</strong> &#8594;</p>

  <ul>
    <li class="fragment">as we saw, function timing makes a lot of sense</li>
    <li class="fragment">perhaps caching</li>
    <li class="fragment">permissions checking (before a function runs)</li>
  </ul>

</section>
<section>
  <h2 id="review">Review</h2>

  <p><strong>We just saw a bunch of higher order functions in JavaScript</strong>&#8230; and we even <strong>created our own</strong>.</p>

  <ul>
    <li>Array Methods
      <ul>
        <li>forEach</li>
        <li>map</li>
        <li>filter</li>
        <li>reduce</li>
      </ul>
    </li>
    <li>Function Methods
      <ul>
        <li>call</li>
        <li>apply</li>
        <li>bind</li>
      </ul>
    </li>
  </ul>

</section>

:ET