I".<section class="intro-slide">
  <h1 id="middleware">Middleware</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="middleware-1">Middleware</h2>

  <p>From the <a href="http://expressjs.com/api.html#middleware">Express docs</a>&#8230;</p>

  <blockquote>
    <p>A <strong>middleware</strong> is a function with access to the request object (req), the response object (res), and the next middleware in line in the request-response cycle of an Express application.</p>
  </blockquote>

  <ul>
    <li class="fragment">invoked before your final request handler is</li>
    <li class="fragment">(between the raw request and the final intended route)</li>
    <li class="fragment">called in order that they are added</li>
  </ul>
</section>

<section>
  <h2 id="whats-that-mean">What&#39;s That Mean?</h2>

  <p>Again, but with more details.</p>

  <ul>
    <li><strong>middleware</strong> is  <em>just</em> a <strong>function</strong></li>
    <li>it&#39;s a function that has three parameters:
      <ul>
        <li>a <strong>request</strong> object (usually <code>req</code>)</li>
        <li>a <strong>response</strong> object (usually <code>res</code>)</li>
        <li>and the <strong>next middleware function</strong> to be executed (conveniently called <code>next</code>)</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h1 id="hey-that-sounds-familiar-isnt-that-the-same-as-">Hey. That Sounds Familiar. <strong>Isn&#39;t That the Same As&#8230;</strong> &#8594;</h1>

</section>

<section>
  <h2 id="its-all-just-middleware">It&#39;s All Just Middleware</h2>

  <p>This should sound pretty familiar to you. <strong>It&#39;s the same kind of function that we pass to our <code>app.VERB</code> methods.</strong></p>

  <pre><code data-trim="" contenteditable="">
app.get('/', function(req, res) {
	res.send('Familiar, no?');
});
</code></pre>

  <ul>
    <li>the callback functions that we pass as arguments to these methods behave just like middleware</li>
    <li>it turns out, <strong>Express apps are just a bunch of middleware chained together and called sequentially</strong></li>
  </ul>
</section>

<section>
  <h1 id="an-express-application-is-essentially-a-stack-of-middleware-which-are-executed-serially">&quot;An Express application is essentially a stack of middleware which are executed serially.&quot;</h1>
</section>

<section>
  <h2 id="using-middleware">Using Middleware</h2>

  <p>Middleware can be:</p>

  <ul>
    <li><strong>application</strong> - executed for the entire application</li>
    <li>or <strong>router level</strong> - only executed for a specific path</li>
  </ul>

  <p><br />
You can use middleware simply by calling the aptly named:</p>

  <pre><code data-trim="" contenteditable="">
// for the whole application:
app.use(yourMiddleWareFunction);

// or... for a specific path:
app.use('path', yourMiddleWareFunction);
</code></pre>

</section>

<section>
  <h2 id="so-im-using-some-middleware">So&#8230; I&#39;m Using Some Middleware</h2>

  <p><strong>Can I have multiple middleware?</strong> &#8594;</p>

  <p class="fragment">The fact that there&#39;s a <code>next</code> parameter implies&#8230; <strong>YES!</strong></p>

  <p class="fragment"><strong>But what order is the middelware executed in?</strong> &#8594;</p>

  <ul class="fragment">
    <li>middleware functions are executed sequentially in the request-response cycle</li>
    <li>&#8230;which means that the order that middleware is included is significant!</li>
  </ul>
</section>

<section>
  <h1 id="middleware-functions-are-executed-in-the-order-of-their-inclusion">Middleware Functions are executed in the order of their inclusion!</h1>

</section>

<section>
  <h2 id="lets-try-creating-your-own-middleware">Let&#39;s Try Creating Your Own Middleware</h2>

  <p>So, you say you want to make your own middleware, eh? <strong>What can you do in your fancy middleware function?</strong> &#8594;</p>

  <ul class="fragment">
    <li>you can execute any code you want in your middleware (<em>anything your heart desires!</em>)</li>
    <li>because they have access to the request and response, they could change those objects before it gets to your routing (<strong>!!!</strong>)</li>
    <li>they could also end the whole request-response cycle by sending a response immediately</li>
    <li>or they could call the next middleware in the stack</li>
  </ul>

  <p class="fragment"><br />
<strong>Ohhhh. Is there a danger with calling render or send in middleware then?</strong> &#8594;</p>

  <p class="fragment">You can end up skipping other chained middleware.</p>
</section>

<section>
  <h2 id="calling-next">Calling Next</h2>

  <p>Furthermore, if the current middleware doesn&#39;t end the request-response cycle, it should really <strong>remember to call <code>next()</code></strong>. <strong>What will happen if it doesn&#39;t?</strong>  &#8594;</p>

  <ul class="fragment">
    <li>a response will never be sent</li>
    <li>the request will be left hanging</li>
    <li>(nothing good)</li>
  </ul>
</section>

<section>
  <h2 id="lets-build-some-hello-world-middleware">Let&#39;s Build Some Hello World Middleware</h2>

  <p><strong>Create middleware that always logs the word &#39;hello&#39; for every request.</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
app.use(function(req, res, next) {
	console.log('hello');
	next();
});
</code></pre>
</section>

<section>
  <h2 id="how-about-some-useful-middleware-please">How About Some Useful Middleware, Please!</h2>

  <p><strong>Create middleware that always logs the request&#39;s method and path.</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
app.use(function(req, res, next) {
	console.log(req.method, req.path);
	next();
});
</code></pre>

  <p>(<strong>also&#8230; let&#39;s play around with ordering.</strong> &#8594;)</p>
</section>

<section>
  <h2 id="one-last-custom-middleware">One Last Custom Middleware</h2>

  <p><strong>Does anyone remember a <em>response</em> header that identifies the type of server that&#39;s being run?</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
Server:Apache/2.2.22 (Ubuntu)
</code></pre>

  <p class="fragment"><strong>How about we set our own <code>Server</code> response header?</strong></p>

  <p class="fragment">We can use <code>res.set(headerName, headerValue)</code>.</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
app.use(function(req, res, next) {
	res.set('Server', 'MY AMAZING SUPER COOL SERVER');
	next();
});
</code></pre>
</section>
<section>
  <h2 id="about-that">About That&#8230;</h2>

  <p><strong>Actually, most people try to suppress or remove that Server header. Why?</strong> &#8594;</p>

  <p class="fragment">Security through obscurity!</p>

  <ul class="fragment">
    <li>maybe it&#39;s better if you don&#39;t reveal anything about your technology or infrastructure</li>
    <li>(what if there were known exploits for a specific version of the web server that you&#39;re running?)</li>
  </ul>
</section>

<section>
  <h2 id="all-together-if-you-were-curious">All Together (If You Were Curious)</h2>

  <pre><code data-trim="" contenteditable="">
const express = require('express');
const app = express();
</code></pre>
  <pre><code data-trim="" contenteditable="">
app.use(function(req, res, next) {
	console.log(req.method, req.path);
	next();
});
</code></pre>
  <pre><code data-trim="" contenteditable="">
app.use(function(req, res, next) {
	console.log('hello');
	next();
});
</code></pre>
  <pre><code data-trim="" contenteditable="">
app.use(function(req, res, next) {
	res.set('Server', 'MY AMAZING SUPER COOL SERVER');
	next();
});
</code></pre>
  <pre><code data-trim="" contenteditable="">
app.get('/', function(req, res) {
	res.send('We\'re done here');
});
</code></pre>
  <pre><code data-trim="" contenteditable="">
app.listen(3000);
</code></pre>
</section>

<section>
  <h2 id="pre-made-middleware">Pre-Made Middleware</h2>

  <p>Hey. So&#8230; DIY is cool and all, but making our own middleware seems like <em>a lot</em> of work. <strong>Are there any pre-built middleware out there? (hint we&#39;ve used one, and we&#39;ve seen others)</strong> &#8594;</p>

  <p class="fragment">Some middleware that we&#39;ve either seen or actually used:</p>

  <ul class="fragment">
    <li><strong>static files</strong></li>
    <li><strong>bodyparser</strong></li>
  </ul>
</section>

<section>
  <h2 id="the-static-file-middleware">The Static File Middleware</h2>

  <p><strong>What do you think the static file middleware does? How does it work in the request-response life cycle?</strong> &#8594;</p>

  <ul class="fragment">
    <li>it checks the path in the incoming request</li>
    <li>tries to find if the file exists in the file system</li>
    <li>if it doesn&#39;t, it calls the next middleware (so if the path is not there, it&#39;ll drop through to your routes)</li>
    <li><a href="http://expressjs.com/api.html#express.static">more info in the docs</a></li>
  </ul>
</section>

<section>
  <h2 id="using-the-static-file-middleware">Using the Static File Middleware</h2>

  <p><strong>How do we actually use the static file middleware?</strong> &#8594;</p>

  <ul class="fragment">
    <li>(there&#39;s nothing to install, it&#39;s bundled with express)</li>
    <li>you only need to specify your public directory (but you could be <em>courteous</em> about it)</li>
  </ul>

  <pre class="fragment"><code data-trim="" contenteditable="">
app.use(express.static('public'));
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
const path = require('path');
const publicPath = path.resolve(__dirname, 'public');
app.use(express.static('public'));
</code></pre>

  <!--__ -->
</section>

<section>
  <h2 id="playing-well-with-others">Playing Well With Others</h2>

  <p><strong>By the way&#8230; if we were using our logging middleware from before, how do we make sure that requests handled by the static file middleware are actually logged?</strong> &#8594;</p>

  <p class="fragment">Just make sure that logging is included (<code>app.use</code>) before static files.</p>
</section>

<section>
  <h2 id="body-parser">Body Parser</h2>

  <p>The body parser middleware:</p>

  <ul>
    <li>parses the body (<em>of course</em>) of a request object&#8230; <strong>why does a request body need parsing?</strong> &#8594;
      <ul>
        <li class="fragment">it&#39;s probably encoded</li>
        <li class="fragment">it&#39;s probably compressed</li>
      </ul>
    </li>
    <li class="fragment">body parser gives you access to a compressed and encoded body as JavaScript object
      <ul>
        <li class="fragment">we&#39;ll mostly use it for urlencoded strings</li>
        <li class="fragment"><code>app.use(express.urlencoded({ extended: false }));</code></li>
      </ul>
    </li>
    <li class="fragment"><a href="https://github.com/expressjs/body-parser">more info in the docs</a></li>
  </ul>
</section>

<section>
  <h1 id="ahhhh-so-why-what-kind-of-request-actually-has-data-in-the-body">Ahhhh. So Why? What kind of request actually has data in the body?</h1>
</section>

<section>
  <h2 id="post-requests">POST Requests</h2>

  <p><strong>POST</strong> requests send their data in the body. <strong>How can we issue a POST request?</strong> &#8594;</p>

  <ul class="fragment">
    <li>forms</li>
    <li>(actually, we can also do it with CURL, Chrome apps/plugins, programmatic clients, like <code>request</code>)</li>
  </ul>

  <p class="fragment"><br />
<strong>Sooooo&#8230; maybe it&#39;s time to figure out what this form thing is all about.</strong> &#8594;</p>
</section>
:ET