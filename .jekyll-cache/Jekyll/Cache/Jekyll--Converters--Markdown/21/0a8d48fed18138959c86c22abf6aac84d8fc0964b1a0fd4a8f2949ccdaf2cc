I"G<style>
hr {
    color: #ccc;
    border-color: #ccc;
}
</style>

<div class="panel panel-default">
	<div class="panel-heading">Homework #3</div>
	<div class="panel-body">

    <h1 id="creating-a-tiny-web-framework-due-thursday-october-5th-by-11pm">Creating a Tiny Web Framework, <strong>Due Thursday, October 5th by 11PM</strong></h1>

    <h2 id="overview">Overview</h2>

    <h3 id="description">Description</h3>

    <p>You&#39;ll be writing a small web framework that allows a developer to write simple web applications. These web applications will be built off of and run from node&#39;s built-in TCP server (from the <code class="highlighter-rouge">net</code> module).</p>

    <p><strong>You can only use the following two modules for this assignment</strong> &#8594;</p>

    <ol>
      <li><code class="highlighter-rouge">net</code> - a module for creating TCP servers and clients</li>
      <li><code class="highlighter-rouge">fs</code> - a module for file system related tasks, such as reading and writing files</li>
    </ol>

    <p><strong>You can&#39;t use the <code class="highlighter-rouge">http</code> module&#8230; or install additional frameworks, such as <code class="highlighter-rouge">express</code></strong></p>

    <h3 id="submission-process">Submission Process</h3>

    <p>You will be given access to a private repository on GitHub. It will contain:</p>

    <ol>
      <li>stub source files in the <code class="highlighter-rouge">src</code> directory</li>
      <li>default assets (images, css, etc.) in the <code class="highlighter-rouge">public</code> folder</li>
      <li>unit tests in <code class="highlighter-rouge">test</code></li>
      <li>various configuration files, such as <code class="highlighter-rouge">package.json</code>, <code class="highlighter-rouge">.eslintrc</code>, etc.</li>
    </ol>

    <ul>
      <li><strong>Push</strong> your changes to the homework repository on GitHub.</li>
      <li>Commits later than the deadline will not be included in grading</li>
    </ul>

    <h3 id="points-make-at-least-4-commits">(4 points) Make at Least 4 Commits</h3>

    <ul>
      <li>Commit multiple times throughout your development process.</li>
      <li>Make at least 3 separate commits - (for example, one option may be to make one commit per part in the homework).</li>
    </ul>

    <h2 id="miniweb---framework-overview"><code class="highlighter-rouge">miniWeb</code> - Framework Overview</h2>

    <h3 id="about-the-framework">About the Framework</h3>

    <p>Your framework, called <code class="highlighter-rouge">miniWeb</code>, will be built off of node&#39;s <code class="highlighter-rouge">net</code> module. It&#39;ll use the <code class="highlighter-rouge">net</code> module to create a TCP server that will allow connections from clients. The code that you&#39;ll write will handle an incoming http request from a client by parsing the http request, determining what do based on the request, and finally sending back an http response. You&#39;ll do this by minimally creating these objects (you can create more objects, but these 3 must be present):</p>

    <ol>
      <li><code class="highlighter-rouge">Request</code> - an object that represents an http request</li>
      <li><code class="highlighter-rouge">Response</code> - an object that represents an http response&#8230; and has the ability to actually send back a response to the client</li>
      <li><code class="highlighter-rouge">App</code> - represents your web application; takes incoming requests and determines what to do based on path, method, etc. &#8230;</li>
    </ol>

    <p>You can use the objects that you create to write simple web applications. Here are some example of how you might use your mini web framework. Again, <strong>you are making the library / objects / module</strong> that makes the following possible:</p>

    <ul>
      <li>Create a new web application
        <pre><code data-trim="" contenteditable="">const App = require('./miniWeb.js').App;
const app = new App();
</code></pre>
      </li>
      <li>Serve the contents of the file in <code class="highlighter-rouge">$PROJECT_ROOT/html/index.html</code> when a request for <code class="highlighter-rouge">/</code> is received
        <ul>
          <li>here&#39;s the code that you would use:
            <pre><code data-trim="" contenteditable="">app.get('/', function(req, res) {
  res.sendFile('/html/index.html');
});
</code></pre>
          </li>
        </ul>
      </li>
      <li>Serve the string <code class="highlighter-rouge">"just some text"</code> as plain text (<code class="highlighter-rouge">text/plain</code>)by manually setting a <code class="highlighter-rouge">Content-Type</code> header, status code, and response body &#8230;when a request for the path, <code class="highlighter-rouge">/just/text</code>, is received
        <pre><code data-trim="" contenteditable="">app.get('/just/text', function(req, res) {
  // set header
  res.setHeader('Content-Type', 'text/plain');

  // return a 200 with body, "just some text"
  res.send(200, 'just some text!');
});
</code></pre>
      </li>
      <li>Send back a temporary redirect when a client requests the path, <code class="highlighter-rouge">/gone</code>
        <pre><code data-trim="" contenteditable="">app.get('/gone', function(req, res) {

  // set the status code and location of a redirect
  res.redirect(301, '/just/text');
});
</code></pre>
      </li>
      <li>Bind your application / web server to port 8080 on localhost
        <pre><code data-trim="" contenteditable="">app.listen(8080, '127.0.0.1');
</code></pre>
      </li>
    </ul>

    <h3 id="building-the-framework">Building the Framework</h3>

    <p>This homework is split into <strong>3 parts</strong>. Coding starts with <strong>part 1</strong>.</p>

    <p>Each part builds off of the previous, with the last parts culminating in finishing up your web framework and building a small fan site 💖 with your web framework! (YES!). <strong>Please do the following in order!</strong> &#8594;</p>

    <ol>
      <li><strong>Part 1 - Warm Up</strong> - get familiar with the <code class="highlighter-rouge">net</code> module!
        <ul>
          <li>work with nodes&#39; net module to create a simple server</li>
          <li>use callbacks to handle new connections and arriving data</li>
          <li>handle http requests from the browser</li>
          <li>create a small &quot;hello world&quot; site</li>
        </ul>
      </li>
      <li><strong>Part 2 - Even Warmer</strong> - build on the previous part, but adding functionality through <code class="highlighter-rouge">Request</code> and <code class="highlighter-rouge">Response</code> objects
        <ul>
          <li>create a <code class="highlighter-rouge">Request</code> object to encapsulate http requests</li>
          <li>create a <code class="highlighter-rouge">Response</code> object to encapsulate http responses; this object will be able to:
            <ul>
              <li>send http responses back using a socket object</li>
              <li>read files from the file system to send back</li>
            </ul>
          </li>
          <li>create a small site that serves html <em>and</em> images (SUCH WOW! 😮)</li>
        </ul>
      </li>
      <li><strong>Part 3 - Converting to App Object</strong>
        <ul>
          <li>create an app object that encapsulates your server&#8230;</li>
          <li>add application level functionality, such as routing</li>
        </ul>
      </li>
      <li><strong>Part 4 - Using your Module!</strong>
        <ul>
          <li>create a fan site using the module and &quot;Classes&quot; that you just made! 🎉</li>
        </ul>
      </li>
    </ol>

    <h2 id="part-1---warm-up">Part 1 - Warm Up</h2>

    <p>In this part, you&#39;ll get familiarize yourself with the <code class="highlighter-rouge">net</code> module by creating a simple server that responds to http requests. You&#39;ll make use of events and callback functions to handle a new connection, data arriving on a socket and closing a connection.</p>

    <p>Start by opening <code class="highlighter-rouge">src/warmUp.js</code>. Create a simple server that responds to any request with a valid http response that says <code class="highlighter-rouge">hello world</code> (as html, with surrounding markup)&#8230; the response will have:</p>

    <ol>
      <li>a status code of <code class="highlighter-rouge">200</code></li>
      <li>a <code class="highlighter-rouge">Content-Type</code> header of <code class="highlighter-rouge">text/html</code></li>
      <li>a body that contains the following markup:
        <pre><code data-trim="" contenteditable=""> &lt;em&gt;Hello&lt;/em&gt; &lt;strong&gt;World&lt;/strong&gt; </code></pre>
      </li>
    </ol>

    <p>Use the following process to do this:</p>

    <ol>
      <li>Check out the <a href="../slides/06/sockets.html#/2">slides on the <code class="highlighter-rouge">net</code> module for some prep</a>, paying close attention to the <a href="../slides/06/sockets.html#/10">the last slide</a>.</li>
      <li>Build off of the last example by modifying the echo server code to&#8230;</li>
      <li>Write back a valid http response (you can write a string directly instead of using a <code class="highlighter-rouge">Buffer</code>):
        <ul>
          <li><a href="../slides/05/web.html#/16">see the slides on http</a></li>
          <li><a href="../slides/05/web.html#/24">and an example response</a></li>
        </ul>
      </li>
      <li>Close the connection after a <code class="highlighter-rouge">write</code> with <code class="highlighter-rouge">sock.end</code>.</li>
      <li>Run <code class="highlighter-rouge">warmup.js</code> (note that your terminal will look like its &quot;frozen&quot;, but it&#39;s really just waiting for requests).</li>
      <li>Use <code class="highlighter-rouge">curl -i localhost:8080</code> to test your server.</li>
      <li>Then point your browser at <code class="highlighter-rouge">http://localhost:8080</code>.</li>
      <li>Make sure that the html renders (it should have italicized and bold text).</li>
      <li>To shutdown your server, CTRL + c in your terminal&#8230;</li>
      <li>Here&#39;s an example of what it might look like: <br /> <img src="/csci-ua.0480-fall2017-007/resources/img/hw03-01-warmUp.gif" alt="pic alt" /></li>
    </ol>

    <p>Troubleshooting</p>

    <ol>
      <li>If your browser doesn&#39;t show anything, make sure you&#39;re calling <code class="highlighter-rouge">sock.end</code>.</li>
      <li>If html is showing up as text (that is, you see the tags / mark-up in the page itself), double check that you&#39;ve set the content type correctly.</li>
    </ol>

    <h2 id="part-2---even-warmer---a-request-and-response-object">Part 2 - Even Warmer - a Request and Response Object</h2>

    <p>In this part, you&#39;ll build off of your experience from part 1 by creating a <code class="highlighter-rouge">Request</code> and <code class="highlighter-rouge">Response</code> object. You&#39;ll use these objects and some simple routing to create a page that has an image and an external css file.</p>

    <h3 id="start-by-creating-a-request-object">Start by creating a <code class="highlighter-rouge">Request</code> object</h3>

    <p>In this section, you&#39;ll fully implement a <code class="highlighter-rouge">Request</code> object. You&#39;ll then conditionally serve up different content based on the <code class="highlighter-rouge">path</code> specified by the request.  The <code class="highlighter-rouge">Request</code> object <strong>represents an http request</strong>. It can take an http request as a string, parse out information about that request and expose that information as properties (such as <code class="highlighter-rouge">method</code>, <code class="highlighter-rouge">path</code>, and <code class="highlighter-rouge">headers</code>). It assumes HTTP/1.1</p>

    <p>In <code class="highlighter-rouge">evenWarmer.js</code>, copy over your code to create a simple server, and make modifications to it so that it parses the request into a request object.</p>

    <p>Create the <code class="highlighter-rouge">Request</code> <em>class</em>  by implementing the following:</p>

    <hr />

    <h4 id="constructor">Constructor</h4>

    <p><code class="highlighter-rouge">Request(httpRequest)</code> - creates a new request object based on the string passed in.</p>

    <pre><code data-trim="" contenteditable="">let s = ''
s += 'GET /foo.html HTTP/1.1\r\n';   // request line
s += 'Host: localhost:8080\r\n';     // headers
s += '\r\n\r\n';                     // empty line to mark the boundary between the header and body

const req = new Request(s);
</code></pre>

    <p>The string passed in will be parsed into the properties shown below. <strong>You can assume that you will always receive a valid http request</strong></p>

    <hr />

    <h4 id="properties">Properties</h4>

    <ol>
      <li><code class="highlighter-rouge">path</code> - the path requested (for example, <code class="highlighter-rouge">/foo/bar/baz.html</code>)</li>
      <li><code class="highlighter-rouge">method</code> - the http verb (for example, <code class="highlighter-rouge">GET</code> or <code class="highlighter-rouge">POST</code>)</li>
      <li><code class="highlighter-rouge">headers</code> - an object that has header names as property names and header values as property values (for example, <code class="highlighter-rouge">{"Host": "localhost:8080", "User-Agent": "Mozilla/5.0 ..."}</code>)</li>
      <li><code class="highlighter-rouge">body</code> - the body of the request (for example, <code class="highlighter-rouge">username=foo</code>)</li>
    </ol>

    <p>Note that our <code class="highlighter-rouge">Request</code> object will assume HTTP/1.1, so it&#39;s not required to keep version as a property (though you can if you want!).</p>

    <hr />

    <h4 id="methods">Methods</h4>

    <ol>
      <li><code class="highlighter-rouge">toString</code> - returns a string representation of the request object as a valid http request (essentially taking its properties and creating a request - or another way of looking at it is recreating the original string passed in to the constructor)</li>
    </ol>

    <p>You can add additional properties and methods as needed.</p>

    <hr />

    <h4 id="example-usage">Example Usage</h4>

    <pre><code data-trim="" contenteditable="">let s = ''
s += 'GET /foo.html HTTP/1.1\r\n';   // request line
s += 'Host: localhost:8080\r\n'; // headers
s += '\r\n\r\n';                     /

const req = new Request(s);

console.log(req.path);
// --&gt; /foo.html

console.log(req.method);
// --&gt; GET

console.log(req.headers);
// --&gt; {'Host': 'localhost:8080' }

console.log(req.body);
// --&gt; ''
// the body is empty in this case ^^^

console.log(req.toString()); // or req + ''
// --&gt;
// GET /foo.html HTTP/1.1\r\n
// Host: localhost:8080
// 
// (notice the empty line above to denote header / body boundary)
</code></pre>

    <hr />

    <h3 id="using-the-request-object">Using the <code class="highlighter-rouge">Request</code> Object</h3>

    <p>Once your finished with your implementation above, you can export, test and try using your new <code class="highlighter-rouge">Request</code> object.</p>

    <ol>
      <li>Export the object using <code class="highlighter-rouge">module.exports</code>, and try running the tests in test/request-response-test.js
        <ul>
          <li>make sure that <code class="highlighter-rouge">mocha</code> is installed as in previous assignments</li>
          <li>install dev dependencies to run tests: npm install &#8211;save-dev chai sinon mocha-sinon (you can ignore any unmet peer dependency warnings)</li>
          <li><code class="highlighter-rouge">mocha test/request-response-test.js</code></li>
        </ul>
      </li>
      <li>In your previous code, <code class="highlighter-rouge">sock.on('data', someCallback)</code> calls <code class="highlighter-rouge">someCallback</code> when the socket receives data&#8230; and that callback takes a single argument, the binary data that the client sent. Pass that data to your <code class="highlighter-rouge">Request</code> constructor to create a <code class="highlighter-rouge">Request</code> object</li>
      <li>Once you have the http request encapsulated by a <code class="highlighter-rouge">Request</code> object&#8230; use a simple conditional to:
        <ol>
          <li>Check if the <code class="highlighter-rouge">Request</code> object&#39;s path is <code class="highlighter-rouge">/</code> &#8230; if so, display your hello world page.</li>
          <li>Check if the <code class="highlighter-rouge">Request</code> object&#39;s path is <code class="highlighter-rouge">/foo.css</code> &#8230; if so, send back a document with content type <code class="highlighter-rouge">text/css</code> containing <code class="highlighter-rouge">h2 {color: red;}</code>.</li>
          <li>If it&#39;s neither <code class="highlighter-rouge">/</code> or <code class="highlighter-rouge">/foo.css</code>, then send back a <code class="highlighter-rouge">404</code>, content type &#39;text/plain&#39;, and a body of <code class="highlighter-rouge">uh oh... 404 page not found!</code>.</li>
        </ol>
      </li>
      <li>Make sure to close the connection once you&#39;ve written your http response by using <code class="highlighter-rouge">sock.end()</code></li>
      <li>Run your server and check all 3 of these paths using both <a href="../slides/05/web.html#/25">curl</a> and your browser.
        <ul>
          <li>You should see a <code class="highlighter-rouge">200</code> for <code class="highlighter-rouge">/</code> and <code class="highlighter-rouge">/foo.css</code>, along with the appropriate <code class="highlighter-rouge">Content-Type</code> header, and the body.</li>
          <li>You should see a <code class="highlighter-rouge">404</code> for everything else.</li>
        </ul>
      </li>
      <li>Finally, to see how everything works together, modify the html that <code class="highlighter-rouge">/</code> sends back:
        <ul>
          <li>Above hello world, include your style sheet using a <code class="highlighter-rouge">link</code> tag in your response for <code class="highlighter-rouge">/</code>&#8230;</li>
          <li>Also above hello world, but below your link tag, add an <code class="highlighter-rouge">h2</code> tag that contains the text, &#39;this is a red header!&#39;</li>
          <li>When you point your browser at `localhost:8080&#39;, you should now see a red header above your hello world text.</li>
        </ul>
      </li>
      <li>It should look something like <br /> <img src="/csci-ua.0480-fall2017-007/resources/img/hw03-02-evenWarmer-01-request.gif" alt="pic alt" /></li>
    </ol>

    <h3 id="and-now-for-our-response-object">And now, for our <code class="highlighter-rouge">Response</code> object</h3>

    <p>Instead of issuing <code class="highlighter-rouge">write</code> calls to the <code class="highlighter-rouge">socket</code> object, you&#39;ll wrap the <code class="highlighter-rouge">socket</code> up in a <code class="highlighter-rouge">Response</code> object and use that to send data to the client. Notice that all of the <code class="highlighter-rouge">methods</code> called on socket are being being called by equivalent methods on your <code class="highlighter-rouge">Response</code> object.</p>

    <p>The <code class="highlighter-rouge">Response</code> object represents an http response, and it allows direct manipulation of the underlying socket that represents the current connection for the http request/response. It can hold data about an http response, turn that data into a valid http response&#8230; and send that data back to the client (as well as close the connection between the server and the client).</p>

    <p>Create a <code class="highlighter-rouge">Response</code> <em>class</em> based on the <a href="#response">specifications below</a>.</p>

    <ul>
      <li>Note that it may be useful to keep an object that maps status codes to short descriptions ({&quot;200&quot;: &quot;OK&quot;, &quot;404&quot;: &quot;Not Found&quot;})</li>
      <li>You can run unit tests as you work, as usual, by adding the object to <code class="highlighter-rouge">module.exports</code>, and running the tests in test/request-response-test.js
        <ul>
          <li>again &#8230; <code class="highlighter-rouge">mocha test/request-response-test.js</code></li>
          <li><strong>not all methods are tested</strong> by the unit tests ⚠️️⚠️️⚠️️</li>
        </ul>
      </li>
    </ul>

    <p><a name="response"></a></p>

    <hr />

    <h4 id="constructor-1">Constructor</h4>

    <p><code class="highlighter-rouge">Response(socket)</code> - creates a new response object using the socket passed in as an argument to send data to the client.</p>

    <pre><code data-trim="" contenteditable=""> // when a socket, named sock, receives data...
// where sock is an object that represents connection a client
const res = new Response(sock);
</code></pre>

    <p>The constructor will set the socket instance passed in as a property on the resulting <code class="highlighter-rouge">Response</code> object. The socket will then be used to send data back to the client.</p>

    <hr />

    <h4 id="properties-1">Properties</h4>

    <ol>
      <li><code class="highlighter-rouge">sock</code> - the socket associated with the http response</li>
      <li><code class="highlighter-rouge">headers</code> - an object that has response header names as property names and response header values as property values (for example, <code class="highlighter-rouge">{"Content-Type": "text/html", "Cache-Control": "max-age=3600"}</code>)</li>
      <li><code class="highlighter-rouge">body</code> - the body of the response (such as an html document or an image)</li>
      <li><code class="highlighter-rouge">statusCode</code> - the status code of the http response as a <code class="highlighter-rouge">Number</code> (for example: <code class="highlighter-rouge">200</code>)</li>
    </ol>

    <hr />

    <h4 id="methods-1">Methods</h4>

    <p>Most of the methods in the <code class="highlighter-rouge">Response</code> either act as a proxy for <code class="highlighter-rouge">socket</code> methods (that is, you can call <code class="highlighter-rouge">end</code> on <code class="highlighter-rouge">Response</code>, which internally just calls <code class="highlighter-rouge">end</code> on its <code class="highlighter-rouge">sock</code> property) or are convenience methods for combining other <code class="highlighter-rouge">Response</code> object methods. Consequently, it would be useful to check out the <a href="../slides/06/sockets.html">slides on networking and sockets</a> before starting. Alternatively, you can also look over the <a href="https://nodejs.org/api/net.html">official node documentation on the <code class="highlighter-rouge">net</code> module</a>.</p>

    <ol>
      <li><code class="highlighter-rouge">setHeader(name, value)</code> - adds a new header name and header value pair to this <code class="highlighter-rouge">Response</code> object&#39;s internal <code class="highlighter-rouge">headers</code> property
        <ul>
          <li><code class="highlighter-rouge">name</code> - the name of the response header</li>
          <li><code class="highlighter-rouge">value</code> - the value of the response header</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.setHeader('Content-Type', 'text/html'); </code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">write(data)</code> - sends data to the client by calling the <code class="highlighter-rouge">write</code> method on this <code class="highlighter-rouge">Response</code> object&#39;s internal socket object (essentially a pass-through / proxy method to call the same method on <code class="highlighter-rouge">this.sock</code>)
        <ul>
          <li><code class="highlighter-rouge">data</code> - a <code class="highlighter-rouge">String</code> or <code class="highlighter-rouge">Buffer</code> (binary data) to be sent to the client</li>
          <li>no return value</li>
          <li>note that <em>all it does</em> is write <code class="highlighter-rouge">data</code> to the socket, nothing else (it doesn&#39;t close the connection or add additional data to <code class="highlighter-rouge">data</code> )</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.write("&lt;h2&gt;A bit o' HTML&lt;/h2&gt;"); </code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">end(s)</code> - sends data and ends the connection by callings the <code class="highlighter-rouge">end</code> method on this <code class="highlighter-rouge">Response</code> object&#39;s internal socket object (essentially a pass-through / proxy method to call the same method on <code class="highlighter-rouge">this.sock</code>)
        <ul>
          <li>note that you will not be able to send any more data on a closed socket (this also implies that you cannot call end more than once for a single request/response cycle)</li>
          <li>also note that you should not call <code class="highlighter-rouge">sock.write</code> at all in this method; again, just make the same call to <code class="highlighter-rouge">sock.end</code> (which can take an argument if you want it to write data to the socket <em>and</em> end the connection)</li>
          <li><code class="highlighter-rouge">s</code> - a <code class="highlighter-rouge">String</code> or <code class="highlighter-rouge">Buffer</code> (binary data) to be sent to the client</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.write("some stuff"); 
res.end('some more stuff'); // closes connection!
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">send(statusCode, body)</code> - sets the statusCode and the body of this <code class="highlighter-rouge">Request</code> object, sends the valid http response to the client, and closes the connection. Essentially, it sets response properties, converts the <code class="highlighter-rouge">Response</code> to a string uses the <code class="highlighter-rouge">Response</code> object&#39;s <code class="highlighter-rouge">end</code> method to send the response and close the connection&#8230; all in one method call.
        <ul>
          <li><code class="highlighter-rouge">statusCode</code> - the status code of the http response</li>
          <li><code class="highlighter-rouge">body</code> - the body of the http response</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.setHeader('Content-Type', 'text/html');
res.send(200, 'Hi there!');
// sends back the following http response (newlines are \r\n):
// HTTP/1.1 200 OK
// Content-Type: text/html
//
// Hi there!
// (then closes the connection)
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">writeHead(statusCode)</code> - sets the statusCode, and writes everything but the body, and leaves the connection open; this is simply a combination of setting the <code class="highlighter-rouge">statusCode</code> property and calling <code class="highlighter-rouge">this.write</code>
        <ul>
          <li>another way to think about it is that: it writes out all of the headers (including the status line), and after you call writeHead, you can continue writing more data, such as the body of the response with something like <code class="highlighter-rouge">write</code></li>
          <li><code class="highlighter-rouge">statusCode</code> - the status code of the http response</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.setHeader('Content-Type', 'text/html');
res.writeHead(200);
// connection isn't closed yet! we can still write more
res.write('More stuff');
res.end('');
// sends back the following http response (newlines are \r\n):
// HTTP/1.1 200 OK
// Content-Type: text/html
//
// More stuff
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">redirect(statusCode, url)</code> - redirects to the supplied <code class="highlighter-rouge">url</code> using the supplied <code class="highlighter-rouge">statusCode</code>&#8230; if <code class="highlighter-rouge">statusCode</code> is no given, then default to permanent redirect, <code class="highlighter-rouge">301</code> (for the redirect to work, the appropriate header must be set to the url provided!). Lastly, immediately sends response and closes connection.
        <ul>
          <li><code class="highlighter-rouge">statusCode</code> - (optional) the status code of the http response redirect</li>
          <li><code class="highlighter-rouge">url</code> - the url to redirect to</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.redirect(302, 'http://another.site/here');
// response is immediately sent and connection is closed
// (essentially ... set statusCode and header, then this.write and this.end or just this.end)
</code></pre>
          </li>
          <li>troubleshooting:
            <ul>
              <li>some browsers, such as Chrome, will cache redirects &#8230; so you&#39;ll have to&#8230;</li>
              <li>check with curl first to see that you&#39;re getting the right status code and headers</li>
              <li>check with your browser next, making sure to clear your browser cache before trying again (and perhaps use &quot;incognito&quot; mode)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">toString()</code> - returns a string representation of this response object that can serve as a valid http response
        <ul>
          <li>no arguments</li>
          <li>returns a string, a valid http response</li>
          <li>when adding a short description for status codes, use these descriptions:
            <ul>
              <li><code class="highlighter-rouge">200</code> - <code class="highlighter-rouge">OK</code></li>
              <li><code class="highlighter-rouge">404</code> - <code class="highlighter-rouge">Not Found</code></li>
              <li><code class="highlighter-rouge">500</code> - <code class="highlighter-rouge">Internal Server Error</code></li>
              <li><code class="highlighter-rouge">400</code> - <code class="highlighter-rouge">Bad Request</code></li>
              <li><code class="highlighter-rouge">301</code> - <code class="highlighter-rouge">Moved Permanently</code></li>
              <li><code class="highlighter-rouge">302</code> - <code class="highlighter-rouge">Found</code></li>
              <li><code class="highlighter-rouge">303</code> - <code class="highlighter-rouge">See Other</code></li>
            </ul>
          </li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.setHeader('Content-Type': 'text/plain');
res.statusCode = 404;
res.body = "Uh oh! No page here!"
console.log(res.toString());
// HTTP/1.1 404 Not Found
// Content-Type: 'text/plain'
//
// Uh oh! No page here!
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">sendFile</code> is a bit lengthy, so we&#39;ll save this for later! ⚠️️</li>
    </ol>

    <hr />

    <h3 id="using-the-response-object">Using the <code class="highlighter-rouge">Response</code> Object</h3>

    <p><strong>Now let&#39;s test your new <code class="highlighter-rouge">Response</code> object in your original application!</strong></p>

    <ol>
      <li>To see your <code class="highlighter-rouge">Response</code> object at work, remove your calls to <code class="highlighter-rouge">sock.write</code> / <code class="highlighter-rouge">sock.end</code> and use a new <code class="highlighter-rouge">Response</code> object instead.</li>
      <li>Again, within the callback that you pass to <code class="highlighter-rouge">sock.on('data', someCallback)</code> and after you create a <code class="highlighter-rouge">Request</code> object, create a <code class="highlighter-rouge">Response</code> object&#8230;.
        <ul>
          <li>Pass in the <code class="highlighter-rouge">sock</code> object that&#39;s in scope (that is the socket object that <code class="highlighter-rouge">on</code> was called on)</li>
          <li>For example:
            <pre><code data-trim="" contenteditable=""> sock.on('data', function(binaryData) {
  const res = new Response(sock);
  // ...
}
</code></pre>
          </li>
        </ul>
      </li>
      <li>Replace every call to <code class="highlighter-rouge">sock.write</code> / <code class="highlighter-rouge">sock.end</code> with:
        <ul>
          <li>A call to your <code class="highlighter-rouge">Response</code> object&#39;s <code class="highlighter-rouge">setHeader</code> method to set the content type: <code class="highlighter-rouge">res.setHeader(...)</code></li>
          <li>A call to your <code class="highlighter-rouge">Response</code> object&#39;s <code class="highlighter-rouge">send</code> method to send the response back with the appropriate body: <code class="highlighter-rouge">res.send(200, ...);</code></li>
          <li>A call to your <code class="highlighter-rouge">Response</code> object&#39;s <code class="highlighter-rouge">end</code> method to close the connection</li>
        </ul>
      </li>
      <li>Everything should still work as it did previously, so try using curl and your browser to request <code class="highlighter-rouge">/</code>, <code class="highlighter-rouge">/foo.css</code>, and any other page to trigger a 404</li>
    </ol>

    <p><br /></p>

    <h3 id="wait-one-more-method-sending-back-files">Wait, One More Method: Sending back files</h3>

    <p>There&#39;s one last method that we&#39;ll implement on <code class="highlighter-rouge">Response</code>:</p>

    <p><code class="highlighter-rouge">sendFile(fileName)</code> - sends file specified by fileName (which will be searched for in <code class="highlighter-rouge">$PROJECT_ROOT/public</code>) to client by specifying appropriate content type, writing the data from the file&#8230; and immediately closing the connection after the data is sent</p>

    <ul>
      <li><code class="highlighter-rouge">fileName</code> - the name of the file to be sent</li>
      <li>no return value</li>
      <li>implementation details
        <ul>
          <li>use the <code class="highlighter-rouge">fs</code> module and the <a href="https://nodejs.org/api/fs.html#fs_fs_readfile_file_options_callback"><code class="highlighter-rouge">readFile</code> function</a> to do this instead of using <code class="highlighter-rouge">readline</code> like we did previously (this is because we may be handling binary data)</li>
          <li><code class="highlighter-rouge">fileName</code> is searched for in <code class="highlighter-rouge">./public</code></li>
          <li>consequently, you <strong>should</strong> prefix the <code class="highlighter-rouge">fileName</code> with <code class="highlighter-rouge">__dirname + '/../public'</code> to get an absolute path to the file</li>
          <li>you&#39;ll have to set the content type based on the file (using the file&#39;s extension is adequate for this assignment)</li>
          <li>minimally, support the following extensions and file types:
            <ol>
              <li><code class="highlighter-rouge">jpeg</code> or <code class="highlighter-rouge">jpg</code>: <code class="highlighter-rouge">image/jpeg</code></li>
              <li><code class="highlighter-rouge">png</code>: <code class="highlighter-rouge">image/png</code></li>
              <li><code class="highlighter-rouge">gif</code>: <code class="highlighter-rouge">image/gif</code></li>
              <li><code class="highlighter-rouge">html</code>: <code class="highlighter-rouge">text/html</code></li>
              <li><code class="highlighter-rouge">css</code>: <code class="highlighter-rouge">text/css</code></li>
              <li><code class="highlighter-rouge">txt</code>: <code class="highlighter-rouge">text/plain</code></li>
            </ol>
          </li>
          <li>if the file is an image type, then don&#39;t specify an encoding to <code class="highlighter-rouge">readFile</code></li>
          <li>if the file is text, then just assume <code class="highlighter-rouge">utf8</code></li>
          <li>you&#39;ll need a callback function &#8230; which means that if you want to access the correct <code class="highlighter-rouge">this</code> or have arguments, you&#39;ll have to use use arrow functions or bind (see the hints on this in later instructions)</li>
          <li>in your callback
            <ul>
              <li>send back a 500 error if something went wrong</li>
              <li>otherwise&#8230; <strong>do this in the following order</strong>:
                <ol>
                  <li>set the content type by setting the appropriate header</li>
                  <li>write the head first using <code class="highlighter-rouge">this.writeHead(200);</code></li>
                  <li><strong>then send the data from the file</strong>&#8230; <code class="highlighter-rouge">this.write(data);</code></li>
                  <li>finally, end the connection &#8230; <code class="highlighter-rouge">this.end()</code></li>
                </ol>
              </li>
              <li>the above ensures that the binary data is set as binary data rather than being converted to a string first</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>example usage:
        <pre><code data-trim="" contenteditable="">// assuming there's a directory called public/css in your project's root...
res.sendFile('/css/base.css');
//
// note that the url does not have to match the name/path of the file being read!
</code></pre>
      </li>
      <li>troubleshooting:
        <ul>
          <li>if you receive <code class="highlighter-rouge">Error: This socket has been ended by the other party</code>, it likely means that <code class="highlighter-rouge">sock.end</code> was called more than once</li>
          <li>if an image is broken:
            <ul>
              <li>it&#39;s likely an issue with content type or reading the image as binary data - make sure that the head is written first, then the data of the body sent afterwards</li>
              <li>or perhaps not having two \r\n&#39;s between the headers and the body</li>
              <li>or it could be inadvertently converting the body into a string by writing the headers and the body all at once</li>
              <li>or inadvertently adding extra data into the body</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <h4 id="background">Background</h4>

    <p>In the previous part, we purposely skipped implementing <code class="highlighter-rouge">sendFile</code>. Send file will take a <code class="highlighter-rouge">fileName</code> and send back an http response with the appropriate status code (<code class="highlighter-rouge">200</code>), <code class="highlighter-rouge">Content-Type</code> header (based on file type being sent back) and body.</p>

    <p>It&#39;s a little bit tricky because of:</p>

    <ol>
      <li>dealing with callbacks</li>
      <li>dealing with <code class="highlighter-rouge">this</code></li>
    </ol>

    <p>For this part, we&#39;ll use the <code class="highlighter-rouge">fs</code> module and <code class="highlighter-rouge">readFile</code>. See <a href="https://nodejs.org/api/fs.html#fs_fs_readfile_file_options_callback">the official docs for more detailed info</a>. Consequently, we&#39;ll have to go over:</p>

    <ol>
      <li>Using <code class="highlighter-rouge">fs.readFile</code></li>
      <li>Using a method as a callback for <code class="highlighter-rouge">fs.readFile</code></li>
      <li>Passing parameters to a callback</li>
      <li>The exact implementation of <code class="highlighter-rouge">sendFile</code>, and the callback function we end up passing to it</li>
    </ol>

    <p><br /></p>

    <h4 id="using-fsreadfile">Using <code class="highlighter-rouge">fs.readFile</code></h4>

    <p>We&#39;re using <code class="highlighter-rouge">fs.readFile</code> so that we can read binary data. It&#39;ll read the entire contents of a file into memory. It works like this:</p>

    <pre><code data-trim="" contenteditable="">const fs = require('fs');
fs.readFile('/tmp/foo.txt', {encoding:'utf8'}, function(err, data) {
    console.log(data);
}); 
</code></pre>

    <ul>
      <li>Note that <code class="highlighter-rouge">readFile</code>&#39;s second argument is a callback function.
        <ul>
          <li>The callback function is executed when an error occurs or the file.</li>
          <li>The callback receives an error object (which contains the error if an error occurred) and the data read from the file.</li>
          <li>If encoding was specified in the original call to <code class="highlighter-rouge">readFile</code>, then the data that&#39;s passed to the callback is a string</li>
          <li>If there is no encoding, then the raw buffer is passed as the data to the callback</li>
          <li>This is useful for reading binary data, like images:
            <pre><code data-trim="" contenteditable="">// leave encoding out of 2nd argument
fs.readFile('/tmp/myImage.gif', {}, function(err, data) {
  // we have the raw buffer!
  console.log(data);
}); 
</code></pre>
          </li>
        </ul>
      </li>
      <li>Of course, the callback doesn&#39;t have to be an anonymous function, it can be a named function as well:
        <pre><code data-trim="" contenteditable="">// in this case, we're passing in handleRead as the callback rather
// than using an anonymous function
fs.readFile('/tmp/myImage.gif', {}, handlRead); 
function handleRead(err, data) {
  console.log(data);
}
</code></pre>
      </li>
    </ul>

    <p><br /></p>

    <h4 id="using-a-method-as-a-callback">Using a method as a callback</h4>

    <p>It turns out that the callback to <code class="highlighter-rouge">readFile</code> (or any function that requires a callback) can be a method plucked from an object. However, if the callback needs to acces the <code class="highlighter-rouge">this</code> property of the original object, <code class="highlighter-rouge">this</code> has to bound explicitly. Let&#39;s see the problem:</p>

    <ul>
      <li>Imagine you have the following object that represents a redacted file&#8230;</li>
      <li>It takes a <code class="highlighter-rouge">fileName</code> and a <code class="highlighter-rouge">word</code> as arguments to the constructor</li>
      <li>Calling <code class="highlighter-rouge">printFile</code> will print out the contents of the file with all occurrences of <code class="highlighter-rouge">word</code> redacted (in this case, it&#39;s replaced with the string, <code class="highlighter-rouge">SECRET</code>)</li>
      <li>Here&#39;s a possible implementation:
        <pre><code data-trim="" contenteditable="">const fs = require('fs'); <br />    
function RedactedFile(fileName, word) {
  this.fileName = fileName;
  this.word = word;
}<br />
RedactedFile.prototype.printFile = function() {
 fs.readFile(this.fileName, this.handleRead); 
};<br />
RedactedFile.prototype.handleRead = function(err, data) {
  // convert to string
  let s = data + '';<br />
  // let's try to replace every occurrence of this.word!<br />
  const replacementPattern = new RegExp(this.word, "g")
  s = s.replace(replacementPattern, 'SECRET');<br />
  // print out the result
  console.log(s);
};
</code></pre>
      </li>
      <li>Now let&#39;s try running this on a file <code class="highlighter-rouge">/tmp/sensitiveData.txt</code>, which contains the following lines:
        <pre><code data-trim="" contenteditable="">I went to the pizza place next door...
and I ordered 1,000 slices of pineapple pizza.
</code></pre>
      </li>
      <li>Here&#39;s the code that we write to print out a redacted version of <code class="highlighter-rouge">/tmp/sensitiveData.txt</code>:
        <pre><code data-trim="" contenteditable="">const redacted = new RedactedFile('/tmp/sensitiveData.txt', 'pizza');
redacted.printFile();
</code></pre>
      </li>
      <li>However, when we run it, we don&#39;t get the result we expected!</li>
      <li>It just prints out the word SECRET <strong>between every character</strong>!?</li>
      <li>How did this happen?
        <ul>
          <li><code class="highlighter-rouge">this.handleRead</code> was passed in to <code class="highlighter-rouge">fs.readFile</code> as a callback&#8230;</li>
          <li>but when the callback actually gets executed, <code class="highlighter-rouge">this</code> within the callback function isn&#39;t actually bound to the original object (because when the callback is invoked, it&#39;s not invoked as a method, but as a regular function call!)</li>
          <li>consequently <code class="highlighter-rouge">this.word</code> is not what we expect (it&#39;s <code class="highlighter-rouge">undefined</code> rather than <code class="highlighter-rouge">pizza</code>)</li>
        </ul>
      </li>
      <li>Consequently, we have to explicitly set the <code class="highlighter-rouge">this</code> value of the callback</li>
      <li>There are a few ways to do this&#8230; we&#39;ll use the way that we learned in class, which is to use arrow functions or <code class="highlighter-rouge">bind</code></li>
      <li>To use an arrow function, wrap the call to method in an arrow function so that <code class="highlighter-rouge">this</code> remains the same as the <code class="highlighter-rouge">this</code> in <code class="highlighter-rouge">printFile</code></li>
      <li>Replace <code class="highlighter-rouge">this.handleRead</code> with  (err, data) =&gt; { this.handleRead(err, data); } <code class="highlighter-rouge">this.handleRead.bind(this)</code>
        <pre><code data-trim="" contenteditable="">// fs.readFile(this.fileName, this.handleRead);
fs.readFile(this.fileName, (err, data) =&gt; { this.handleRead(err, data); });
// or with bind:
//  fs.readFile(this.fileName, this.handleRead.bind(this));`
</code></pre>
      </li>
      <li>What does that do?
        <ul>
          <li>with arrow functions - it preserves <code class="highlighter-rouge">this</code>!</li>
          <li>with bind:
            <ul>
              <li>Remember that bind gives back function.</li>
              <li>With a specified <code class="highlighter-rouge">this</code> (as given by the caller).</li>
              <li>So, it explicitly sets the <code class="highlighter-rouge">this</code> of the <code class="highlighter-rouge">handleRead</code> function to the current <code class="highlighter-rouge">this</code>, which refers to the <code class="highlighter-rouge">RedactedFile</code> object</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="http://stackoverflow.com/questions/20279484/how-to-access-the-correct-this-context-inside-a-callback/20279485#20279485">Here&#39;s an SO article to read more about it!</a> This shows a few ways to use a method as a callback by  <em>somehow</em> correctly setting <code class="highlighter-rouge">this</code>.</li>
    </ul>

    <p><br /></p>

    <h4 id="passing-arguments-to-a-callback">Passing arguments to a callback</h4>

    <p>Imagine if our <code class="highlighter-rouge">handleRead</code> function took an extra argument, a disclaimer.</p>

    <pre><code data-trim="" contenteditable="">RedactedFile.prototype.handleRead = function(disclaimer, err, data) {
    let s = data + '';
    const replacementPattern = new RegExp(this.word, "g")
    s = s.replace(replacementPattern, 'SECRET');
    console.log(disclaimer);
    console.log(s);
};
</code></pre>

    <p>Now&#8230; we have an issue, because the callback that should be supplied to <code class="highlighter-rouge">readFile</code> should only have <code class="highlighter-rouge">err</code> and <code class="highlighter-rouge">data</code> as its two arguments (but now our callback has 3!). How can we transform our callback so that it only takes 2 arguments like it did before? Once again, we&#39;ll rely on arrow functions or <code class="highlighter-rouge">bind</code>!</p>

    <ol>
      <li>
        <p>our arrow function can have only 2 arguments, but pass in disclaimer as the 1st argument when calling the original method
     &lt;pre&gt;<code data-trim="" contenteditable="">RedactedFile.prototype.printFile = function() {
 const disclaimer = 'This file has been redacted';</code></p>

        <p>// bind disclaimer as the first parameter
 fs.readFile(this.fileName, (err, data) =&gt; { this.handleRead(disclaimer, err, data); }); 
};
&lt;/code&gt;&lt;/pre&gt;</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">bind</code> allows us to &quot;fix&quot; a parameter or parameters of a function to specific values</p>
        <ul>
          <li>(so we can create a new function with less parameters)</li>
          <li>for example: <code class="highlighter-rouge">const parseInt100 = parseInt.bind(null, "100")</code> &#8230;</li>
          <li>binds &quot;100&quot; to the first argument of <code class="highlighter-rouge">parseInt</code>, and returns a function that takes only one argument, the <code class="highlighter-rouge">radix</code></li>
          <li><code class="highlighter-rouge">parseInt100(2)</code> &#8230; gives us 4 (because the only argument is the radix)</li>
          <li>Consequently, the fix for a callback that requires a parameter is to use bind to fix the initial parameters:
            <pre><code data-trim="" contenteditable="">RedactedFile.prototype.printFile = function() {
 const disclaimer = 'This file has been redacted';

</code></pre>
          </li>
        </ul>
        <p>// bind disclaimer as the first parameter
 fs.readFile(this.fileName, this.handleRead.bind(this, disclaimer)); 
};
&lt;/code&gt;&lt;/pre&gt;</p>
      </li>
    </ol>

    <p><br /></p>

    <h4 id="implementing-sendfile">Implementing <code class="highlighter-rouge">sendFile</code></h4>

    <p>Now that we know how to use <code class="highlighter-rouge">readFile</code> and its callback within the context of an object, we&#39;ll turn our attention back to  <code class="highlighter-rouge">sendFile</code>. <code class="highlighter-rouge">sendFile</code> will read the contents of the <code class="highlighter-rouge">fileName</code> supplied to it, and it&#39;ll read the file relative to the <code class="highlighter-rouge">public</code> folder in the repository. Here&#39;s how you&#39;ll implement <code class="highlighter-rouge">sendFile</code>:</p>

    <ol>
      <li>Determine the absolute path to the file that&#39;s passed in as its argument by using <code class="highlighter-rouge">_\_dirname</code> to find the directory of the module&#8230; and go up one so that public can be accessed.
        <pre><code data-trim="" contenteditable="">const publicRoot = __dirname + '/../public';
const filePath =  publicRoot + fileName;
</code></pre>
      </li>
      <li>Use the extension of the file to determine:
        <ul>
          <li>if it&#39;s an image</li>
          <li>&#8230; and to figure out what the correct <code class="highlighter-rouge">Content-Type</code> should be
            <ol>
              <li><code class="highlighter-rouge">jpeg</code> or <code class="highlighter-rouge">jpg</code>: <code class="highlighter-rouge">image/jpeg</code></li>
              <li><code class="highlighter-rouge">png</code>: <code class="highlighter-rouge">image/png</code></li>
              <li><code class="highlighter-rouge">gif</code>: <code class="highlighter-rouge">image/gif</code></li>
              <li><code class="highlighter-rouge">html</code>: <code class="highlighter-rouge">text/html</code></li>
              <li><code class="highlighter-rouge">css</code>: <code class="highlighter-rouge">text/css</code></li>
              <li><code class="highlighter-rouge">txt</code>: <code class="highlighter-rouge">text/plain</code></li>
            </ol>
          </li>
        </ul>
      </li>
      <li>Call <code class="highlighter-rouge">readFile</code> with:
        <ul>
          <li>a callback function that&#39;s a method on the <code class="highlighter-rouge">Response</code> object, a standalone function or an anonymous function.</li>
          <li>a value for encoding if the file being read is text-based (<code class="highlighter-rouge">{"encoding": "utf8"}</code>)</li>
        </ul>
      </li>
      <li>In any case, the callback should take a <code class="highlighter-rouge">contentType</code>, <code class="highlighter-rouge">err</code> and <code class="highlighter-rouge">data</code> as its arguments&#8230; but make sure that <code class="highlighter-rouge">contentType</code> is set appropriately and that <code class="highlighter-rouge">this</code> can be used to access <code class="highlighter-rouge">Response</code> object methods (use arrow functions or bind!)</li>
      <li>Call the appropriate <code class="highlighter-rouge">Response</code> object methods from within your callback to send back a response; note that the methods must be called <strong>in this order</strong> &#8594;
        <ol>
          <li>set the <code class="highlighter-rouge">Content-Type</code> header</li>
          <li>send everything but the body by calling <code class="highlighter-rouge">this.writeHead(200)</code></li>
          <li>write the data that was passed in as an argument to the callback to the socket (that is, write the data from the file)</li>
          <li>close the connection</li>
          <li>why write the headers and the body separately? This avoids any issues where the binary data of the image is inadvertently converted to a string.</li>
        </ol>
      </li>
    </ol>

    <p><br /></p>

    <h4 id="testing-sendfile">Testing <code class="highlighter-rouge">sendFile</code></h4>

    <p>Now try adding a path to display:</p>

    <ol>
      <li>an html file that&#39;s located in your <code class="highlighter-rouge">$PROJECT_ROOT/public/html/</code> folder called <code class="highlighter-rouge">test.html</code></li>
      <li>an image that&#39;s in located in your <code class="highlighter-rouge">$PROJECT_ROOT/public/img/</code> folder called <code class="highlighter-rouge">bmo1.gif</code></li>
    </ol>

    <p>To do this:</p>

    <ol>
      <li>Add another condition for the paths <code class="highlighter-rouge">/test</code> and <code class="highlighter-rouge">/img/bmo1.gif</code></li>
      <li>Use <code class="highlighter-rouge">sendFile</code> to send the appropriate file relative to <code class="highlighter-rouge">public</code></li>
      <li>Remember that the path of the request doesn&#39;t have to match the path of the actual file being read</li>
      <li>Here&#39;s what it&#39;ll all look like together: <br /> <img src="/csci-ua.0480-fall2017-007/resources/img/hw03-03-evenWarmer-response.gif" alt="pic alt" /></li>
      <li><code class="highlighter-rouge">bmo1.gif</code> should be present</li>
      <li>you&#39;ll have to write your own <code class="highlighter-rouge">test.html</code></li>
    </ol>

    <h2 id="part-3---converting-to-app-object">Part 3 - Converting to App Object</h2>

    <p>Now you&#39;ll start writing your module, <code class="highlighter-rouge">miniWeb.js</code>.</p>

    <ol>
      <li>Copy your <code class="highlighter-rouge">Request</code> and <code class="highlighter-rouge">Response</code> classes from <code class="highlighter-rouge">evenWarmer.js</code> to <code class="highlighter-rouge">miniWeb.js</code></li>
      <li>In <code class="highlighter-rouge">minWeb.js</code>, add one more class, <code class="highlighter-rouge">App</code>. Use the <a href="#app">specifications for the <code class="highlighter-rouge">App</code> object below</a></li>
      <li>Go through your code and check for places that may cause 500 errors (for example, if the <code class="highlighter-rouge">err</code> object exists when handling a file read, send back a 500 as a response&#8230; or if the framework user tries to send a file that has an extension that is not recognized, that should also be a 500)</li>
      <li>Export <code class="highlighter-rouge">App</code> along with <code class="highlighter-rouge">Require</code> and <code class="highlighter-rouge">Response</code></li>
    </ol>

    <p><a name="app"></a></p>

    <h3 id="app-object"><code class="highlighter-rouge">App</code> Object</h3>

    <p>The app object represents a web application. It&#39;s responsible for:</p>

    <ol>
      <li>accepting incoming http requests</li>
      <li>holding &quot;routes&quot; or url/path combinations (right now our framework will only support GETs)</li>
      <li>determining what to do based on the incoming request</li>
      <li>sending back a response</li>
    </ol>

    <p>Number 2 and 3 are determined by the user that is writing a web application with this framework. That is, they specify what routes are present &#8230; and what to do when that route is matched by writing code. For example, a hello world application could be written as follows (this is what someone using your web framework would write):</p>

    <pre><code data-trim="" contenteditable="">const App = require('./miniWeb.js').App;
const app = new App();

app.get('/hello', function(req, res) {
    res.send(200, 'HELLO WORLD');
});

app.listen(8080, '127.0.0.1');
</code></pre>

    <hr />

    <h4 id="constructor-2">Constructor</h4>

    <p><code class="highlighter-rouge">App()</code> - creates a new App object and sets the connection callback function to <code class="highlighter-rouge">this.handleConnection</code> which you&#39;ll implement below &#8230; additionally, initializes its routes to empty object (see Properties section). Example usage of constructor:</p>

    <pre><code data-trim="" contenteditable="">const App = require('./miniWeb.js').App;
const app = new App();
</code></pre>

    <p>Note that when you import the module, you can set a variable directly to an exported object by using dot notation. In the example above, pull out the <code class="highlighter-rouge">App</code> constructor.</p>

    <p>The <code class="highlighter-rouge">App</code> object itself represents both a web server and the web application running on that server. Consequently, it&#39;ll hold an instance of a <code class="highlighter-rouge">Server</code> object from node&#39;s <code class="highlighter-rouge">net</code> module. See <a href="../slides/06/sockets.html#/2">the slides</a> or the <a href="https://nodejs.org/api/net.html#net_class_net_server">node documentation</a>.</p>

    <p>When you create a server using <code class="highlighter-rouge">net.createServer</code>, it expects a callback function to be specified when a client connects to the server. That callback will be a method that you define, <code class="highlighter-rouge">handleConnection</code>. However, to have a method be passed as a callback <strong>and</strong> retain its original access to the object that it belongs to, you&#39;ll have to use bind (otherwise, <code class="highlighter-rouge">this</code> will refer to the global object). In the constructor, it&#39;ll look something like this:</p>

    <pre><code data-trim="" contenteditable="">// within your constructor
this.server = net.createServer(this.handleConnection.bind(this));

// the above ensures that handleConnection will have a this that refers to the
// object created by the constructor without having to call handleConnection
// as a method on the object
</code></pre>

    <hr />

    <h4 id="properties-2">Properties</h4>

    <ol>
      <li><code class="highlighter-rouge">server</code> - an instance of the <code class="highlighter-rouge">net</code> module&#39;s <code class="highlighter-rouge">Server</code> object</li>
      <li><code class="highlighter-rouge">routes</code> - an object that maps paths to callback functions</li>
    </ol>

    <hr />

    <h4 id="methods-2">Methods</h4>

    <ol>
      <li><code class="highlighter-rouge">get(path, cb)</code> - adds <code class="highlighter-rouge">path</code> as a property name in <code class="highlighter-rouge">routes</code>&#8230; the value of which is the callback function, <code class="highlighter-rouge">cb</code> (again, assumes support only for GET requests)
        <ul>
          <li><code class="highlighter-rouge">path</code> - the path to respond to (that is, a valid path for the web application)</li>
          <li><code class="highlighter-rouge">callback</code> - the function called when <code class="highlighter-rouge">path</code> is requested (essentially&#8230; what to do when a specific path is asked for)
            <ul>
              <li>the callback function will take two arguments</li>
              <li>a <code class="highlighter-rouge">Request</code> object</li>
              <li>a <code class="highlighter-rouge">Response</code> object</li>
              <li><code class="highlighter-rouge">cb(req, res) ...</code></li>
            </ul>
          </li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">app.get('/hello', function(req, res) {
 res.send(200, 'HELLO WORLD');
});
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">listen(port, host)</code> - binds the server to the given <code class="highlighter-rouge">port</code> and <code class="highlighter-rouge">host</code> (&quot;listens&quot; on <code class="highlighter-rouge">host</code>:<code class="highlighter-rouge">port</code>)
        <ul>
          <li><code class="highlighter-rouge">port</code> - the port number to bind to</li>
          <li><code class="highlighter-rouge">host</code> - the host that the server will be running on (for example, &#39;127.0.0.1&#39;)</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">app.listen(8080, '127.0.0.1');
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">handleConnection(sock)</code> - the function called when a client connects to the server&#8230; this will simply set the callback for the socket&#39;s <code class="highlighter-rouge">on</code> method: <code class="highlighter-rouge">sock.on('data', ...)</code> to the function below, <code class="highlighter-rouge">handleRequestData</code>
        <ul>
          <li><code class="highlighter-rouge">sock</code> - the socket representing the connection to the client (this will be supplied by the caller because this will be used as a callback function for <code class="highlighter-rouge">net.createServer</code>)</li>
          <li>no return value</li>
          <li>example usage (as a callback function for <code class="highlighter-rouge">net.createServer</code>):</li>
        </ul>
        <pre><code data-trim="" contenteditable="">this.server = net.createServer(this.handleConnection.bind(this));</code></pre>
      </li>
      <li><code class="highlighter-rouge">handleRequestData(sock, binaryData)</code> - the function called when the socket receives data from the client (our framework will not have a timeout, it&#39;ll just assume that once it receives data, that the data received is the entire request)&#8230;  this is where most of the logic of our framework will go; it processes a request and sends back a response!
        <ul>
          <li><code class="highlighter-rouge">sock</code> - the socket representing the connection to the client</li>
          <li><code class="highlighter-rouge">binaryData</code> - the data sent by the client</li>
          <li>no return value</li>
          <li>this callback is essentially responsible for processing a request and sending back a response&#8230; it will:
            <ol>
              <li>convert the incoming data to a string</li>
              <li>create a new <code class="highlighter-rouge">Request</code> object based on that string</li>
              <li>create a new <code class="highlighter-rouge">Response</code></li>
              <li>sets a callback for when the connection is closed (the callback will be to log the response using <code class="highlighter-rouge">logResponse</code> below)</li>
              <li>determine if the request is valid by checking for a <code class="highlighter-rouge">Host</code> header (it&#39;ll return a <code class="highlighter-rouge">400</code> if the request isn&#39;t valid)</li>
              <li>look up the function to call in <code class="highlighter-rouge">this.routes</code> by using the <code class="highlighter-rouge">path</code> property from the incoming <code class="highlighter-rouge">Request</code> object &#8230; <strong>make sure that urls with and without a trailing slash (/) map to the same function</strong></li>
              <li>call that function, passing in the <code class="highlighter-rouge">Request</code> and <code class="highlighter-rouge">Response</code> objects created above as arguments</li>
              <li>if the <code class="highlighter-rouge">path</code> doesn&#39;t exist in <code class="highlighter-rouge">this.routes</code>, then send back a <code class="highlighter-rouge">404</code></li>
            </ol>
          </li>
          <li>hints:
            <ul>
              <li>note that the callback for <code class="highlighter-rouge">sock.on(data, ...)</code> typically only takes a single argument</li>
              <li>however, we want access to a socket object so that we can create our <code class="highlighter-rouge">Response</code> object using that socket</li>
              <li>so&#8230; to fix the arguments, when we set <code class="highlighter-rouge">handleRequestData</code> as a callback in <code class="highlighter-rouge">handleConnection</code>, we&#39;ll have to use bind again (or arrow functions):</li>
            </ul>
          </li>
          <li>example usage:
      &lt;pre&gt;<code data-trim="" contenteditable="">// within handleConnection...
sock.on('data', this.handleRequestData.bind(this, sock));
// once again, sets this... and also sets sock so that the returned function
// only takes a single argument, binaryData</code></li>
          <li>example usage (as a callback function for <code class="highlighter-rouge">sock.on('data', ...)</code>):</li>
        </ul>
        <pre><code data-trim="" contenteditable=""> sock.on('data', this.handleRequestData.bind(this, sock)); </code></pre>
      </li>
      <li><code class="highlighter-rouge">logResponse(req, res)</code> - logs out the http request method and path&#8230; as well as the response status code and short message
        <ul>
          <li>example usage:</li>
          <li><code class="highlighter-rouge">req</code> - the incoming http request</li>
          <li><code class="highlighter-rouge">res</code> - the resulting http response</li>
          <li>no return value</li>
          <li>example usage (as a callback function for <code class="highlighter-rouge">sock.on('close', ...)</code>:
            <pre><code data-trim="" contenteditable="">// when a request / response cycle is finished, then log out some info
// note that we'll need to bind req and res assuming that they're available (which they should be...
// ...since this goes in handleRequestData, which creates both objects)
// (arrow functions will also work)
sock.on('close', this.logResponse.bind(this, req, res));
</code></pre>
          </li>
        </ul>
      </li>
    </ol>

    <h2 id="part-4---using-your-module">Part 4 - Using your Module!</h2>

    <p>Create a small site using your framework. In a file called <code class="highlighter-rouge">fansite.js</code> create a fan site for a fictional character from a book, movie or television series. It must respond to the following URLs (note that the URLs should still work if an extra trailing slash is added&#8230; <code class="highlighter-rouge">/about</code> and <code class="highlighter-rouge">/about/</code> should go to the same place):</p>

    <ul>
      <li><code class="highlighter-rouge">/</code> - a homepage that has an image and that uses a stylesheet</li>
      <li><code class="highlighter-rouge">/about</code> - a page that has an <code class="highlighter-rouge">h1</code> header somewhere in the markup</li>
      <li><code class="highlighter-rouge">/css/base.css</code> - the css that the homepage (and other pages optionally) should use</li>
      <li><code class="highlighter-rouge">/rando</code> - a page that displays a random image; this must be an html page with no client side JavaScript&#8230; the server will generate a random image url to be displayed</li>
      <li><code class="highlighter-rouge">/image1.jpg</code></li>
      <li><code class="highlighter-rouge">/image2.png</code></li>
      <li><code class="highlighter-rouge">/image3.gif</code></li>
      <li><code class="highlighter-rouge">/home</code> - should issue a permanent redirect (301) to <code class="highlighter-rouge">/</code></li>
    </ul>

    <p>To create your site:</p>

    <ol>
      <li>Bring in your module and create a new <code class="highlighter-rouge">App</code> object:
        <pre><code data-trim="" contenteditable="">const App = require('./miniWeb.js').App;
const app = new App();
</code></pre>
      </li>
      <li>Add routes as necessary&#8230;
        <pre><code data-trim="" contenteditable="">app.get('/', function(req, res) {
 // ... do stuff here
});
</code></pre>
      </li>
      <li>Use any mechanism you&#39;d like to send back a response (you can use <code class="highlighter-rouge">sendFile</code> and read files from <code class="highlighter-rouge">public</code>, you can just use <code class="highlighter-rouge">send</code> to send back strings of html, etc.) &#8230; obviously, for some, like images, you&#39;ll have to use specific methods</li>
      <li>Bind to a port and host with <code class="highlighter-rouge">listen</code>:
        <pre><code data-trim="" contenteditable="">app.listen(8080, '127.0.0.1');
</code></pre>
      </li>
    </ol>

    <p>Check your work</p>

    <ol>
      <li>use curl to check status codes and headers&#8230;</li>
      <li>check the pages in your browser, make sure everything renders fine with/without leading and trailing slashes</li>
      <li>make sure your redirect actually causes your browser to redirect the right way (that is, it should coerce the browser into making another request)</li>
      <li>remember to check 404&#39;s</li>
      <li>make sure that your application is logging request/response info to the console</li>
    </ol>

    <p>Here&#39;s an example of how it might all work:</p>

    <p><img src="/csci-ua.0480-fall2017-007/resources/img/hw03-04-fansite.gif" alt="pic alt" /></p>

  </div>

</div>
:ET