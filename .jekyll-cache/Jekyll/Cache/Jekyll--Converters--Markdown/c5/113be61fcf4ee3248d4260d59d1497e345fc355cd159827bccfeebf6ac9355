I"tæ<style>
.warning {
    background-color: #eecccc;
}
</style>

<div class="panel panel-default">
	<div class="panel-heading">Homework #6</div>
	<div class="panel-body">

    <h1 id="authentication-and-mongoose-models---due-tuesday-nov-13th-by-11pm">Authentication and Mongoose Models - <strong>Due Tuesday, Nov 13th, by 11PM</strong></h1>

    <h2 id="overview">Overview</h2>

    <h3 id="description">Description</h3>

    <h4 id="login-registration-and-multiple-models">Login, Registration, and Multiple Models</h4>

    <p>Create a link aggregator site (<em>like</em> reddit, hacker news, etc.) that supports user registration and login&#8230; along with the ability to post articles (links).</p>

    <p>Registering or logging in will create an authenticated session that contains all of the logged in user&#39;s information. Some elements on pages will only appear when a user is logged in. Some pages will redirect to login if a user arrives unauthenticated.</p>

    <h3 id="goals">Goals</h3>

    <ul>
      <li>use <code class="highlighter-rouge">bcrypt.js</code> to salt and hash a password and to compare a hash to a plain text password</li>
      <li>use <a href="../slides/16/auth.html">the slides on authentication</a> to implement login and registration</li>
      <li>use express-session to store user data  / an authenticated session</li>
      <li>use embedded or related documents to model users and posted articles</li>
      <li>extract path components to determine what data to use to render a page</li>
    </ul>

    <h3 id="warning-">‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è WARNING ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è</h3>

    <p><span class="warning">This homework is for learning purposes only; <strong>do not use it</strong> for authentication on a deployed site</span></p>

    <ul>
      <li>our application will only be served locally, and consequently, it will not be served over an encrypted connection &#8230; and - related - cookies aren&#39;t set to secure</li>
      <li>it will allow case sensitive usernames</li>
      <li>it encourages the use of multiple nested callbacks instead of promises and / or async await</li>
      <li>not all errors accounted for or handled gracefully</li>
      <li>system level errors and user errors may not be distinguishable</li>
      <li>some error messaging may reveal <strong>too much</strong> information</li>
      <li>user interaction and error messaging will be minimal (for example, successful login should redirect to page that required login)</li>
      <li>some error messages reveal will info about the existence of a user</li>
      <li>our session secret will be in version control</li>
    </ul>

    <h3 id="features">Features</h3>

    <ol>
      <li>register a new account</li>
      <li>login using an existing account</li>
      <li>add a new article</li>
      <li>view all posted articles</li>
      <li>show a single article&#39;s details</li>
      <li>prevent / allow access to certain ui elements or pages based on authenticated status</li>
    </ol>

    <h4 id="youll-have-5-pages-and-3-forms">You&#39;ll have 5 pages and 3 forms:</h4>

    <ul>
      <li><strong>/</strong> - lists all articles</li>
      <li><strong>/register</strong> - register form</li>
      <li><strong>/login</strong>  - login form</li>
      <li><strong>/article/add</strong> - add new article form</li>
      <li><strong>/article/:slug</strong> - detail page for a specific article</li>
    </ul>

    <h4 id="example-interaction">Example Interaction</h4>

    <p>Here&#39;s what it looks like to login, add a new article, and view the link and details page:.</p>

    <p><img src="../resources/img/hw06-aintreddit-00-all.gif" /></p>

    <h3 id="submission-process">Submission Process</h3>

    <p>You will be given access to a private repository on GitHub. The repository will have a partially built Express application. The final version of your assignment should be in GitHub:</p>

    <ul>
      <li><strong>Push</strong> your changes to the homework repository on GitHub.</li>
    </ul>

    <h3 id="make-at-least-4-commits">Make at Least 4 Commits</h3>

    <ul>
      <li>Commit multiple times throughout your development process.</li>
      <li>Make at least 4 separate commits - (for example, one option may be to make one commit per part in the homework).</li>
    </ul>

    <h2 id="part-1---setup-and-authentication-functions">Part 1 - Setup and Authentication Functions</h2>

    <h3 id="starting-project">Starting Project</h3>

    <p>Your repository should have the following files and directories.</p>

    <pre><code data-trim="" contenteditable="">
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app.js
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ auth.js
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ db.js
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ public
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ css
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ views
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ article-add.hbs
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ login.hbs
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ register.hbs
‚îî‚îÄ‚îÄ test
    ‚îú‚îÄ‚îÄ mock-user.js
    ‚îî‚îÄ‚îÄ test-auth.js
</code></pre>

    <p>Add the following:</p>

    <ul>
      <li><code class="highlighter-rouge">.gitignore</code> - ignore <code class="highlighter-rouge">node_modules</code> and any other files that you would like to keep out of your repository (varies depending on your OS and editor&#8230; for example, if you&#39;re on vim on MacOS, you may want to ignore <code class="highlighter-rouge">.swp</code> files and <code class="highlighter-rouge">.DS_Store</code> etc.)</li>
      <li><code class="highlighter-rouge">.eslintrc.js</code>/<code class="highlighter-rouge">.eslintrc.json</code> - you can use a previous configuration for this</li>
    </ul>

    <h3 id="dependencies">Dependencies</h3>

    <p>The following modules are already listed in <code class="highlighter-rouge">package.json</code> and configured in <code class="highlighter-rouge">app.js</code> &#8230; so simply run <code class="highlighter-rouge">npm install</code> in the project root</p>

    <ul>
      <li><code class="highlighter-rouge">express</code></li>
      <li><code class="highlighter-rouge">hbs</code></li>
      <li><code class="highlighter-rouge">express-session</code> - for session management</li>
      <li><code class="highlighter-rouge">mongoose</code> - for database access</li>
      <li><code class="highlighter-rouge">bcryptjs</code> - module for salting, hashing and comparing passwords</li>
      <li><code class="highlighter-rouge">mongoose-url-slugs</code> - plugin for autogenerating slugs</li>
    </ul>

    <p>Your app is configured to listen on port 3000. <span class="warning">Do not change this.</span></p>

    <h3 id="about-bcryptjs">About bcrypt.js</h3>

    <p>bcrypt.js is a JavaScript implementation of password hashing function called (you guessed it!) bcrypt. We&#39;ll use it for login and registration. The result of using bcrypt contains both the hash and the salt! Check out the details in the first section of the <a href="https://en.wikipedia.org/wiki/Bcrypt">wikipedia article</a> and the diagram below illustrating the output of bcrypt:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy
|_____||____________________||_____________________________|
   |             |                          |
   |             |                          +-- hash
   |             |
   |             +-- salt
   |
   +-- algorithm and cost factor

</code></pre></div>    </div>

    <p>Check out <a href="https://www.npmjs.com/package/bcryptjs">how to use bcrypt.js</a>.</p>

    <h3 id="database-setup">Database Setup</h3>

    <ul>
      <li>in <code class="highlighter-rouge">src/db.js</code>&#8230;.</li>
      <li>using mongoose, <strong>create two schemas</strong>:
        <ul>
          <li><code class="highlighter-rouge">UserSchema</code>
            <ul>
              <li>it should have the following fields (all <code class="highlighter-rouge">String</code>, and all required):
                <ul>
                  <li><code class="highlighter-rouge">username</code> - user name used for login and public display</li>
                  <li><code class="highlighter-rouge">email</code> - user&#39;s email</li>
                  <li><code class="highlighter-rouge">password</code> - the combined salt and hash
  	* username should be a unique field, so set as <code class="highlighter-rouge">{type: String, unique: true, required: true}</code>
  	* typically hash and salt should be stored in separate fields, but because we&#39;re using <code class="highlighter-rouge">bcrypt</code> a single field is adequate for both</li>
                </ul>
              </li>
            </ul>
          </li>
          <li><code class="highlighter-rouge">ArticleSchema</code>
            <ul>
              <li>it should have the following fields (all <code class="highlighter-rouge">String</code>, validation is your discretion)
                <ul>
                  <li><code class="highlighter-rouge">title</code></li>
                  <li><code class="highlighter-rouge">url</code></li>
                  <li><code class="highlighter-rouge">description</code></li>
                </ul>
              </li>
              <li><span class="warning">if you use embedded documents, you can skip using mongoose-url-slugs, and create slugs on your own</span>
                <ul>
                  <li>sadly, it looks like <a href="https://github.com/talha-asad/mongoose-url-slugs/issues/13">sub docs aren&#39;t supported with mongoose-url-slugs</a> (embedded documents won&#39;t work)</li>
                  <li>&#8230;mainly because the plugin only works  correctly when save is explicitly called (which doesn&#39;t happen when dealing with embedded documents)</li>
                  <li>soooo‚Ä¶. instead, manually create a slug field (in your schema), and set it to the lowercase version of the title, replacing spaces with dashes (whenever a new article is created)</li>
                </ul>
              </li>
              <li>use <code class="highlighter-rouge">mongoose-url-slugs</code> to add a slug to uniquely identify each article:
                <ul>
                  <li>this plugin will autogenerate a <code class="highlighter-rouge">slug</code> field (no need to explicitly add it to your schema)</li>
                  <li>a slug is a string that serves as a short, human readable name</li>
                  <li>usually contains dashes to separate words, and a number suffix</li>
                  <li>for example, <code>this-is-a-slug</code></li>
                  <li><code class="highlighter-rouge">require</code> the module: <code class="highlighter-rouge">const URLSlugs = require('mongoose-url-slugs');</code></li>
                  <li>use the plugin by adding this code: <code>&lt;your schema name&gt;plugin(URLSlugs('&lt;what properties your slug should consist of&gt;'));</code></li>
                  <li>this should go before the model is registered
&lt;/code&gt;&lt;/pre&gt;</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>finally, <strong>you must associate users and articles</strong> by using embedded or related documents:
            <ul>
              <li>if relating documents, add a <code class="highlighter-rouge">User</code>&#39;s id to <code class="highlighter-rouge">ArticleSchema</code></li>
              <li>if embedding, perhaps adding an <code class="highlighter-rouge">Array</code> of <code class="highlighter-rouge">Article</code> objects to <code class="highlighter-rouge">UserSchema</code> would work</li>
              <li>which one would be easier to use to list all of the articles posted by everyone on the home page, without user info?</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>don&#39;t forget to register your models:
        <ul>
          <li><code class="highlighter-rouge">mongoose.model('User', UserSchema);</code></li>
          <li><code class="highlighter-rouge">mongoose.model('Article', ArticleSchema);</code></li>
        </ul>
      </li>
      <li>your db.js is configured to connect to <code class="highlighter-rouge">hw06</code>:
        <ul>
          <li><code class="highlighter-rouge">mongoose.connect('mongodb://localhost/hw06');</code></li>
        </ul>
      </li>
    </ul>

    <h3 id="create-helper-functions">Create Helper Functions</h3>

    <p>Create the following functions in a module, <code class="highlighter-rouge">src/auth.js</code>:</p>

    <ol>
      <li><code class="highlighter-rouge">register</code></li>
      <li><code class="highlighter-rouge">login</code></li>
      <li><code class="highlighter-rouge">startAuthenticatedSession</code></li>
    </ol>

    <p>You&#39;ll use these functions in your express application to implement a login and registration page.</p>

    <p><span class="warning">Warning: the following functions will contain many levels ofnested callbacks!</span></p>

    <ul>
      <li>we haven&#39;t covered promises yet, but if you want to remove nesting, using promises is one solution (though you&#39;ll have to research this on your own): both <code class="highlighter-rouge">mongoose</code> and <code class="highlighter-rouge">bcrypt</code> provide promises (instead of callbacks) as part of their api</li>
      <li>another way of dealing with this is wrapping some functionality in a function, but if you do this, you&#39;ll need to write a function that takes a callback!
        <h3 id="register">register</h3>
      </li>
    </ul>

    <p><code class="highlighter-rouge">register(username, email, password, errorCallback, successCallback)</code></p>

    <h4 id="parameters">Parameters:</h4>

    <ul>
      <li><code class="highlighter-rouge">username</code>: username</li>
      <li><code class="highlighter-rouge">email</code>: email</li>
      <li><code class="highlighter-rouge">password</code>: plain text password</li>
      <li><code class="highlighter-rouge">errorCallback</code>: function to call if an error occurs
        <ul>
          <li><code class="highlighter-rouge">errorCallback(errObj)</code></li>
          <li><code class="highlighter-rouge">errObj</code> will have a key called message that contains an error message</li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">successCallback</code>: function to call if registration works
        <ul>
          <li><code class="highlighter-rouge">successCallback(userObject)</code></li>
          <li><code class="highlighter-rouge">userObject</code> is the object that represents the newly saved user</li>
        </ul>
      </li>
    </ul>

    <h4 id="return">Return:</h4>

    <ul>
      <li>no return value (instead, calls callback functions, <code class="highlighter-rouge">errorCallback</code> or <code class="highlighter-rouge">successCallback</code>)</li>
    </ul>

    <h4 id="description-1">Description:</h4>

    <ol>
      <li>when you encounter any errors as you run through the registration process:
        <ul>
          <li>log the error to the console (server)</li>
          <li>call the <code class="highlighter-rouge">errorCallback</code> passing in an error object containing a key called <code class="highlighter-rouge">message</code> and a value of a string describing the error that occurred (this gives the caller the ability to pass in a function that handles the error - for example, rendering a template with an error message)</li>
          <li>some errors will require specific strings to be in the <code class="highlighter-rouge">message</code> property of the error object, while others are your discretion (read the instructions and run the tests for details)</li>
        </ul>
      </li>
      <li>check the length of the username and password passed in; they should both be greater than or equal to 8</li>
      <li>if either the username or password does not meet this requirement, call the <code class="highlighter-rouge">errorCallback</code> function with an object containing a key called <code class="highlighter-rouge">message</code> and value of <code class="highlighter-rouge">USERNAME PASSWORD TOO SHORT</code></li>
      <li>check if the user already exists (case sensitive check is ok)
        <ul>
          <li>remember to pull out your <code class="highlighter-rouge">User</code> model by using <code class="highlighter-rouge">const User = mongoose.model('User');</code></li>
          <li>use <code class="highlighter-rouge">User.findOne((err, result, count) =&gt; {   })</code> to check if the user already exists
            <ul>
              <li>you can check the object with <code class="highlighter-rouge">if(result)</code> to determine if a <code class="highlighter-rouge">User</code> object was returned</li>
            </ul>
          </li>
          <li>or use <code class="highlighter-rouge">User.find((err, result, count) =&gt; {   })</code>&#8230; the
            <ul>
              <li>you can check if the length of the resulting <code class="highlighter-rouge">Array</code> is greater than 0</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>if the user already exists, call the <code class="highlighter-rouge">errorCallback</code> function with an object containing a key called <code class="highlighter-rouge">message</code> with the value, <code class="highlighter-rouge">USERNAME ALREADY EXISTS</code></li>
      <li>if the user doesn&#39;t exist yet, then it&#39;s ok to go ahead and create a new user&#8230;</li>
      <li>salt and hash the password using the <code class="highlighter-rouge">bcryptjs</code> module
        <ul>
          <li><a href="https://www.npmjs.com/package/bcryptjs#usage---async">check out the documentation on the bcrypt module</a></li>
          <li>do not use the sync calls (use the async version of bcrypt)</li>
          <li>auto generate a hash and a salt:
            <pre><code data-trim="" contenteditable="">// you can use a default value of 10 for salt rounds 
bcrypt.hash(myPlaintextPassword, saltRounds, function(err, hash) {
    // do more stuff here!
});
</code></pre>
          </li>
        </ul>
      </li>
      <li>notice the <code class="highlighter-rouge">hash</code> parameter in the callback above; it <em>actually</em> contains both the hash and the salt</li>
      <li>now we have everything we need to create a new user
        <ul>
          <li>instantiate  a new <code class="highlighter-rouge">User</code> object</li>
          <li>set the <code class="highlighter-rouge">username</code> and <code class="highlighter-rouge">email</code> to whatever was passed in as arguments, and the <code class="highlighter-rouge">password</code> should be set to the salt and hash generated</li>
          <li>call <code class="highlighter-rouge">save</code></li>
          <li>if the <code class="highlighter-rouge">save</code> succeeds, call the <code class="highlighter-rouge">successCallback</code> function with the newly saved user</li>
          <li>otherwise call the <code class="highlighter-rouge">errorCallback</code> with an object that contains the key, <code class="highlighter-rouge">message</code>, and a generic error message, <code class="highlighter-rouge">DOCUMENT SAVE ERROR</code>, as the value</li>
        </ul>
      </li>
      <li>check that your function works by:
        <ol>
          <li>running the unit tests, <code class="highlighter-rouge">mocha test/test-auth.js</code> (comment out all tests except for registration related ones), to check for:
            <ul>
              <li>a user object being passed to the success callback</li>
              <li>the user object having the same name and email as the original arguments passed in to the <code class="highlighter-rouge">register</code> function</li>
              <li>the password hash in the user object being the same as the hashed version of the original password passed in to the <code class="highlighter-rouge">register</code> function</li>
              <li>the error callback being called if a duplicate user is found (<code class="highlighter-rouge">USERNAME ALREADY EXISTS</code>)</li>
              <li>the error callback being called if a save issue occurred (<code class="highlighter-rouge">DOCUMENT SAVE ERROR</code>)</li>
            </ul>
          </li>
          <li>writing a small script to test if running the function actually creates a user in the database!
            <pre><code data-trim="" contenteditable="">require('../src/db.js');
const auth = require('../src/auth.js');
auth.register('testtest', 'test@test.test', 'testtest',
  function(err) {console.log(err);},
  function(user) {console.log(user);}
);
</code></pre>
          </li>
        </ol>
      </li>
    </ol>

    <h4 id="example-usage">Example Usage:</h4>

    <pre><code data-trim="" contenteditable="">function success(newUser) {
  // start an authenticated session and redirect to another page
}
function error(err) {
  // render a template containing an error message
}
auth.register(req.body.username, req.body.email, req.body.password, error, success);
</code></pre>

    <hr />

    <h3 id="login">login</h3>

    <p><code class="highlighter-rouge">login(username, password, errorCallback, successCallback)</code></p>

    <h4 id="parameters-1">Parameters:</h4>

    <ul>
      <li><code class="highlighter-rouge">username</code>: username</li>
      <li><code class="highlighter-rouge">password</code>: plain text password</li>
      <li><code class="highlighter-rouge">errorCallback</code>: function to call if an error occurs
        <ul>
          <li><code class="highlighter-rouge">errorCallback(errObj)</code></li>
          <li><code class="highlighter-rouge">errObj</code> will have a key called message that contains an error message</li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">successCallback</code>: function to call if login is successful
        <ul>
          <li><code class="highlighter-rouge">successCallback(userObject)</code></li>
          <li><code class="highlighter-rouge">userObject</code> is the object that represents the newly saved user</li>
        </ul>
      </li>
    </ul>

    <h4 id="return-1">Return:</h4>

    <ul>
      <li>no return value (instead, calls callback functions, <code class="highlighter-rouge">errorCallback</code> or <code class="highlighter-rouge">successCallback</code>)</li>
    </ul>

    <h4 id="description-2">Description:</h4>

    <ol>
      <li>when you encounter any errors as you run through the login process:
        <ul>
          <li>log the error to the console (server)</li>
          <li>call the <code class="highlighter-rouge">errorCallback</code> passing in an error object containing a key called <code class="highlighter-rouge">message</code> and a value of a string describing the error that occurred (this gives the caller the ability to pass in a function that handles the error - for example, rendering a template with an error message)</li>
          <li>some errors will require specific strings to be in the <code class="highlighter-rouge">message</code> property of the error object, while others are your discretion (read the instructions and run the tests for details)</li>
        </ul>
      </li>
      <li>find the user with username that was passed in
        <pre><code data-trim="" contenteditable="">User.findOne({username: username}, (err, user, count) =&gt; {
 if (!err &amp;&amp; user) {
         // compare with form password!
 }
});
</code></pre>
      </li>
      <li>if the user doesn&#39;t exist, call the <code class="highlighter-rouge">errorCallback</code> function with an object containing a <code class="highlighter-rouge">message</code> field that has the value <code class="highlighter-rouge">USER NOT FOUND</code></li>
      <li>if the user exists&#8230; then check if the password entered matches the password in the database
        <ul>
          <li>the password in the database is salted and hashed&#8230; and contains the salt</li>
          <li>so a simple compare with <code class="highlighter-rouge">===</code> is not adequate</li>
          <li>salt and hash the password and compare with the hash stored in the database</li>
          <li>use the function, <code class="highlighter-rouge">bcrypt.compare</code> to do this (<a href="https://www.npmjs.com/package/bcryptjs#usage---async">see the docs</a>:
            <pre><code data-trim="" contenteditable="">bcrypt.compare(password, user.password, (err, passwordMatch) =&gt; {
 // regenerate session if passwordMatch is true
});
</code></pre>
          </li>
          <li>note that <code class="highlighter-rouge">passwordMatch</code> within the callback will be either true or false, signifying whether or not the salted and hashed version of the incoming password matches the one stored in the database</li>
        </ul>
      </li>
      <li>once the match is verified, call the <code class="highlighter-rouge">successCallback</code> function with the user that was found</li>
      <li>check that your function works by:
        <ol>
          <li>running the unit tests, <code class="highlighter-rouge">mocha test/test-auth.js</code> (comment out all tests except for registration and login related ones), to check for:
            <ul>
              <li>the user object being passed to the <code class="highlighter-rouge">successCallback</code> when a login attempt works</li>
              <li>the following values for the <code class="highlighter-rouge">message</code> property on the error object passed to the <code class="highlighter-rouge">errorCallback</code>: <code class="highlighter-rouge">PASSWORDS DO NOT MATCH</code> and <code class="highlighter-rouge">USER NOT FOUND</code></li>
            </ul>
          </li>
          <li>writing a small script to test if running the function succeeds in logging a user in (that is, confirm that the success callback is called)
            <pre><code data-trim="" contenteditable="">require('../src/db.js');
const auth = require('../src/auth.js');
// assuming the user, testtest was already registered previously
auth.login('testtest', 'testtest',
  function(err) {console.log(err);},
  function(user) {console.log(user);}
);
</code></pre>
          </li>
        </ol>
      </li>
    </ol>

    <h4 id="example-usage-1">Example Usage:</h4>

    <pre><code data-trim="" contenteditable="">function success(newUser) {
  // successfully logged in!
  // start an authenticated session and redirect to another page
}
function error(err) {
  // render a template containing an error message
}
auth.login(req.body.username, req.body.password, error, success);
</code></pre>

    <hr />

    <h3 id="startauthenticatedsession">startAuthenticatedSession</h3>

    <p><code class="highlighter-rouge">startAuthenticatedSession(req, user, callback)</code></p>

    <h4 id="parameters-2">Parameters:</h4>

    <ul>
      <li><code class="highlighter-rouge">req</code>: an express Request object that contains a session variable</li>
      <li><code class="highlighter-rouge">user</code>: the user data to store in the session</li>
      <li><code class="highlighter-rouge">callback</code>: the callback to call after a new session has been created
        <ul>
          <li><code class="highlighter-rouge">callback(err)</code> - the callback only has a single parameter, <code class="highlighter-rouge">err</code></li>
        </ul>
      </li>
    </ul>

    <h4 id="return-2">Return:</h4>

    <ul>
      <li>no return value (instead, calls <code class="highlighter-rouge">callback</code> function)</li>
    </ul>

    <h4 id="description-3">Description:</h4>

    <ol>
      <li>regenerate a session id
        <ul>
          <li>use <code class="highlighter-rouge">req.session.regenerate</code> to do this (<a href="https://www.npmjs.com/package/express-session#sessionregeneratecallback">see the docs</a>)</li>
        </ul>
      </li>
      <li>add the user object passed in to the session; it should minimally contain <code class="highlighter-rouge">username</code> and <code class="highlighter-rouge">_id</code>, but other other properties (like email) can also be present</li>
      <li>test your code by running <code class="highlighter-rouge">mocha test/test-auth.js</code> (you can uncomment all commented out tests from previous runs)</li>
    </ol>

    <h4 id="example-usage-2">Example Usage:</h4>

    <pre><code data-trim="" contenteditable=""> // assuming that user is the user retrieved from the database
req.session.regenerate((err) =&gt; {
  if (!err) {
    req.session.username = user; 
  } else {
	// log out errorcall callback with error
  }
});
</code></pre>

    <h4 id="additional-notes">Additional Notes:</h4>

    <p>Once <code class="highlighter-rouge">startAuthenticatedSession</code> is called, you can:</p>

    <ol>
      <li>check if someone is logged in by looking at the user object in req.session (<code class="highlighter-rouge">if(req.session.user.username)</code>)</li>
      <li>add the user object to every context object for every template by using this middleware:
        <ul>
          <li>use <code class="highlighter-rouge">res.locals</code> (<a href="https://expressjs.com/en/api.html#res.locals">see express docs</a>) to do this:
            <pre><code data-trim="" contenteditable="">// add req.session.user to every context object for templates
app.use((req, res, next) =&gt; {
  // now you can use {{user}} in your template!
  res.locals.user = req.session.user;
  next();
});
</code></pre>
          </li>
          <li>in any template (or even in <code class="highlighter-rouge">layout.hbs</code>), you can use the following to conditionally display ui elements based on authenticated status:
            <pre><code data-trim="" contenteditable="">{{#if user}}
&lt;h1&gt;something that can only be seen if logged in&lt;/h1&gt;
{{/if user}}
</code></pre>
          </li>
        </ul>
      </li>
      <li>finally, to retrieve a username from the session, use: <code class="highlighter-rouge">req.session.user.usernmae</code></li>
    </ol>

    <h2 id="part-2---layout-homepage-registration-and-login">Part 2 - Layout, Homepage, Registration and Login</h2>

    <p>In this part, you&#39;ll implement the following pages:</p>

    <ol>
      <li><code class="highlighter-rouge">/</code> - home</li>
      <li>&#39;/register` - registration form</li>
      <li>&#39;/login` - login form</li>
    </ol>

    <p>The following routes should be supported:</p>

    <ol>
      <li><code class="highlighter-rouge">GET /</code></li>
      <li><code class="highlighter-rouge">GET /register</code></li>
      <li><code class="highlighter-rouge">POST /register</code></li>
      <li><code class="highlighter-rouge">GET /login</code></li>
      <li><code class="highlighter-rouge">POST /login</code></li>
    </ol>

    <h3 id="layout-and-homepage">Layout and Homepage</h3>

    <h4 id="create-a-layout-file">Create a Layout File</h4>

    <p>In <code class="highlighter-rouge">views/layout.hbs</code>, add a header that contains the following information:</p>

    <ul>
      <li>if the user is logged in:
  )* the user&#39;s username
        <ul>
          <li>a link to <code class="highlighter-rouge">/article/add</code> (to be implemented in part 3)</li>
        </ul>
      </li>
      <li>if the user is not logged in:
        <ul>
          <li>links to:
            <ul>
              <li><code class="highlighter-rouge">/login</code></li>
              <li><code class="highlighter-rouge">/register</code></li>
            </ul>
          </li>
          <li>the link to add an article should not appear!</li>
        </ul>
      </li>
      <li>for both logged in and non-logged in users:
        <ul>
          <li>a link to home, <code class="highlighter-rouge">/</code></li>
        </ul>
      </li>
    </ul>

    <h4 id="create-a-homepage">Create a Homepage</h4>

    <p><code class="highlighter-rouge">/</code> should show the header implemented above. In part 3, this page will be used to display data from the database.</p>

    <h3 id="registration-overview">Registration Overview</h3>

    <p>Registration should allow a user to create a new account and immediately start a new authenticated session. To do this, follow these steps:</p>

    <ol>
      <li>show a registration form</li>
      <li>after submitting the form, salt and hash the password using bcrypt</li>
      <li>save the username and salt/hash combination</li>
      <li>regenerate the session (create a new session id)</li>
      <li>add some information, such as the username, to the session</li>
      <li>redirect to home, <code class="highlighter-rouge">/</code>, if registration is successful</li>
    </ol>

    <p>Steps 2 through 5 are handled using the <code class="highlighter-rouge">register</code> function in the <code class="highlighter-rouge">auth</code> module that you implemented in Part 1.</p>

    <p>Step 6 should be implemented by passing a success callback function to <code class="highlighter-rouge">register</code></p>

    <p>There are two routes for registration:</p>

    <ol>
      <li><code class="highlighter-rouge">GET /register</code> - to display the form</li>
      <li><code class="highlighter-rouge">POST /register</code>- to process the form input</li>
    </ol>

    <h3 id="get-register-implementation">GET /register Implementation</h3>

    <ul>
      <li>find the route for <code class="highlighter-rouge">GET /register</code> in <code class="highlighter-rouge">app.js</code></li>
      <li>it should render a template, <code class="highlighter-rouge">register.hbs</code> that contains a form (<code class="highlighter-rouge">register.hbs</code> should already exist in your <code class="highlighter-rouge">views</code> folder)</li>
      <li>the form in <code class="highlighter-rouge">register.hbs</code> will&#8230;
        <ul>
          <li><code class="highlighter-rouge">POST</code> to <code class="highlighter-rouge">/register</code></li>
          <li>(that is, when you press the submit button, a POST request will be made to <code class="highlighter-rouge">/register</code>)</li>
        </ul>
      </li>
      <li>if there is a registration error, <code class="highlighter-rouge">register.hbs</code> can be re-rendered with a message showing the error above the form</li>
    </ul>

    <h3 id="post-register-implementation">POST /register Implementation</h3>

    <ul>
      <li>find the route for <code class="highlighter-rouge">POST /register</code> in <code class="highlighter-rouge">app.js</code></li>
      <li>call your <code class="highlighter-rouge">register</code> function using the data from the POST request&#39;s body (provided by the form that the user filled out)</li>
      <li>pass two functions, error and success callbacks, to your call to <code class="highlighter-rouge">register</code></li>
    </ul>

    <h4 id="success-callback">success callback</h4>

    <ul>
      <li>the success callback is only called if the registration works</li>
      <li>so it can assume that the new user now exists</li>
      <li>&#8230;and consequently, it can start an authenticated session for the new user using the <code class="highlighter-rouge">startAuthenticatedSession</code> function from the <code class="highlighter-rouge">auth</code> implemented above</li>
      <li>in turn, once an authenticated session is started, <em>its</em> callback should redirect to home (`/&#39;)</li>
      <li>here&#39;s what the resulting interaction might look like:
  <br /><img src="../resources/img/hw06-aintreddit-01-register.gif" /></li>
    </ul>

    <h4 id="error-callback">error callback</h4>

    <ul>
      <li>if , the registration does not work, then rerender the register template with an error</li>
      <li>to do this, the error callback should use the response object to call <code class="highlighter-rouge">render</code>, and the context should supply an error message</li>
      <li>minimally, the following errors should be shown
        <ol>
          <li>password length too short</li>
          <li>user already exists</li>
        </ol>
      </li>
      <li>all other errors can simply display a generic error message</li>
      <li>see below for examples of registration errors:
        <ul>
          <li>password or username length too short
  <br /><img src="../resources/img/hw06-aintreddit-03-register-short.gif" /></li>
          <li>user already exists
  <br /><img src="../resources/img/hw06-aintreddit-02-register-same.gif" /></li>
        </ul>
      </li>
    </ul>

    <h3 id="registration-testing">Registration Testing</h3>

    <ol>
      <li>in your browser, got to your registration page</li>
      <li>attempt to register a user
        <ul>
          <li>verify that you are redirected to the homepage</li>
          <li>use the mongo commandline client to check that you have user documents with username and password filled in</li>
        </ul>
      </li>
    </ol>

    <h3 id="login-overview">Login Overview</h3>

    <p>Login should allow a user to authenticate using a username and password. To do this, follow these steps:</p>

    <ol>
      <li>show a login form</li>
      <li>search the database for the username specified in the login form</li>
      <li>after finding the user, salt and hash the incoming password and compare with the password in the database by using <code class="highlighter-rouge">bcrypt.compare</code></li>
      <li>if the passwords match then start a new authenticated session</li>
      <li>redirect to the home page</li>
    </ol>

    <p>Steps 2 through 4 are handled by the <code class="highlighter-rouge">login</code> function in the <code class="highlighter-rouge">auth</code> module implemnted in a previous part.</p>

    <p>Step 5 should be implemented by passing a success callback function to <code class="highlighter-rouge">login</code></p>

    <p>There are two routes for login:</p>

    <ol>
      <li><code class="highlighter-rouge">GET /login</code> - to display the form</li>
      <li><code class="highlighter-rouge">POST /login</code>- to process the form input</li>
    </ol>

    <h3 id="get-login-implementation">GET /login Implementation</h3>

    <ul>
      <li>find the route for <code class="highlighter-rouge">GET /login</code> in <code class="highlighter-rouge">app.js</code></li>
      <li>it should render a template, <code class="highlighter-rouge">login.hbs</code> that contains a form (<code class="highlighter-rouge">login.hbs</code> should already exist in your <code class="highlighter-rouge">views</code> folder)</li>
      <li>the form in <code class="highlighter-rouge">login.hbs</code> will&#8230;
        <ul>
          <li><code class="highlighter-rouge">POST</code> to <code class="highlighter-rouge">/login</code></li>
          <li>(that is, when you press the submit button, a POST request will be made to <code class="highlighter-rouge">/login</code>)</li>
        </ul>
      </li>
      <li>if there is a login error, <code class="highlighter-rouge">login.hbs</code> can be re-rendered with a message showing the error above the form</li>
    </ul>

    <h3 id="post-login-implementation">POST /login Implementation</h3>

    <p>Handle the data POSTed by the login form&#8230;</p>

    <ul>
      <li>find the route for <code class="highlighter-rouge">POST /login</code> in <code class="highlighter-rouge">app.js</code></li>
      <li>call your <code class="highlighter-rouge">login</code> function using the data from the POST request&#39;s body (provided by the login form that the user filled out)</li>
      <li>pass two functions, error and success callbacks, to your call to <code class="highlighter-rouge">login</code></li>
    </ul>

    <h4 id="success-callback-1">success callback</h4>

    <ul>
      <li>the success callback is only called if the login works</li>
      <li>consequently, it can start an authenticated session for the logged in user using the <code class="highlighter-rouge">startAuthenticatedSession</code> function from the <code class="highlighter-rouge">auth</code> implemented earlier</li>
      <li>in turn, once an authenticated session is started, <em>its</em> callback should redirect to home (`/&#39;)</li>
      <li>here&#39;s what the resulting interaction might look like:
  <br /><img src="../resources/img/hw06-aintreddit-04-login.gif" /></li>
    </ul>

    <h4 id="error-callback-1">error callback</h4>

    <ul>
      <li>if , the login does not work, then re-render the login template with an error</li>
      <li>to do this, the error callback should use the response object to call <code class="highlighter-rouge">render</code>, and the context should supply an error message</li>
      <li>minimally, the following errors should be shown
        <ol>
          <li>user does not exist</li>
          <li>passwords do not match</li>
        </ol>
      </li>
      <li>all other errors can simply display a generic error message</li>
      <li>see below for examples of login errors:
        <ul>
          <li>user does not exist
  <br /><img src="../resources/img/hw06-aintreddit-05-no-username.gif" /></li>
          <li>passwords to not match
  <br /><img src="../resources/img/hw06-aintreddit-06-login-password.gif" /></li>
        </ul>
      </li>
    </ul>

    <h2 id="part-3---adding-and-displaying-articles">Part 3 - Adding and Displaying Articles</h2>

    <h3 id="adding-articles">Adding Articles</h3>

    <p>There are two routes for adding an article:</p>

    <ol>
      <li><code class="highlighter-rouge">GET /article/add</code> - to display the form</li>
      <li><code class="highlighter-rouge">POST /article/add</code>- to process the form input</li>
    </ol>

    <h3 id="get-articleadd-implementation">GET /article/add Implementation</h3>

    <ul>
      <li>make sure that only logged in users can reach this url:
        <ul>
          <li>check <code class="highlighter-rouge">req.session.user</code></li>
          <li>redirect to <code class="highlighter-rouge">/login</code> if the user is not logged in</li>
        </ul>
      </li>
      <li>find the route for <code class="highlighter-rouge">GET /article/add</code> in <code class="highlighter-rouge">app.js</code></li>
      <li>it should render a template, <code class="highlighter-rouge">article-add.hbs</code> that contains a form (<code class="highlighter-rouge">login.hbs</code> should already exist in your <code class="highlighter-rouge">views</code> folder)</li>
      <li>the form in <code class="highlighter-rouge">article-add.hbs</code> will&#8230;
        <ul>
          <li><code class="highlighter-rouge">POST</code> to <code class="highlighter-rouge">/article/add</code></li>
          <li>(that is, when you press the submit button, a POST request will be made to <code class="highlighter-rouge">/article/add</code>)</li>
        </ul>
      </li>
      <li>it has the following fields:
        <ol>
          <li><code class="highlighter-rouge">title</code> - the title of the article</li>
          <li><code class="highlighter-rouge">url</code> - the link to the article</li>
          <li><code class="highlighter-rouge">description</code> - a short description of the article</li>
        </ol>
      </li>
      <li>the following fields will be determined by your application
        <ol>
          <li><code class="highlighter-rouge">slug</code> - the unique, human-readable identifier for this article</li>
          <li>if you&#39;re using related documents, <code class="highlighter-rouge">user</code> - the user id associated with this article (if you&#39;re using embedded documents, you will find the logged in user in the database and add this article to it)</li>
        </ol>
      </li>
    </ul>

    <h3 id="post-articleadd-implementation">POST /article/add Implementation</h3>

    <ul>
      <li>make sure that only logged in users can reach this url:
        <ul>
          <li>check <code class="highlighter-rouge">req.session.user</code></li>
          <li>redirect to <code class="highlighter-rouge">/login</code> if the user is not logged in</li>
        </ul>
      </li>
      <li>create a new Article and associate it with a user
        <ul>
          <li>if you used related documents
            <ul>
              <li>remember to bring in your <code class="highlighter-rouge">Article</code> model: <code class="highlighter-rouge">const Article = mongoose.model('Article')</code>;</li>
              <li>you&#39;ll have to add the user id of the logged in user (this can be found in  the <code class="highlighter-rouge">_id</code> property of the session data, <code class="highlighter-rouge">req.session.user</code>, that you have for the currently logged in user)</li>
            </ul>
          </li>
          <li>if you used embedded documents
            <ul>
              <li>you&#39;ll have find the user that created the article in the database</li>
              <li>and push a new article into its list of embedded documents</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>in either case if the article / user is saved successfully, redirect to the home page (<code class="highlighter-rouge">/</code>), and if there&#39;s an error, re-render the <code class="highlighter-rouge">article-add.hbs</code> and display an error message</li>
      <li>note that the <code class="highlighter-rouge">slug</code> field should automatically be added for you by the <code class="highlighter-rouge">mongoose-url-slugs</code> plugin</li>
      <li>the entire interaction should look like this:
  <br /><img src="../resources/img/hw06-aintreddit-07-add.gif" /></li>
    </ul>

    <h3 id="testing">Testing</h3>

    <ul>
      <li>go to <code class="highlighter-rouge">/article/add</code></li>
      <li>make sure that you are redirected to login (if you&#39;re not logged in)</li>
      <li>register or login to your site</li>
      <li>go back to <code class="highlighter-rouge">/article/add</code></li>
      <li>submit the form</li>
      <li>using the commandline client, check that a new article has been added!</li>
    </ul>

    <h3 id="displaying-all-articles">Displaying All Articles</h3>

    <p>The homepage should display all of the articles added by users.</p>

    <ol>
      <li>go back to your route handler and template for your home page, <code class="highlighter-rouge">/</code></li>
      <li>query the database for all articles posted, and drop the result into the context object when rendering the template.</li>
      <li>in the template, display the title of the article&#8230;</li>
      <li>make the title a link to the url of the article
        <ul>
          <li>for example, if <code class="highlighter-rouge">title</code> is <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">url</code> is <code class="highlighter-rouge">http://bar.baz</code>&#8230; then the markup should be:</li>
          <li><code class="highlighter-rouge">&lt;a href="http://bar.baz/&gt;foo&lt;/a&gt;</code></li>
        </ul>
      </li>
      <li>additionally, link to a detail page for the article <code class="highlighter-rouge">/article/the-article-slug</code>; the link text should be &quot;details&quot;
        <ul>
          <li>for example, if the <code class="highlighter-rouge">slug</code> field of the article is <code class="highlighter-rouge">qux-corge</code>&#8230; then the markup should be:</li>
          <li><code class="highlighter-rouge">&lt;a href="/article/qux-corge"&gt;details&lt;/a&gt;</code> &#8230; note that the slug part would have to be filled in by a template variable</li>
        </ul>
      </li>
    </ol>

    <h3 id="displaying-an-articles-details">Displaying an Article&#39;s Details</h3>

    <p>The detail page, <code class="highlighter-rouge">/article/the-article-slug</code>, should show all of the fields of an aritcle, including:</p>

    <ul>
      <li>title</li>
      <li>url (this should actually link to the url displayed)</li>
      <li>username of the user that added the article</li>
      <li>desription</li>
    </ul>

    <h3 id="displaying-all-articles-and-article-details-example">Displaying All Articles and Article Details Example</h3>

    <p><img src="../resources/img/hw06-aintreddit-08-details.gif" /></p>

    <h2 id="extra-credit-5-points">Extra Credit (5 points)</h2>

    <ul>
      <li>create a route that shows only the articles added by a certain user</li>
      <li>its url should be /:username</li>
      <li>display the user&#39;s username on top of the page</li>
      <li>a list of articles should go underneath the username</li>
      <li>display the title and make it a link to the url</li>
    </ul>

  </div>

</div>

:ET