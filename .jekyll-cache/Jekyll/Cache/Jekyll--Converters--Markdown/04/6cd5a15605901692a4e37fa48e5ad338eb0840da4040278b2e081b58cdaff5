I"á"<section class="intro-slide">
  <h1 id="modifying-and-creating-elements">Modifying and Creating Elements</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="modifying-the-dom">Modifying the DOM</h2>

  <p><strong>What were some methods that we could use to add or get rid of elements from the DOM</strong> &#8594;</p>

  <ul>
    <li class="fragment"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node.removeChild"><code>.removeChild(childNodeToRemove)</code></a> - removes a child node from the DOM and returns it (node still exists in memory, but is no longer in DOM tree)</li>
    <li class="fragment"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node.appendChild"><code>.appendChild(nodeToAppend)</code></a> - puts node at end of list of this node&#39;s child nodes and returns the appended node</li>
    <li class="fragment"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node.insertBefore"><code>.insertBefore(nodeToInsert, beforeThisNode)</code></a> - inserts node before the node given as child of current node and returns the inserted node</li>
    <li class="fragment"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node.replaceChild"><code>.replaceChild(nodeToInsert, nodeToReplace)</code></a> - replaces a child of the current node with the nodeToInsert and returns the <strong>replaced node</strong></li>
  </ul>
</section>

<section>
  <h2 id="swapping-paragraphs">Swapping Paragraphs</h2>

  <p>We didn&#39;t have a chance to try this previously&#8230; so let&#39;s check out <a href="../../code/class19.html">another sample page</a>.
 Starting with:</p>

  <pre><code data-trim="" contenteditable="">
const content = document.getElementById('content');
const paragraphs = document.getElementsByTagName('p');
</code></pre>

  <p><strong>Move the 3rd paragraph between the first two.</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const inserted = content.insertBefore(paragraphs[2], paragraphs[1]);
</code></pre>

  <p class="fragment"><strong>Now, instead of just inserting before, let&#39;s replace paragraph &quot;Two&quot; with paragraph &quot;Three&quot;:</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const replaced = content.replaceChild(paragraphs[2], paragraphs[1]);
</code></pre>
</section>

<section>
  <h2 id="removing-elements">Removing Elements</h2>

  <p>We also looked at removing elements with <strong>removeChild</strong>. This was our first attempt:</p>

  <pre><code data-trim="" contenteditable="">
const div = document.getElementById('content');
const p = div.getElementsByTagName('p');

for(let i = 0; i &lt; p.length; i++) {
	div.removeChild(p[i]);
}
</code></pre>

  <p>But&#8230; <strong>what happened?</strong> &#8594;</p>

  <p class="fragment">There was an element left over because we were editing a <em>live</em> data structure. <strong>How did we fix this?</strong> &#8594;</p>
</section>

<section>
  <h2 id="removing-elements-continued">Removing Elements Continued</h2>

  <p>To get around this issue, we could:</p>

  <ul>
    <li>work backwards</li>
    <li>use a while loop</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
while (div.firstChild) {
  div.removeChild(div.firstChild);
}
</code></pre>

  <ul>
    <li>use a copy&#8230;</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
const copy = Array.prototype.slice.call(p, 0)
copy.forEach(function(ele) {
	div.removeChild(ele)
});
</code></pre>
</section>

<section>
  <h2 id="reading-and-modifying-a-nodes-content">Reading and Modifying a Node&#39;s Content</h2>

  <p>The following <strong>Node</strong> property and methods allow you to read and / or modify that Node&#39;s content:</p>

  <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeValue">nodeValue</a> - represents content of text and comment nodes, null otherwise</p>

  <pre><code data-trim="" contenteditable="">
// assuming we have an element_node, and we know its first child is a text element
console.log(node.firstChild.nodeValue);
node.firstChild.nodeValue = 'new text';
</code></pre>

  <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node.textContent">textContent</a> - the <strong>text content</strong> of the node and all of its descendants (!)</p>

  <pre><code data-trim="" contenteditable="">
const text = element.textContent; 
element.textContent = "this is some sample text";
</code></pre>

  <p>There are other properties similar to <code>textContent</code>, such as <code>innerHTML</code> (which includes markup) and <code>innerText</code> which is aware of styling (for example, ignores hidden elements).</p>
</section>

<section>
  <h2 id="node-content-continued">Node Content Continued</h2>

  <p><strong>What do the following lines of code represent / do based on the markup below?</strong> &#8594;</p>
  <pre><code data-trim="" contenteditable="">
&lt;div id="content"&gt;
	&lt;p&gt;One&lt;/p&gt;
	&lt;p class="cta"&gt;Two&lt;/p&gt;
	&lt;p class="cta"&gt;Three&lt;/p&gt;
&lt;/div&gt;
</code></pre>

  <pre><code data-trim="" contenteditable="">
document.body.textContent
document.body.innerHTML
document.body.nodeValue
const p = document.getElementsByTagName('p')[0]
p.firstChild.nodeValue
p.firstChild.nodeValue = 'Surprised?'
p.textContent = 'Maybe not.'
</code></pre>
</section>

<section>
  <h2 id="creating-nodes">Creating Nodes</h2>

  <p>The following methods actually create new Nodes!</p>

  <p><strong>Note&#8230; that they&#39;re called on the built-in <code>document</code> object, not on <code>Node</code> or an instance of <code>node</code>.</strong></p>

  <ul>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/document.createTextNode"><code>document.createTextNode(text)</code></a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/document.createElement"><code>document.createElement(elementName)</code></a></li>
  </ul>
</section>

<section>
  <h2 id="replacing-all-paragraphs-with-text">Replacing All Paragraphs With Text</h2>

  <p>Replace each paragraph element with text that says &quot;this was a paragraph&quot;.</p>
  <pre><code data-trim="" contenteditable="">
&lt;div id="content"&gt;
	&lt;p&gt;One&lt;/p&gt;
	&lt;p class="cta"&gt;Two&lt;/p&gt;
	&lt;p class="cta"&gt;Three&lt;/p&gt;
&lt;/div&gt;
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
const div = document.getElementById('content');
const p = div.getElementsByTagName('p');

for(let i = p.length - 1; i &gt;= 0; i--) {
	div.replaceChild( 
		document.createTextNode("this was a paragraph"),
		p[i]);
}
</code></pre>
</section>

<section>
  <h2 id="now-lets-try-adding-some-elements">Now Let&#39;s Try Adding Some Elements</h2>

  <p><strong>Instead of just a text node, replace each paragraph with an <code>h1</code> (a header). The text should remain the same.</strong> &#8594;</p>

  <ul>
    <li>in a  loop&#8230;</li>
    <li>create an h1 element node and a text node</li>
    <li>add the text node to the h1</li>
    <li>replace the div</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
const div = document.getElementById('content');
const p = div.getElementsByTagName('p');

for(let i = p.length - 1; i &gt;= 0; i--) {
	const header = document.createElement("h1");
	const content = document.createTextNode(p[i].textContent);
	header.appendChild(content);
	div.replaceChild(header, p[i]);
}
</code></pre>
</section>

<section>
  <h2 id="convenience">Convenience</h2>

  <p>Creating each element and adding a child was a bit of a drag&#8230;</p>

  <p><strong>The book uses a convenience method to add an element and an arbitrary number of child elements.</strong></p>

  <p>It acts like this: <code>elt(type, [, child1, ..., child2);</code> &#8594;</p>

  <ul>
    <li>creates an element of type <code>type</code></li>
    <li>an optional list of Elements follows</li>
    <li>each element will be added as a child</li>
    <li>if the element is just a string, create and add a text node</li>
  </ul>

  <p><strong>How would we create this?</strong> &#8594;</p>

</section>

<section>
  <h2 id="elt-implementation">elt Implementation</h2>

  <p><strong>A potential implementation&#8230;</strong> &#8594;</p>

  <ul>
    <li>uses the arguments object</li>
    <li>checks typeof to determine whether or not to create a text node</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
function elt(type) {
	const ele = document.createElement(type);
	// start at 1 or else we'll get the type argument!
	for (let i = 1; i &lt; arguments.length; i++) {
		let child = arguments[i];
		if (typeof child === "string") {
			child = document.createTextNode(child);
		}
		ele.appendChild(child);
	}
	return ele;
}
const ul = elt('ul', elt('li', 'item one'), elt('li', 'item two'));
document.body.appendChild(ul);
</code></pre>
</section>
:ET