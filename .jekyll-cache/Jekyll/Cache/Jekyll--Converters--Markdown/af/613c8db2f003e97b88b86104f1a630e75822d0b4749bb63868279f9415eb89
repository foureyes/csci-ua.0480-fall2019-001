I"„3<style>
.warning {
    background-color: #ffaabb;
}
</style>

<div class="panel panel-default">
  <div class="panel-heading">Homework #8</div>
  <div class="panel-body">

    <h1 id="ajax---due-tuesday-dec-11th-by-11pm">AJAX - <strong>Due Tuesday, Dec 11th by 11pm</strong></h1>

    <h2 id="overview">Overview</h2>

    <h3 id="goals--topics-covered">Goals / Topics Covered</h3>

    <p>You&#39;ll be using the following concepts:</p>

    <ul>
      <li>XMLHttpRequest</li>
      <li>sending back json from Express</li>
    </ul>

    <h3 id="description">Description</h3>

    <p>Create an app that saves random strings created by smashing the keyboard with your hands.</p>

    <p>In the &quot;sounds&quot; homework assignment, the page must be reloaded whenever you want to refresh the visible data or insert more data. Most websites don&#39;t work/look like this because they use AJAX, i.e. browser-side, they write javascript that makes a web request to some api, then changes the DOM (using <code class="highlighter-rouge">document.querySelector</code>) when it requests an http response from the api.</p>

    <p>This assignment is to help you practice implementing that, by creating a web app for users to vent their emotions by smashing their keyboard into a text input (a <code class="highlighter-rouge">textarea</code> that will be saved to a database (to use later for data mining for ad targeting, of course, because&#8230; what else do you do with data, amirite?).</p>

    <p>To do this, you&#39;ll be given a partially implemented express application. You&#39;ll have to finish it up by:</p>

    <ol>
      <li>Implementing routes to create an API for retrieving smashings and adding new ones</li>
      <li>Using JavaScript to trigger background requests to the API from the form submit buttons</li>
    </ol>

    <p>Use the following resources as reference:</p>

    <ol>
      <li><a href="../slides/20/ajax.html">Slides on AJAX Part 1</a></li>
      <li><a href="../slides/21/ajax-express.html">Slides on AJAX Part 2</a></li>
      <li><a href="../slides/21/ajax-express.html#/47">AJAX POST (from Part 2)</a></li>
    </ol>

    <p>Check out the video below to see how the site will work. Pay attention to:</p>

    <ul>
      <li>the button presses</li>
      <li>the changes in the ui</li>
      <li>&#8230;and the network tab</li>
      <li>notice that there are no page refreshes!</li>
    </ul>

    <p><img src="https://lh00000000-public.s3.amazonaws.com/2018/appinter/hwx.gif" alt="a browser page with the network tab of the browser inspector tools open showing a web app where entering random text adds a row of data to the table of data on the screen. the top of the page has interactive filters that filter the results below. this filtering functionality is then demonstrated by filtering for short instances of random text" /></p>

    <h3 id="submission-process">Submission Process</h3>

    <p>You will be given access to a private repository on GitHub.  The final version of your assignment should be in GitHub</p>

    <ul>
      <li><strong>Push</strong> your changes to the homework repository on GitHub.</li>
      <li>Commits later than that date will be handled on a case-by-case basis.</li>
    </ul>

    <h3 id="make-at-least-3-commits">Make at Least 3 Commits</h3>

    <ul>
      <li>Commit multiple times throughout your development process.</li>
      <li>Make at least 3 separate commits</li>
    </ul>

    <h3 id="code-structure">Code Structure:</h3>

    <p><strong>You will be given an express application that is served on port 3000.</strong> The structure looks like this:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.eslintrc.js
.gitignore
package-lock.json
package.json
src
‚îú‚îÄ‚îÄ app.js             # edit this file
‚îú‚îÄ‚îÄ db.js
‚îî‚îÄ‚îÄ public
    ‚îú‚îÄ‚îÄ css
    ‚îÇ   ‚îî‚îÄ‚îÄ base.css
    ‚îú‚îÄ‚îÄ index.html
    ‚îî‚îÄ‚îÄ js
        ‚îî‚îÄ‚îÄ index.js   # edit this file
</code></pre></div>    </div>

    <p>Note that this will be implemented <strong>as a single page web app</strong>. This means that to implement these features:</p>

    <ol>
      <li><strong>create routes that send back JSON</strong> (essentially create an API)</li>
      <li>utilize the API by writing client side JavaScript that:
        <ul>
          <li>constructs an http request by retrieving the values of form elements</li>
          <li>requests data from url constructed in the background (AJAX)</li>
          <li>parses the result of the background request</li>
          <li>modifies the DOM appropriately</li>
        </ul>
      </li>
    </ol>

    <h3 id="some-of-this-project-is-already-built-for-you">Some of This Project is Already Built for You!</h3>

    <ol>
      <li>Server side code
        <ul>
          <li>database setup (a mongoose model, database connection, etc.) is provided through <code class="highlighter-rouge">db.js</code></li>
          <li>a partially implemented Express application is in <code class="highlighter-rouge">app.js</code>
            <ul>
              <li>it has basic setup for body parsing, static files, etc.</li>
              <li>it has some helper functions for generating smashing instances</li>
              <li>it has stubs for route handlers, with some minor parts implemented (such as forming a query object for mongoose based on query string parameters in the url)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Client side code
        <ul>
          <li>there are static files present in <code class="highlighter-rouge">public</code></li>
          <li>the html (<code class="highlighter-rouge">index.html</code>) and css (<code class="highlighter-rouge">base.css</code>) are already built</li>
          <li>but the client side JavaScript is mostly left unimplemented (<code class="highlighter-rouge">index.js</code>), so you&#39;ll have to flesh out the majority of the function definitions</li>
        </ul>
      </li>
    </ol>

    <h3 id="fetching-and-filtering">Fetching and Filtering:</h3>

    <ol>
      <li>Finish the route, <code class="highlighter-rouge">GET /api/smashings</code> (in <code class="highlighter-rouge">app.js</code>, <strong>the server</strong>), which returns all of the existing smashing in the database
        <ol>
          <li>This route will support several query string paremeters (you can see them in the names of the form&#39;s input elements)</li>
          <li>It should return JSON list of smashing objects. For example, <code class="highlighter-rouge">GET /api/smashings?lengthGt=2&amp;lengthLt=55555</code>  (note that smashings is plural, not singular!) could return:
            <pre><code data-trim="" contenteditable="">[
  {smashingText: 'aaa', length: 3, etc.}, 
  {smashingText: 'asdf', length: 4, etc.}
]
</code></pre>
          </li>
          <li>To test, add some data into your database manually using the commandline mongo client using the properties supplied above (you can skip the letter counts to make things easier)</li>
          <li>enter the url <code class="highlighter-rouge">http://localhost:3000/api/smashings</code> in your browser; you should get JSON back&#8230; with the JSON containing the smashings that you just entered</li>
          <li>enter the url again&#8230; but now with query string parameters (such as lengthGt=2) to see if the filtering part works</li>
        </ol>
      </li>
      <li>Add some JavaScript to <code class="highlighter-rouge">src/public/js/index.js</code> (<strong>the client side JavaScript</strong>)so that once the page loads:
        <ol>
          <li>a background request is made to the the api url above using <code class="highlighter-rouge">XMLHttpRequest</code> or <code class="highlighter-rouge">fetch</code></li>
          <li>do this by finishing the implementations in <code class="highlighter-rouge">index.js</code> for the following functions (fill in the parts underneath the comments that start with <code class="highlighter-rouge">TODO</code>):
            <ul>
              <li><code class="highlighter-rouge">insertSmashing</code> to insert data from a single smashing instance into the DOM given an object representing the smashing</li>
              <li><code class="highlighter-rouge">deleteAllResults</code> to remove all of the smashings displayed in the DOM</li>
              <li><code class="highlighter-rouge">refreshResults</code> to retrieve filtered (or unfiltered if the form is not filled) smashing data from the api and display its results (you can use some of the functions above to do this)
                <ul>
                  <li>you&#39;ll use <code class="highlighter-rouge">XMLHttpRequest</code> or <code class="highlighter-rouge">fetch</code> here</li>
                  <li>the url will either be <code class="highlighter-rouge">/api/smashings</code> or <code class="highlighter-rouge">/api/smashings?foo=bar&amp;baz=qux</code> (the query string will be composed of names and values from the form input elements in the filter form)</li>
                </ul>
              </li>
              <li><code class="highlighter-rouge">main</code> to add event handlers and show the initial data on page load</li>
              <li>‚ö†Ô∏è  <strong>remember to make sure that the regular form button press event isn&#39;t triggered (use <code class="highlighter-rouge">preventDefault</code>)</strong></li>
            </ul>
          </li>
          <li>detailed descriptions of each function is in comments within the source code</li>
          <li>test by:
            <ul>
              <li>going to the page and verifying that all smashings are loaded</li>
              <li>open your network tab to see an <code class="highlighter-rouge">xhr</code> request to <code class="highlighter-rouge">api/smashings</code></li>
              <li>using the form to filter and verifying that the results on the page are updated without a page refresh</li>
              <li>again, check your network tab to see an <code class="highlighter-rouge">xhr</code> request to <code class="highlighter-rouge">api/smashings</code>&#8230; but note that the request should have query string parameters attached to it</li>
            </ul>
          </li>
        </ol>
      </li>
    </ol>

    <h3 id="adding-new-keyboard-smashes">Adding New Keyboard Smashes</h3>

    <ol>
      <li>In the route, <code class="highlighter-rouge">POST /api/smashing</code> (in <code class="highlighter-rouge">app.js</code>, <strong>the server</strong>),  create a new smashing document and save it in the database
        <ul>
          <li>it should give back a JSON object as the response: <code class="highlighter-rouge">{"_code": "OK"}</code> or, if there&#39;s an error, <code class="highlighter-rouge">{"_code": "ERROR"}</code></li>
        </ul>
      </li>
      <li>In <code class="highlighter-rouge">index.js</code>, <strong>the client-side JavaScript</strong> &#8230;
        <ol>
          <li>finish the implementation of the following functions (fill in the parts underneath the comments that start with <code class="highlighter-rouge">TODO</code>).
            <ul>
              <li><code class="highlighter-rouge">postSmashing</code> to send a POST request to save smashing data in the database
                <ul>
                  <li>using <code class="highlighter-rouge">XMLHttpRequest</code> or <code class="highlighter-rouge">fetch</code>, make a POST request</li>
                  <li>set the <code class="highlighter-rouge">ContentType</code> to <code class="highlighter-rouge">application/x-www-form-urlencoded</code></li>
                  <li>set the body to the value of the textarea</li>
                  <li>the response should trigger the client to refresh the data on the page with the newly created smashing (note, not a page refresh, but just updated DOM elements)
 		* <strong>if there was a filter set before adding, then clear the filter to show all smashings, including the newly added one</strong></li>
                  <li>use existing helper functions within <code class="highlighter-rouge">index.js</code> to aid in this implementation</li>
                </ul>
              </li>
              <li><code class="highlighter-rouge">main</code> (you may have have finished this already) to add an event listener to handle a button press for the form to create a keyboard smashing
 		* remember to make sure that the regular form button press event isn&#39;t triggered (use <code class="highlighter-rouge">preventDefault</code>)</li>
            </ul>
          </li>
          <li>more details for these functions can be found in the comments</li>
          <li>test this by:
            <ul>
              <li>openining the network tab</li>
              <li>submitting the form</li>
              <li>viewing the <code class="highlighter-rouge">xhr</code> POST request in the network tab
 		* verifying that the data is saved in the database by using the <code class="highlighter-rouge">mongo</code> commandline client</li>
              <li>verifying that the new saved smashing also shows up on the page (without a page refresh)</li>
            </ul>
          </li>
        </ol>
      </li>
    </ol>
  </div>
</div>

:ET