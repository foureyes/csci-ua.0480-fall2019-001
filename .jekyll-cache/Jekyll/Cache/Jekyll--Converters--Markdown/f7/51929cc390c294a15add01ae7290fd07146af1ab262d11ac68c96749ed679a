I"^Q<section class="intro-slide">
  <h1 id="some-es6-features">Some ES6 Features!</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="es6">ES6</h2>

  <p><strong>Where is it available?</strong> &#8594;</p>

  <ul>
    <li>most features are supported by <strong>node (server side)</strong>
      <ul>
        <li><a href="http://kangax.github.io/compat-table/es6/">see the compatibility table</a></li>
        <li>there are some exceptions, notably <code class="highlighter-rouge">import</code>/modules</li>
      </ul>
    </li>
    <li>same for most modern browsers (client side)</li>
    <li>feel free to use in your code!</li>
  </ul>
</section>

<section>
  <h2 id="declaring-variables">Declaring Variables</h2>

  <p><strong>We can declare variables using these keywords:</strong> &#8594;</p>

  <ul>
    <li><code class="highlighter-rouge">var</code> - (we&#39;ve know this!) function level scope</li>
    <li><code class="highlighter-rouge">let</code> - es6! &#8230; block level scope</li>
    <li><code class="highlighter-rouge">const</code> - es6! &#8230; block level scope, but you can&#39;t reassign this name to another object
      <ul>
        <li>note - does not make value constant</li>
        <li>you just can&#39;t use <code class="highlighter-rouge">=</code> again
          <pre><code data-trim="" contenteditable="">
// AN ERROR OCCURS!
const foo = 'bar';
foo = 'baz';
</code></pre>
        </li>
      </ul>
    </li>
  </ul>

  <p><br /></p>

</section>

<section>
  <h2 id="const-let-and-var">const, let, and var</h2>

  <p><strong>OK&#8230; so, which is the right one to use?</strong> &#8594;</p>

  <ol>
    <li><strong>NEVER USE</strong> <code class="highlighter-rouge">var</code> again!</li>
    <li>consider using <code class="highlighter-rouge">const</code> for all variable declarations</li>
    <li>some common places to use <code class="highlighter-rouge">let</code>: &#8230; perhaps in a for loop
      <pre><code data-trim="" contenteditable="">
for(let i = 0; i &lt; 5; i++) {
 console.log(i);
}
</code></pre>
    </li>
  </ol>

  <p><br /></p>

  <p>Note that this will not work!</p>

  <pre><code data-trim="" contenteditable="">
for(const i = 0; i &lt; 5; i++) {
    console.log(i);
}
</code></pre>
</section>

<section>
  <h2 id="block-level-scope">Block Level Scope?</h2>

  <p>Using <code class="highlighter-rouge">let</code> and <code class="highlighter-rouge">const</code> gives you block level scope, so, now, <strong>JavaScript may behave more <em>normally</em>:</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
for(let i = 0; i &lt; 5; i++) {
    console.log(i);
    let greeting = "hello " + i;
}
// these console.logs  will give an error!
console.log(i); 
console.log(greeting); 
</code></pre>

  <p><code class="highlighter-rouge">greeting</code> and <code class="highlighter-rouge">i</code> are only available within curly braces, such as within:</p>

  <ul>
    <li>within a function definition</li>
    <li>a loop / other control structure</li>
    <li>etc.</li>
  </ul>

</section>

<section>
  <h2 id="temporal-dead-zone">Temporal Dead Zone</h2>

  <p>ALSO.. <strong><code class="highlighter-rouge">let</code> and <code class="highlighter-rouge">const</code> now act <em>normally</em> vs <code class="highlighter-rouge">var</code></strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
console.log(foo);
var foo = 'bar';
// works fine
</code></pre>
  <pre><code data-trim="" contenteditable="">
console.log(foo);
let foo = 'bar';
// does not work
</code></pre>

  <p>Temporal because&#8230; it&#39;s <strong>when</strong> let is declared, not where it is in actual code.</p>

</section>

<section>
  <h2 id="arrow-functions">Arrow Functions</h2>

  <p><strong>We use function expression</strong> &#8594;</p>

  <ul>
    <li>as anonymous functions (when we need a callback, but we don&#39;t want to define a separate named function)</li>
    <li>for creating functions as values to assign to a variable or property name</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
function(arg1, arg2) {
    // body
}
</code></pre>

  <p>ES6 allows new syntax and semantics for doing this, using <strong>arrow function</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
(arg1, arg2) =&gt; { // body goes here }
</code></pre>

  <ul>
    <li><code class="highlighter-rouge">this</code> in arrow function is this of enclosing context / scope</li>
    <li>works the way you expect (it won&#39;t <em>just be global</em> for most cases)
      <ul>
        <li>maybe no more <code class="highlighter-rouge">bind</code> needed!</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="why-use-arrow-functions">Why Use Arrow Functions</h2>

  <p>This just seems like the same thing as function expressions, though. <strong>Why use arrow functions <em>at all</em>?</strong> &#8594;</p>

  <ul>
    <li>concise syntax!</li>
    <li><code class="highlighter-rouge">this</code> is the same this as context that arrow function was declared in</li>
  </ul>

  <p><br />
<strong>Um, what does that mean exactly?</strong></p>

</section>

<section>
  <h2 id="first-a-problem">First, A Problem</h2>

  <p><strong>Check out this contrived code. What do you think the output is?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
function Transformer(number) {
    this.number = number;
}
</code></pre>

  <pre><code data-trim="" contenteditable="">
Transformer.prototype.multiply = function(arr) {
    return arr.map(function(ele) {
        return this.number * ele;
    });
};
</code></pre>

  <pre><code data-trim="" contenteditable="">
const t = new Transformer(2);
const result = t.multiply([1, 2, 3, 4]);
console.log(result);
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
// the output is (!!??):
[ NaN, NaN, NaN, NaN ]
</code></pre>

</section>

<section>
  <h2 id="what-happened">What Happened?</h2>

  <p><strong>Take a close look at the <code class="highlighter-rouge">multiply</code> method:</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
Transformer.prototype.multiply = function(arr) {
    return arr.map(function(ele) {
        return this.number * ele;
    });
};
</code></pre>

  <p><strong>Why did we get an <code class="highlighter-rouge">Array</code> of <code class="highlighter-rouge">NaN</code>&#39;s?</strong> &#8594;</p>

  <ul>
    <li class="fragment">the function passed to map refers to <code class="highlighter-rouge">this.number</code></li>
    <li class="fragment">that function is called as a regular function because it&#39;s not called with the context of an object</li>
    <li class="fragment">so <code class="highlighter-rouge">this</code> is global, and <code class="highlighter-rouge">this.number</code> is undefined</li>
  </ul>
</section>

<section>
  <h2 id="and-back-to-arrow-functions">And Back to Arrow Functions</h2>

  <p><strong>If we make a slight modification to our <code class="highlighter-rouge">multiply</code> method, we&#39;ll see the advantage of arrow functions in this situation</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
Transformer.prototype.multiply = function(arr) {
    return arr.map((ele) =&gt; {
        return this.number * ele;
    });
};
</code></pre>

  <ul>
    <li>now&#8230; <code class="highlighter-rouge">this</code> will be the same this as the enclosing context (which is the <code class="highlighter-rouge">multiply</code> method)</li>
    <li>the <code class="highlighter-rouge">multiply</code> method&#39;s <code class="highlighter-rouge">this</code> is set to the instance that it was called on!</li>
  </ul>

  <p><br />
<strong>We&#39;ll discuss arrow functions a little more later on in these slides.</strong> &#8594;</p>

</section>

<section>
  <h2 id="string-interpolation">String Interpolation</h2>

  <p>Create a string with backticks:</p>

  <pre><code data-trim="" contenteditable="">
const target = 'world';
console.log(`hello ${target}`)
</code></pre>

</section>

<section>
  <h2 id="destructuring">Destructuring</h2>

  <p>Think of it as multiple assignment:</p>

  <ul>
    <li>works with Arrays</li>
    <li>works with objects (but you use curly braces instead)</li>
  </ul>

  <p><br /></p>

  <pre><code data-trim="" contenteditable="">
const coord = [1, 2];
let [x, y] = coord;
console.log(x); // 1
console.log(y); // 2
</code></pre>

  <pre><code data-trim="" contenteditable="">
const {a, b} = {a: 1, b:2}
</code></pre>

</section>

<section>
  <h1 id="more-es6">More ES6!</h1>
</section>

<section>
  <h2 id="arrow-functions-again">Arrow Functions Again</h2>

  <p>Arrow functions are already pretty concise. In ES5, you might find code that looks like this:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
var numbers = [1, 2, 3, 4];
var result = numbers.map(function(num) { return num * 2});
</code></pre>

  <p class="fragment">With arrow functions, that becomes:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const numbers = [1, 2, 3, 4];
const result = numbers.map((num) =&gt; {return num * 2});
</code></pre>

  <p class="fragment">In fact, we can drop the parentheses, curly braces and rely on the fact that arrow functions will implicitly return the last expression to drop the <code class="highlighter-rouge">return</code> to get this:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const numbers = [1, 2, 3, 4];
const result = numbers.map(num =&gt; num * 2);
</code></pre>
</section>

<section>
  <h2 id="where-not-to-use-arrow-functions">Where <em>Not</em> to Use Arrow Functions</h2>

  <p>That was pretty great, so <strong>why don&#39;t we use arrow functions all of the time?</strong> &#8594;</p>

  <p class="fragment"><strong>There are some places where they don&#39;t work quite right.</strong></p>

  <ul>
    <li class="fragment">creating addEventListener callbacks where you want <code class="highlighter-rouge">this</code> to refer to the element that generated the event</li>
    <li class="fragment">creating constructors</li>
    <li class="fragment">creating methods
      <ul>
        <li class="fragment">either on object literals</li>
        <li class="fragment">or on prototypes</li>
      </ul>
    </li>
  </ul>

  <p class="fragment"><br />
<strong>But why not?</strong> &#8594;</p>

  <p class="fragment">Remember, arrow functions do not bind this to a new value, and instead gets its this from the enclosing scope</p>

</section>

<section>
  <h2 id="arrow-functions-and-addeventlistener">Arrow Functions and <code class="highlighter-rouge">addEventListener</code></h2>

  <p><strong>Be careful when using arrow functions and <code class="highlighter-rouge">addEventListener</code></strong> &#8594;</p>

  <p>Starting with this code:</p>
  <pre><code data-trim="" contenteditable="">
const button = document.createElement('button');
document.body.appendChild(button).textContent = 'Click Me';
</code></pre>

  <p class="fragment">The following listeners alert different messages!</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
// alerts window object (essentially global)
button.addEventListener('click', () =&gt; {alert(this)});
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
// alerts button element
button.addEventListener('click', function()  {alert(this)});
</code></pre>

  <ul>
    <li class="fragment">if you want <code class="highlighter-rouge">this</code> in your event handler to reference the element event&#39;s target element, then use function expressions</li>
    <li class="fragment">&#8230;because arrow functions don&#39;t create their own <code class="highlighter-rouge">this</code>, and instead use the this from the surrounding context</li>
  </ul>

</section>

<section>
  <h2 id="arrow-functions-cannot-be-constructors">Arrow Functions Cannot be Constructors</h2>

  <p><strong>In the following code, we try to use an arrow function as a constructor.</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
const Cat = (name) =&gt; {
    this.name = name;
}
</code></pre>

  <p>Creating the function works fine, but if we try to use it with <code class="highlighter-rouge">new</code>:</p>

  <pre><code data-trim="" contenteditable="">
var c = new Cat();
</code></pre>

  <p>We get&#8230;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
var c = new Cat();
        ^
TypeError: Cat is not a constructor
</code></pre>

  <p class="fragment">Instead, use the usual function declaration to create constructors:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function Cat(name) {
    this.name = name;
}
</code></pre>

</section>

<section>
  <h2 id="arrow-functions-as-methods">Arrow Functions as Methods</h2>

  <p><strong>What is the output of this code?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
function Cat(name) {
    this.name = name;
}
Cat.prototype.meow = (() =&gt; {
    console.log(this.name, 'meows');
});
var c = new Cat('paw newman');
c.meow();
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
undefined meows
</code></pre>

  <ul>
    <li class="fragment">&#8230;because arrow functions do not bind a new value to <code class="highlighter-rouge">this</code></li>
    <li class="fragment">again, <code class="highlighter-rouge">this</code> remains the same as the <code class="highlighter-rouge">this</code> in the containing context / scope</li>
    <li class="fragment">(which, in this case is the global object)</li>
  </ul>
</section>

<section>
  <h2 id="arrow-functions-as-methods-on-object-literals">Arrow Functions as Methods on Object Literals</h2>

  <p><strong>What&#39;s the output of this code?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">const cat = {
    sound: 'meow',
    meow: () =&gt; {console.log(this.sound);}
};
cat.meow();
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
// once again...
undefined
</code></pre>
</section>

<section>
  <h2 id="object-literals">Object Literals</h2>

  <p><strong>While we&#39;re on the subject of object literals, we should also take a quick look at:</strong> &#8594;</p>

  <ul>
    <li>Shorthand methods</li>
    <li>Dynamic / calculated properties</li>
  </ul>

</section>

<section>
  <h2 id="shorthand-methods">Shorthand Methods</h2>

  <p><strong>In ES5, you can create methods on objects simply by setting properties equal to function expressions:</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
const obj = {
  f: function() {console.log('fffff!');},
  g: function() {console.log('ggggg!');},
};
obj.f();
obj.g();
</code></pre>

  <p>Unfortunately, we can&#39;t use arrow functions (see previous slides) for methods on objects, but there is a shorthand ES6 syntax that makes things a little more concise:</p>

  <pre><code data-trim="" contenteditable="">
// the function() part can be dropped:
const obj = {
    f() {console.log('fffff!');},
    g() {console.log('ggggg!');},
};
</code></pre>

</section>

<section>
  <h2 id="calculated-property-names">Calculated Property Names</h2>

  <p><strong>ES6 allows you to use calculated/dynamic values as property names in object literal notation</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
const propName = 'published';
const book = {title: 'Snowcash', [propName]: 1992};
console.log(book.published);
</code></pre>

  <ul>
    <li><code class="highlighter-rouge">propName</code> is a variable that contains the value <code class="highlighter-rouge">published</code></li>
    <li>which means that using <code class="highlighter-rouge">[propName]</code> creates a property on the object <code class="highlighter-rouge">book</code> called <code class="highlighter-rouge">published</code></li>
    <li>(you could always create property/value pairs with properties that are variables by using assignment on an existing object)</li>
    <li>(but now it can be done in an object literal as well!)</li>
  </ul>

</section>

<section>
  <h2 id="classes">Classes</h2>

  <p><strong>Since we&#39;re talking about objects, we should also discuss ES6 classes.</strong></p>

  <ul>
    <li>they&#39;re syntactic sugar for creating constructors and methods</li>
    <li>in actuality, everything is still prototypes and constructor functions</li>
    <li>but now there&#39;s more familiar syntax to create constructors, methods&#8230; and &quot;classes&quot;</li>
  </ul>
</section>

<section>
  <h2 id="example-es6-class">Example ES6 Class</h2>

  <p><strong>These two bits of code both produce a function called <code class="highlighter-rouge">HttpRequest</code>!</strong> &#8594;</p>

  <p>ES6 class:</p>

  <pre><code data-trim="" contenteditable="">
class HttpRequest {
}
</code></pre>

  <p>ES5 constructor:</p>

  <pre><code data-trim="" contenteditable="">
function HttpRequest() {
}
</code></pre>

  <p>Both result in the same output when used in the following manner:</p>

  <pre><code data-trim="" contenteditable="">
const req = new HttpRequest();
console.log(HttpRequest);
console.log(typeof req.constructor);
console.log(req.constructor.name);
</code></pre>

</section>

<section>
  <h2 id="constructors">Constructors</h2>

  <p>ES6 style classes allow for a constructor to be defined as follows:</p>

  <ul>
    <li>within the class definition, create a function called constructor</li>
    <li>no function keyword is required</li>
    <li>the constructor has access to <code class="highlighter-rouge">this</code> which represents the instance that is created</li>
  </ul>

  <p><br /></p>
  <pre><code data-trim="" contenteditable="">
class HttpRequest {
    constructor(method, url) {
        this.method = method;
        this.url = url;
    }
}
</code></pre>

  <p>The above code is <em>mostly</em> the same as this ES5 function that can be used as a constructor:</p>

  <pre><code data-trim="" contenteditable="">
function HttpRequest(method, url) {
   this.method = method;
   this.url = url;
}
</code></pre>

  <p>We&#39;ll see later that subclass constructors must call super before using <code class="highlighter-rouge">this</code>.</p>
</section>

<section>
  <h2 id="methods-in-es5">Methods in ES5</h2>

  <p><strong>In ES5, to add a method to the prototype, we&#39;d have to do something like this:</strong>&#8594;</p>

  <pre><code data-trim="" contenteditable="">
function HttpRequest(method, url) {
   this.method = method;
   this.url = url;
}
</code></pre>

  <pre><code data-trim="" contenteditable="">
HttpRequest.prototype.makeRequest = function() {
    return this.method + ' ' + this.url + ' HTTP/1.1';
}
</code></pre>

</section>

<section>
  <h2 id="methods-in-es6">Methods in ES6</h2>

  <p><strong>In ES6, we can define methods directly in the class definition, and they will show up in the instances&#39; prototype</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
class HttpRequest {
  constructor(method, url) {
    this.method = method;
    this.url = url;
  }

  makeRequest() {
    return this.method + ' ' + this.url + ' HTTP/1.1';
  }
}
</code></pre>

  <ul>
    <li>note that there are no commas between method and constructor definitions</li>
    <li>again, you do not have to use the keyword, <code class="highlighter-rouge">function</code></li>
    <li>methods, of course, can reference <code class="highlighter-rouge">this</code>, and if the method is called within the context of an instance, then <code class="highlighter-rouge">this</code> refers to the instance</li>
  </ul>

</section>

<section>
  <h2 id="es6-methods-continued">ES6 Methods Continued</h2>

  <p><strong>Note that creating these methods in ES6 style classes is <em>actually</em> just adding to the prototype!</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
const req = new HttpRequest('GET', 'http://foo.bar/baz');
console.log(req.makeRequest());
console.log(Object.getPrototypeOf(req).makeRequest);
</code></pre>

</section>

<section>
  <h2 id="inheritance">Inheritance</h2>

  <p><strong>Use <code class="highlighter-rouge">extends</code> to inherit from a class!</strong></p>

  <pre><code data-trim="" contenteditable="">
class Element {
    constructor(name) {
        this.name = name; 
    }
}
</code></pre>

  <pre><code data-trim="" contenteditable="">
class ImgElement extends Element {
    // make sure to call super before using this
    // within subclass
    constructor(url) {
        super('img');
        this.url = url;
    }
}
</code></pre>

  <pre><code data-trim="" contenteditable="">
const img = new ImgElement('http://foo.bar/baz.gif');
console.log(img.name);
console.log(img.url);
</code></pre>

</section>

:ET