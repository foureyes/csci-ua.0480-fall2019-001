I"0<section class="intro-slide">
  <h1 id="sockets--net-module-review">Sockets / net Module Review</h1>

  <h3 id="section">-</h3>

  <p><small></small></p>
</section>
<section>
  <h2 id="nodes-net-module">Node&#39;s net Module</h2>

  <p><strong>What&#39;s the <code class="highlighter-rouge">net</code> module used for?</strong> &#8594;</p>

  <p class="fragment">It&#39;s for creating TCP/IP servers and clients.</p>

  <p><strong>What are the objects that we used when creating a server?</strong> &#8594;</p>

  <ul>
    <li class="fragment">a <em>Server</em> object (of course!) &#8230; which binds to a hostname and port, and accepts connections and data from clients</li>
    <li class="fragment">a <em>Socket</em> object &#8230; that allows reading and writing data to a specific connection</li>
  </ul>

</section>

<section>
  <h2 id="creating-a-server">Creating a Server</h2>

  <p>So, how do we <strong>create a server?</strong> &#8594;</p>

  <ul>
    <li class="fragment">easy - just call createServer!!!!</li>
    <li class="fragment"><code class="highlighter-rouge">createServer</code> gets a callback function, though&#8230; <strong>what is this callback for?</strong> &#8594;</li>
    <li class="fragment">it&#39;s the function that&#39;s called when a client connects to the server&#8230; the callback gets a socket passed to it as an argument&#8230; which can be used to read and write data to the client</li>
    <li class="fragment">here&#39;s a simple example:</li>
  </ul>

  <pre class="fragment"><code data-trim="" contenteditable="">
const net = require('net');
const server = net.createServer(function(sock) {
    console.log('Got connection from (addr, port):', sock.remoteAddress, sock.remotePort); 
});
server.listen(8080, '127.0.0.1');
</code></pre>

</section>

<section>
  <h2 id="the-socket-object">The Socket Object</h2>

  <p><strong>On every connection:</strong> &#8594;</p>

  <ul>
    <li>the callback passed to <code class="highlighter-rouge">createServer</code> gets called with an instance a <code class="highlighter-rouge">Socket</code> object</li>
    <li>you can think of that socket object <em>as our interface to the connection</em> to the client</li>
    <li><strong>what can the socket object do?</strong> &#8594;
      <ul>
        <li class="fragment">respond to <code class="highlighter-rouge">data</code> events (that is, read data&#8230;)</li>
        <li class="fragment">respond to <code class="highlighter-rouge">close</code> events (listen for a closed connection)</li>
        <li class="fragment"><code class="highlighter-rouge">write</code> data to the client</li>
      </ul>
    </li>
    <li class="fragment">note that events work by calling <code class="highlighter-rouge">on</code> and sending it a callback that determines what to do on that event</li>
  </ul>
</section>

<section>
  <h2 id="an-echo-server-example">An Echo Server Example</h2>

  <p>The classic <em>hello world</em> for network programming is an <strong>echo server</strong>. <strong>Here&#39;s our version</strong>. &#8594;</p>

  <pre><code data-trim="" contenteditable=""> sock.on('data', function(binaryData) {
    console.log('got data\n=====\n' + binaryData); 
    sock.write(binaryData);

    // uncomment me if you want the connection to close
    // immediately after we send back data
    // sock.end();
});
</code></pre>
</section>

<section>
  <h2 id="echo-server--web-server">Echo Server &#8594; Web Server</h2>

  <p>So&#8230; if we try pointing our browser to our echo server, not much happens. <strong>Our server doesn&#39;t &quot;speak HTTP&quot; yet</strong>. 
<strong>What do we have to do if we want to turn our echo server into a web server that responds to different paths by sending back html documents?</strong> &#8594;</p>

  <ul>
    <li class="fragment">treat the incoming data as http, and parse out the path</li>
    <li class="fragment">send back valid http responses with an html document as the body</li>
  </ul>

</section>

<section>
  <h2 id="web-server---setup">Web Server - Setup</h2>

  <p>Aaand&#8230; we did just that! During our live coding demo, <strong>we came up with this code</strong>&#8230; &#8594;</p>

  <p>First, some setup:</p>

  <pre><code data-trim="" contenteditable="">
const net = require('net');

// Request object goes here...

const server = net.createServer(function(sock) {
    // "routing" goes here
});
server.listen(8080, '127.0.0.1');
</code></pre>
</section>

<section>
  <h2 id="web-server---request-object">Web Server - Request Object</h2>

  <p><strong>Then, a <code class="highlighter-rouge">Request</code> object to parse out the path:</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
class Request {
    constructor(s) {
        const requestParts = s.split(' ');
        const path = requestParts[1];
        this.path = path;
    }
}
</code></pre>
</section>

<section>
  <h2 id="web-server---routing--content">Web Server - Routing / Content</h2>

  <p><strong>Now let&#39;s do routing and serving content all in one shot!</strong> &#8594;</p>

  <p>On connection &#8230;</p>
  <pre><code data-trim="" contenteditable="">
    console.log('connected', sock.remoteAddress, sock.remotePort);
    sock.on('data', (binaryData) =&gt; {
        const reqString = '' + binaryData; 
        const req = new Request(reqString);
        if(req.path === '/about') {
            sock.write('HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n<h2>hello</h2>');
        } else  if(req.path === '/test') {
            sock.write('HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n<h2>test</h2>');
        }         
        sock.end();
    });
</code></pre>
</section>

:ET