I"§E<section class="intro-slide">
  <h1 id="functions-closures-optional-arguments">Functions (Closures, Optional Arguments)</h1>

  <h3 id="csci-ua0480">CSCI-UA.0480</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="topics">Topics</h2>

  <ul>
    <li>Review hoisting</li>
    <li>Optional Arguments</li>
    <li>Closures</li>
  </ul>

</section>

<section>
  <h2 id="a-quick-review-on-hoisting">A Quick Review on Hoisting</h2>

  <p><strong>What&#39;s hoisting?</strong> &#8594;</p>

  <ul>
    <li class="fragment"><strong>hoisting</strong> is the processing of <em>declarations</em> before any code is executed.</li>
    <li class="fragment">what&#39;s a <strong>declaration</strong>?</li>
    <li class="fragment">a <strong>declaration</strong> is a way of telling the interpreter (or compiler) that a name or identifier exists</li>
    <li class="fragment">Soooo&#8230; <strong>Hoisting</strong> basically brings declarations to the <strong>top of the current scope</strong></li>
    <li class="fragment">which means declarations do not have to occur before they are used depending on how you declare identifiers!</li>
  </ul>
</section>

<section>
  <h2 id="hoisting-continued">Hoisting Continued?</h2>

  <p><strong>What are some hoisting rules?</strong> &#8594;</p>

  <ul>
    <li class="fragment"><code class="highlighter-rouge">let</code> and <code class="highlighter-rouge">const</code> declarations are <em>sort of hoisted</em> (their names are created, but they can&#39;t be used until they&#39;re actually declared)</li>
    <li class="fragment"><code class="highlighter-rouge">var</code> declarations are brought to the top of the scope</li>
    <li class="fragment">assignment / initialization is not hoisted (it happens at the original location of that line, so these <code class="highlighter-rouge">var</code> variables are <code class="highlighter-rouge">undefined</code>)</li>
    <li class="fragment">function declarations are hoisted (including their definition)</li>
  </ul>

</section>

<section>
  <h2 id="whats-the-output">What&#39;s the Output?</h2>

  <p><strong>What is the output of the following code? Error or no output are possible.</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
console.log(x);
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
ReferenceError: x is not defined
</code></pre>

  <p class="fragment">(x wasn&#39;t declared yet)</p>

</section>

<section>
  <h2 id="whats-the-output-1">What&#39;s the Output?</h2>

  <p><strong>What is the output of the following code? Error or no output are possible.</strong> &#8594;</p>
  <pre><code data-trim="" contenteditable="">
let x;
console.log(x);
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
undefined
</code></pre>

  <p class="fragment"><code class="highlighter-rouge">let</code> variables are initialized to <code class="highlighter-rouge">undefined</code></p>

  <pre><code data-trim="" contenteditable="">
console.log(x);
let x;
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
ReferenceError
</code></pre>

  <p class="fragment">Temporal Dead Zone - can&#39;t access <code class="highlighter-rouge">let</code> variable before actual declaration</p>

  <pre><code data-trim="" contenteditable="">
console.log(x);
var x;
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
undefined
</code></pre>

  <p class="fragment">the <code class="highlighter-rouge">var</code> declaration for x is hoisted</p>

</section>

<section>
  <h2 id="whats-the-output-2">What&#39;s the Output?</h2>

  <p><strong>What is the output of the following code? Error or no output are possible.</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
f(5); 
var f = function(x) {
	console.log(x);
}
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
TypeError: undefined is not a function
</code></pre>

  <p class="fragment">variable declaration is hoisted, but the initialization of its value is not&#8230;. the value, <code>undefined</code> is being used as a function!?</p>

</section>

<section>
  <h2 id="whats-the-output-3">What&#39;s the Output?</h2>

  <p><strong>What is the output of the following code? Error or no output are possible.</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
f(5); 
function f(x) {
	console.log(x);
}
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
5
</code></pre>

  <p class="fragment">when using function declaration syntax, both declaration and <em>actual definition</em> of function are hoisted</p>

</section>

<section>
  <h2 id="about-var">About <code class="highlighter-rouge">var</code></h2>

  <p>A quick summary on <strong>using var</strong> &#8594;</p>

  <ul>
    <li>if you drop <code class="highlighter-rouge">var</code> (and don&#39;t have a <code class="highlighter-rouge">const</code> or <code class="highlighter-rouge">let</code> either), the declaration is not hoisted</li>
    <li>if you&#39;re in a function then <code class="highlighter-rouge">var</code> will create a local variable &#8230; and the scope of it will be that function</li>
    <li>within a function, but without <code class="highlighter-rouge">const</code>, <code class="highlighter-rouge">let</code> or <code class="highlighter-rouge">var</code>, <strong>the interpreter will look up the scope chain until it finds that variable or hits the global scope (at which point it will create it)</strong></li>
  </ul>
</section>

<section>
  <h2 id="aaaand-back-to-using--not-using-const-let-or-var">Aaaand&#8230; Back to Using / Not Using <code class="highlighter-rouge">const</code>, <code class="highlighter-rouge">let</code> or <code class="highlighter-rouge">var</code></h2>

  <p><strong>What&#39;s the output of this code?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
let g = 7;

function f() {
	g = 5;
}
f();
console.log(g);
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
// the variable, g, within the function, f...
// changes the global variable, g
5
</code></pre>

</section>

<section>
  <h2 id="a-tricky-one">A Tricky One&#8230;</h2>

  <p><strong>What&#39;s the output of this code?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
let g = 7;
function f() {
    g = 5;
    function g() {}
}
f();
console.log(g);
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
7 (!?)
</code></pre>

  <ul>
    <li class="fragment">function g is hoisted and is local to function f</li>
    <li class="fragment">g = 5 reassigns the local variable g!</li>
  </ul>

</section>

<section>
  <h2 id="and-from-the-previous-slides">And From the Previous Slides</h2>

  <p>This illustrates going up the scope chain&#8230; <strong>what&#39;s the output?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
let x = 10;
function f() {
  function g() {
    x = 20; 
  }
  g(); 
}
console.log(x);
f();
console.log(x);
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
10 // global
20 // nearest x is global, so global is changed by x = 20
</code></pre>

</section>

<section>
  <h2 id="scope-chain-continued">Scope Chain Continued</h2>

  <p>A minor change in code&#8230;. (declaring a local in f). <strong>What&#39;s the output this time?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
let x = 10;
function f() {
  let x = 30;
  function g() {
    x = 20; 
  }
  g(); 
}
f();
console.log(x);
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
// nearest x is in f, so global x is not changed
10
</code></pre>

</section>

<section>
  <h2 id="optional-arguments">Optional Arguments</h2>

  <p>You can pass as many or as few arguments to functions as you like!</p>

  <p class="fragment"><strong>Wait&#8230; what!?</strong> &#8594;</p>

  <ul class="fragment">
    <li>if there are <strong>aren&#39;t enough</strong> arguments, the remaining parameters are <code>undefined</code></li>
    <li>if there are <strong>too many</strong> arguments passed in, they&#39;re ignored</li>
    <li>there&#39;s also an <code>arguments</code> variable added to the function&#39;s context (along with a this variable) &#8230; maybe we&#39;ll check these out later</li>
  </ul>

  <p class="fragment"><br />
<strong>Let&#39;s check this out</strong> &#8594;</p>
</section>

<section>
  <h2 id="optional-arguments-continued">Optional Arguments Continued</h2>

  <p><strong>Given the following function&#8230;</strong></p>

  <pre><code data-trim="" contenteditable="">
function f(a, b) {
	console.log(a, b);
}
</code></pre>

  <p><strong>What is output of this function if called with the following arguments?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
f(1, 2);
f(1);
f();
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
1 2
1 undefined
undefined undefined
</code></pre>

</section>

<section>
  <h2 id="rest-parameters">Rest Parameters</h2>

  <p><strong>Using the following syntax for rest parameters</strong> &#8230; you can create functions that <strong>have an indefinite number of arguments represented as a real Array</strong> mixed in with initial positional arguments &#8594;</p>

  <pre><code data-trim="" contenteditable="">
function hiEveryone(greeting, ...names) {
    console.log(greeting);
    console.log(names);
}
hiEveryone('Hello', 'Alice', 'Bob', 'Carol')
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
Hello
[ 'Alice', 'Bob', 'Carol' ]
</code></pre>

  <p class="fragment"><code class="highlighter-rouge">names</code> is an actual <code class="highlighter-rouge">Array</code>, so you can use <code class="highlighter-rouge">Array</code> methods on it (unlike the <code class="highlighter-rouge">arguments</code> object, which is a <em>fake</em> Array-like object)</p>

</section>

<section>
  <h2 id="arguments-object">Arguments Object</h2>

  <p>When a function is called, it gets an <strong>arguments</strong> object in its context, along with its defined parameters (and <strong>this</strong>, but we&#39;ll talk about that later). <strong>Let&#39;s see this in action.</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const f = function() {
    console.log("number of args " + arguments.length);
    for (let i = 0, j = arguments.length; i &lt; j; i++) {
        console.log(arguments[i]);
    }
};
f(1, 2, 3);
</code></pre>
</section>

<section>
  <h2 id="arguments-object-continued">Arguments Object Continued</h2>

  <p>The arguments object is array-like, but not an array. (<strong>Let&#39;s see.</strong> &#8594;)</p>

  <ul>
    <li>you can index into it</li>
    <li>you can get it&#39;s length</li>
    <li>you can loop over it (with a <em>regular</em> <code>for</code> loop)</li>
    <li>no methods, though (no <code>slice</code>, <code>pop</code>, <code>forEach</code>, etc.)</li>
  </ul>

</section>

<section>
  <h2 id="using-the-arguments-object">Using the Arguments Object</h2>

  <p>Create a function called <code>mySum</code> that takes an arbitrary number of numbers as separate arguments and returns the sum of all of the arguments</p>

  <pre><code data-trim="" contenteditable="">
console.log(mySum(1, 2, 3)); // --&gt; 6
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
var mySum = function() {
	var total = 0;
	for(var i = 0; i &lt; arguments.length; i++) {
		total += arguments[i];
	}
	return total;
}
</code></pre>

</section>

<section>
  <h2 id="arguments-vs-rest-parameters">Arguments vs Rest Parameters</h2>

  <p>Both <strong><code class="highlighter-rouge">arguments</code></strong> and <strong>rest parameters</strong> allow for an arbitrary number of arguments. <strong>Which should be used?</strong> &amp;arr;</p>

  <ol>
    <li class="fragment">prefer using rest parameters</li>
    <li class="fragment">you get access to a <em>real</em> <code class="highlighter-rouge">Array</code></li>
    <li class="fragment">you can name the resulting <code class="highlighter-rouge">Array</code></li>
    <li class="fragment">however, rest parameters are only available as of ES6</li>
  </ol>

</section>

<section>
  <h2 id="default-values">Default Values</h2>

  <p><strong>What operator could we use to give parameters default values if they&#39;re not passed in?</strong> &#8594;</p>

  <p>For example, how would we create a function called <code>greetTheWorld</code></p>

  <ul>
    <li>has one parameter, <code>greeting</code></li>
    <li>prints out the <code>greeting</code>, followed by <code>"world"</code></li>
    <li><code>greetTheWorld("Hi")</code> &#8594; <code>Hi world!</code></li>
    <li>however, if an argument is not passed in, greeting should default to <code>"Hello"</code></li>
    <li><code>greetTheWorld()</code> &#8594; <code>Hello world!</code></li>
  </ul>

  <p><br />
<strong>Let&#39;s see an implementation in the next slide.</strong> &#8594;</p>
</section>

<section>
  <h2 id="default-values-continued">Default Values Continued</h2>

  <p>We can use the <code class="highlighter-rouge">||</code> operator to give a default value if the value on the left is <em>false-y</em>:</p>

  <pre><code data-trim="" contenteditable="">
function greetTheWorld(greeting) {
	console.log((greeting || "Hello") + " world!");
}
</code></pre>

</section>

<section>
  <h2 id="default-values-in-es6">Default Values in ES6</h2>

  <p><strong>You can also add default values directly in the function header in ES6</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
function f(x=1) {
    console.log(x);
}
f(); // no args, result is 1!
</code></pre>

  <p class="fragment"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters">See more examples at mdn</a></p>

</section>

<section>
  <h2 id="default-parameter-value-details">Default Parameter Value Details</h2>

  <p>These values are <strong>evaluated at call time, so a new object is created each time</strong> (that way, changes won&#39;t be persisted across function calls for default arguments that are  mutable) &#8594;</p>
  <pre class="fragment"><code data-trim="" contenteditable="">
function extraSauce(condiments = []) {
	condiments.push('ketchup');
	console.log(condiments);
}
extraSauce() // ['ketchup']
extraSauce() // still just ['ketchup']
</code></pre>

  <p class="fragment">You can even <strong>reference other parameters in your expression</strong>!</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function foo(a = 1, b = (2 * a)) {
	console.log(a, b);
}
foo();  // 1 2
foo(7); // 7 14
</code></pre>

</section>

<section>
  <h2 id="more-default-parameter-value-details">More Default Parameter Value Details!</h2>

  <p><strong>Parameters with default values can be anywhere in parameter list</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function foo(a, b = 'it me!', c) {
	console.log(a, b, c);
}
foo(1, 2, 3)  // 1 2 3
foo(1)        // 1 'it me!' undefined
</code></pre>

  <p class="fragment">The value, <code class="highlighter-rouge">undefined</code>, is what actually triggers the default value</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
foo(1, undefined, 3)  // 1 it me! 3
</code></pre>

</section>

<section>
  <h2 id="closure">Closure</h2>

  <p>Functions retain access to their original scope, even when the outer function they were defined in has returned. <strong>What happens here?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">

let gimmeFunction = function() {

	let a = "I'm in here!";

	return function() {
		console.log(a);
	}
}

let myFunction = gimmeFunction();
myFunction();
</code></pre>

  <p class="fragment">I&#39;m in here!</p>

</section>

<section>
  <h2 id="wait-what-happened">Wait. What Happened?</h2>

  <p>(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">Via MDN</a>)&#8230;</p>

  <ul>
    <li>normally, the local variables within a function only exist for the duration of that function&#39;s execution</li>
    <li>once the outer function <code>gimmeFunction</code> finishes executing, you&#39;d expect that its local letiable, a, would no longer be accessible</li>
    <li>however&#8230; a <strong>closure</strong> is created when it returns a function!</li>
    <li>a <strong>closure</strong> is a special kind of <strong>object that combines two things</strong>:
      <ul>
        <li>a function</li>
        <li>the environment in which that function was created</li>
        <li>the environment consists of any local letiables that were in-scope at the time that the closure was created</li>
      </ul>
    </li>
  </ul>

</section>

<section>
  <h2 id="makeadder">MakeAdder</h2>

  <p><strong>Try writing a function called <code class="highlighter-rouge">makeAdder</code>:</strong> &#8594;</p>

  <ul>
    <li>it should take a single argument, a number</li>
    <li>it should return a new function
      <ul>
        <li>&#8230; that also takes one argument</li>
        <li>but returns that argument with the argument from the outer function added to it</li>
      </ul>
    </li>
  </ul>

  <p><br />
It should look like this:</p>

  <pre><code data-trim="" contenteditable="">
let addTwo = makeAdder(2);
console.log(addTwo(5));
// should print out 7
</code></pre>
</section>

<section>
  <h2 id="makeadder-continued">MakeAdder Continued</h2>

  <p><strong>Here&#39;s a possible solution:</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">

let makeAdder = function(x) {
	return function(y) {
		return y + x;
	}
};

let addTwo = makeAdder(2);
console.log(addTwo(5));
</code></pre>
</section>

:ET