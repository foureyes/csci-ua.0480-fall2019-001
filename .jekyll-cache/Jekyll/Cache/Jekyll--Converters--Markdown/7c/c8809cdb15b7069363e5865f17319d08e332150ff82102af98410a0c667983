I"U¼<section class="intro-slide">
  <h1 id="values-types-operators-and-type-coercion">Values, Types, Operators and Type Coercion</h1>

  <h3 id="csci-ua0480">CSCI-UA.0480</h3>

  <p><small> 
</small></p>
</section>

<section>
  <h2 id="all-types-all-the-time">All Types All the Time</h2>

  <p>In this set of slides, <strong>we&#39;ll take a look at</strong>:</p>

  <ol>
    <li class="fragment">JavaScript&#39;s types</li>
    <li class="fragment"><code class="highlighter-rouge">Numbers</code> and numeric operators</li>
    <li class="fragment"><code class="highlighter-rouge">Strings</code> and string operators</li>
    <li class="fragment"><code class="highlighter-rouge">Booleans</code> and logical and comparison operators</li>
    <li class="fragment"><code class="highlighter-rouge">undefined</code> and <code class="highlighter-rouge">null</code></li>
  </ol>
</section>

<section>
  <h2 id="some-definitions">Some Definitions</h2>

  <ul>
    <li><strong>value</strong> <span class="fragment"> - data</span></li>
    <li><strong>type</strong> <span class="fragment"> - a category or classification of values</span></li>
    <li><strong>operator</strong> <span class="fragment"> - a language construct that allows the manipulation or combination of a value or values to yield another value</span></li>
    <li><strong>operand</strong> <span class="fragment"> - a value that an operator works on; the subject of an operator</span></li>
    <li><strong>unary operator</strong> <span class="fragment"> - an operator that only has one operand</span></li>
    <li><strong>binary operator</strong> <span class="fragment"> - an operator that has two operands</span></li>
    <li><strong>prefix operator</strong> <span class="fragment"> - an operator that goes before (to the left) of its operand(s)</span></li>
    <li><strong>infix operator</strong> <span class="fragment"> - an operator that goes between its operands</span></li>
  </ul>
</section>

<section>
  <h2 id="lets-start-off-with-comments">Let&#39;s Start off with Comments</h2>

  <p><strong>Yup</strong> Similar to comments in C or Java&#8230;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
// a comment

/*
a multiline
comment
*/
</code></pre>
</section>

<section>
  <h2 id="values">Values</h2>

  <ul>
    <li><strong>What&#39;s a value?</strong> &#8594;
      <ul class="fragment">
        <li><strong>values</strong> are just data</li>
        <li>they&#39;re <em>pieces of information</em>.</li>
      </ul>
    </li>
    <li class="fragment">Some examples of <strong>literal values</strong> in JavaScript:</li>
  </ul>
  <pre class="fragment"><code data-trim="" contenteditable="">
317.0
"oh, hello"
true
{'name': 'Joe'}
function() {console.log("in here!")}
undefined
</code></pre>
</section>

<section>
  <h2 id="types-of-values">Types of Values</h2>

  <p><strong>Based on the values in the previous slides, guess what types JavaScript supports?</strong> &#8594;</p>

  <ol class="fragment">
    <li>number</li>
    <li>string</li>
    <li>boolean</li>
    <li>object</li>
    <li>function</li>
    <li>undefined</li>
  </ol>

  <p class="fragment"><br />
Actually&#8230; these are the types that the <code>typeof</code> operator returns&#8230; <strong>the specs specify something different</strong> (we&#39;ll see in a minute)</p>
</section>

<section>
  <h2 id="typeof">typeof</h2>

  <p>Before we delve into these data types, let&#39;s check out a <strong>unary</strong>, <strong>prefix</strong> <strong>operator</strong>:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
typeof
</code></pre>

  <p class="fragment">As you might expect, <code>typeof</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof">returns a string that represents the operand&#39;s type</a>:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
&gt; typeof 317.0
'number'
</code></pre>

  <p class="fragment">We&#39;ll be using <code>typeof</code> extensively for the next few slides&#8230;.</p>
</section>

<section>
  <h2 id="btw-types-according-to-the-specification">BTW&#8230; Types According to the Specification</h2>

  <p><a href="http://www.ecma-international.org/ecma-262/#sec-ecmascript-data-types-and-values">The ECMAScript specification lists some types, but they&#39;re not the ones that typeof returns</a> (of course!)</p>

  <ul>
    <li><code>Undefined</code></li>
    <li><code>Null</code></li>
    <li><code>Boolean</code></li>
    <li><code>String</code></li>
    <li><code>Number</code></li>
    <li><code>Object</code></li>
    <li><code>Symbol</code> (ES6)</li>
  </ul>

  <p><br />
Wait&#8230; what? Then what&#39;s <code>typeof</code> doing?</p>

</section>

<section>
  <h2 id="what-does-typeof-do">What Does <code class="highlighter-rouge">typeof</code> Do?</h2>

  <p>Weelllll&#8230;. it behaves <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.4.3">exactly according to what&#39;s specified</a>:</p>

  <ul>
    <li><code>typeof undefined  &rarr; "undefined"</code></li>
    <li><code>typeof null  &rarr; "object"</code> ???</li>
    <li><code>typeof false  &rarr; "boolean"</code></li>
    <li><code>typeof 5  &rarr; "number"</code></li>
    <li><code>typeof 'foo'  &rarr; "string"</code></li>
    <li><code>typeof console.log  &rarr; "function"</code></li>
    <li><code>typeof [1, 2, 3, 4]  &rarr; "object"</code> ???</li>
  </ul>

  <p><br />
Seems like <code>null</code> is an object (!? &#8230; <a href="http://javascript.crockford.com/survey.html">a mistake?</a>). <code>Array</code> is also listed as a generic object. Â¯\<em>(ãƒ„)</em>/Â¯.</p>

</section>

<section>
  <h2 id="tell-me-about-the-types">TELL ME ABOUT THE TYPES!</h2>

  <h3 id="seriously-stop-messing-around-types-really">Seriously, stop messing around. Types Really:</h3>

  <ul>
    <li><strong>Undefined</strong> - <code class="highlighter-rouge">typeof</code> returns <code class="highlighter-rouge">undefined</code></li>
    <li><strong>Null</strong> - <code class="highlighter-rouge">typeof</code> returns <code class="highlighter-rouge">object</code> because JavaScript is <em>terrible</em> (<a href="http://stackoverflow.com/questions/18808226/why-is-typeof-null-object">or to maintain backwards compatibility with previous versions of JavaScript</a>)</li>
    <li><strong>Boolean</strong> - <code class="highlighter-rouge">typeof</code> returns <code class="highlighter-rouge">boolean</code></li>
    <li><strong>String</strong> - <code class="highlighter-rouge">typeof</code> returns <code class="highlighter-rouge">string</code></li>
    <li><strong>Number</strong> - <code class="highlighter-rouge">typeof</code> returns <code class="highlighter-rouge">number</code></li>
    <li><strong>Object</strong> - <code class="highlighter-rouge">typeof</code> returns <code class="highlighter-rouge">object</code></li>
    <li><strong>Symbol</strong> - <code class="highlighter-rouge">typeof</code> returns <code class="highlighter-rouge">symbol</code></li>
  </ul>

  <p><br />
Functions are actually just objects, but <code class="highlighter-rouge">typeof</code> gives back <code class="highlighter-rouge">function</code> when its operand is a function. Arrays are objects too, so <code class="highlighter-rouge">typeof</code> returns <code class="highlighter-rouge">object</code> for an Array.</p>

</section>

<section>
  <h2 id="primitives-vs-objects">Primitives vs Objects</h2>

  <p><strong>Hey&#8230; those two terms should sound familiar&#8230;</strong> &#8594;</p>

  <ul>
    <li class="fragment">booleans, numbers, strings, <code class="highlighter-rouge">null</code> and <code class="highlighter-rouge">undefined</code> are <strong>primitive values</strong>:
      <ul>
        <li>they&#39;re immutable</li>
        <li>they&#39;re compared by value</li>
        <li>note that wrapper objects for primitives <em>do exist</em> (we&#39;ll see this later)</li>
      </ul>
    </li>
    <li class="fragment"><strong>objects</strong>, on the other hand:
      <ul>
        <li>are compared by reference</li>
      </ul>
      <pre><code data-trim="" contenteditable="">
console.log({} === {}) // false!
const foo = {};
const bar = foo;
console.log(foo === bar); // true (because "aliasing")
</code></pre>
      <ul>
        <li>are mutable (by default, though they can be made immutable-ish)</li>
      </ul>
    </li>
  </ul>

</section>

<section>
  <h2 id="numbers">Numbers</h2>

  <ul>
    <li>unsurpsingly, numbers are just <em>numbers</em>
      <ul>
        <li><strong>all numbers in Javascript are 64bit (8 bytes) floating point numbers</strong></li>
        <li>JavaScript does not distinguish between ints, floats, longs, doubles, etc.</li>
      </ul>
    </li>
    <li>numbers represent&#8230;
      <ul>
        <li>positive and negative whole numbers: 23, 42, -10</li>
        <li>floating point numbers (with a dot): 2.3, 4.2</li>
      </ul>
    </li>
    <li><strong>number literals consist of digits, an optional decimal point, and an optional exponent</strong> &#8594;</li>
  </ul>
  <pre><code data-trim="" contenteditable="">
123 // an integer - just digits
12.3 // a floating point number - decimal point
12e3 // (12 times 10 to the 3rd) exponent
</code></pre>
</section>

<section>
  <h2 id="more-about-numbers">More About Numbers</h2>

  <ul>
    <li><strong>So how many values can 64 bits hold?</strong> (Um&#8230; a lot?) &#8594;</li>
    <li class="fragment">2 to the power of 64!  About 18 with 18 0&#39;s after it. <strong>However, this doesn&#39;t exactly indicate what numbers can be stored. Why?</strong> &#8594;</li>
    <li class="fragment">This just means that number of possible values.  This has to include negative numbers, decimals, etc&#8230;
      <ul class="fragment">
        <li><strong>52 bits</strong> for the value (<a href="http://www.2ality.com/2012/04/number-encoding.html">er really</a> <a href="http://www.jibbering.com/faq/#FAQ4_7">53</a> &#8230; because of the sign)</li>
        <li>used to represent both integers and real numbers</li>
        <li><strong>11 bits</strong> for the exponent (for placing the decimal point)</li>
        <li><strong>1 bit</strong> for the sign</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="and-why-does-that-matter">And Why Does That Matter?</h2>

  <ul>
    <li><strong>integers</strong> are considered to be reliable up to about 15~16 digits &#8594;</li>
  </ul>
  <pre><code data-trim="" contenteditable="">
&gt; Math.pow(2,53)
&gt; 9007199254740992
9007199254740992
&gt; 9007199254740993
9007199254740992
</code></pre>
  <ul>
    <li>for <strong>floating point numbers</strong> (<a href="http://floating-point-gui.de/">which are <em>difficult</em> to represent!</a>)
      <ul>
        <li>if you need precise floating point / decimal point behavior, use a special data type, like <a href="https://github.com/dtrebbien/BigDecimal.js">BigDecimal</a>, otherwise <code>0.1 + 0.2 // ????</code>&#8594;</li>
        <li>use rounding and number formatting if you&#39;re just concerned about display - maybe <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision">toPrecision</a></li>
        <li>use integers!</li>
      </ul>
    </li>
    <li>apparently, <a href="http://www.hunlock.com/blogs/The_Complete_Javascript_Number_Reference">floating point numbers</a> are <a href="http://stackoverflow.com/questions/1458633/elegant-workaround-for-javascript-floating-point-number-problem">tricky</a></li>
  </ul>
</section>

<section data-background="#440000">
  <h2 id="floating-point-operations-may-yield-unexpected-results">Floating Point Operations May Yield Unexpected Results!</h2>

  <ul>
    <li>sooo&#8230; you may have to be careful when comparing them!</li>
    <li class="fragment">for example, if checking two floating point numbers for equality
      <ul>
        <li>perhaps take the absolute value of the difference of the values and determine if that&#39;s below some threshold</li>
        <li>if it is, then the floating point numbers are <em>equal</em></li>
      </ul>
    </li>
    <li class="fragment">this threshold is the <a href="http://stackoverflow.com/questions/34611858/machine-epsilon-in-python">machine epsilon</a>
      <ul>
        <li>The smallest representable positive number such that 1.0 + eps != 1.0</li>
        <li><code class="highlighter-rouge">0.1 + 0.2 === 0.3 // false!?</code></li>
        <li><code class="highlighter-rouge">Math.abs((0.1 + 0.2) - 0.3)  &lt; 0.0000000000000004 // true! </code></li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="operators">Operators</h2>

  <ul>
    <li>Using operators with values as operands yields values!</li>
    <li>We&#39;ve learned one operator so far&#8230; <strong>what was it?</strong> &#8594;</li>
    <li>We&#39;re familiar with some numeric operators (just because we&#39;ve seen them in other languages, and - <em>you know</em>, math) &#8230; <strong>what are they?</strong> &#8594;</li>
  </ul>
</section>

<section>
  <h2 id="numeric-operators">Numeric Operators</h2>

  <p>A quick list of <strong>binary</strong>, <strong>infix</strong> arithmetic operators (they take two operands, one on each side of the operator):</p>

  <ul>
    <li><strong>+</strong> - addition</li>
    <li><strong>-</strong> - subtraction</li>
    <li><strong>*</strong> - multiplication</li>
    <li><strong>/</strong> - division</li>
    <li><strong>%</strong> - modulo (remainder)</li>
    <li class="fragment"><strong>**</strong> for exponentiation works too if your js engine supports ES7</li>
    <li class="fragment"><strong>check out these operations in the node REPL</strong> &#8594;</li>
  </ul>
</section>

<section>
  <h2 id="numeric-operators-precedence">Numeric Operators, Precedence</h2>

  <p><strong>What order would I evaluate this in?  What is the resulting value?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
4 + 1 * 5
</code></pre>

  <ul class="fragment">
    <li>remember <em>PEMDAS</em>? (modulo is the same precedence as multiplication)</li>
    <li>multiplication first</li>
    <li>then addition</li>
    <li>result is 9</li>
    <li>you can find more about <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">operator precedence here</a></li>
  </ul>

</section>

<section>
  <h2 id="use-parentheses-liberally">Use Parentheses Liberally</h2>

  <ul>
    <li>parentheses allow grouping</li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Grouping">grouping operation</a> has highest precedence (always goes first)</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
// force addition first
(4 + 1) * 5
</code></pre>
</section>

<section>
  <h2 id="more-number-operators">More Number Operators</h2>

  <p>A couple more operators - these are <strong>prefix</strong>, <strong>unary</strong> operators that yield numbers:</p>

  <ul>
    <li><strong>+</strong> - convert to positive number</li>
    <li><strong>-</strong> - convert to negative number</li>
    <li><strong>let&#39;s try them out</strong> &#8594;</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
+12
-12
-"12"
+"12"
-true
</code></pre>

  <p class="fragment">Note that they work on non-number types as well! <strong>These operators can be used to convert strings to numbers.</strong></p>
</section>

<section>
  <h2 id="bitwise-operators">Bitwise Operators</h2>

  <p><strong>What do you think the following operators do?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
2 &amp; 3 // 10 &amp; 11 = 10 = 2
7 ^ 3 // 111 ^ 011 = 100 = 4
</code></pre>

  <ul class="fragment">
    <li><strong>bitwise AND</strong> - a <strong>&amp;</strong> b - returns a one in each bit position for which the corresponding bits of both operands are ones</li>
    <li><strong>bitwise OR</strong> - a <strong>|</strong> b - returns a one in each bit position for which the corresponding bits of either or both operands are ones</li>
    <li><strong>bitwise XOR</strong> - a <strong>^</strong> b returns a one in each bit position for which the corresponding bits of either but not both operands are ones</li>
    <li><strong>bitwise NOT</strong> - <strong>~</strong> a - inverts the bits of its operand</li>
  </ul>

  <p class="fragment"><br />Note&#8230; bitwise operators work in 32 bits (even though numbers are stored in 64)</p>

  <p class="fragment"><strong>let&#39;s try these</strong> &#8594;</p>
</section>

<section>
  <h2 id="more-bitwise-operators">More Bitwise Operators</h2>

  <p><strong>What do you think the following operators do?</strong> &#8594;</p>
  <pre><code data-trim="" contenteditable="">
2 &lt;&lt; 3 // 10 &lt;&lt; 11 = 10000 = 16
</code></pre>

  <ul class="fragment">
    <li><strong>left shift</strong> - a <strong>&lt;&lt;</strong> b - shifts a in binary representation b (&lt; 32) bits to the left, shifting in zeros from the right.</li>
    <li><strong>sign-propagating right shift</strong> - a <strong>&gt;&gt;</strong> b - shifts a in binary representation b (&lt; 32) bits to the right, discarding bits shifted off.</li>
    <li><strong>zero-fill right shift</strong> a <strong>&gt;&gt;&gt;</strong> b - shifts a in binary representation b (&lt; 32) bits to the right, discarding bits shifted off, and shifting in zeros from the left.</li>
  </ul>
</section>

<section data-background="#440000">
  <h2 id="bitwise-operators-treat-their-operands-as-a-sequence-of-32-bits">Bitwise operators treat their operands as a sequence of 32 bits!</h2>

</section>

<section>
  <h2 id="lets-try-a-few">Let&#39;s Try a Few</h2>

  <p><strong>What are the results of the following expressions?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
8 | 2 // 1000 | 0010
8 &gt;&gt; 2 // 1000 &gt;&gt; 0010

</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
10
2
</code></pre>

  <p class="fragment">(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">More details on MDN</a>)</p>

</section>

<section>
  <h2 id="some-special-numbers">Some Special Numbers&#8230;</h2>

  <p><strong>Try the following operations&#8230;</strong> &#8594;</p>
  <pre><code data-trim="" contenteditable="">
0/0
9e300 * 25874481
</code></pre>

  <ul>
    <li class="fragment">JavaScript has some special number values:
      <ul class="fragment">
        <li><strong>NaN</strong> (<em>Not a Number</em>) - this results from any numeric operation that doesn&#39;t give back a meaningful result&#8230;</li>
        <li><strong>Infinity, -Infintity</strong> - positive and negative infinities</li>
      </ul>
    </li>
    <li class="fragment">Note that these special values are <em>actually</em> numbers! (really!)
      <ul>
        <li class="fragment">that is, <strong>both <code class="highlighter-rouge">NaN</code> and Positive/Negative <code class="highlighter-rouge">Infinity</code> are of type <code class="highlighter-rouge">Number</code>!</strong> &#8594;
          <pre><code data-trim="" contenteditable="">
typeof NaN      // --&gt; number (what??? ok)
typeof Infinity // --&gt; number
</code></pre>
        </li>
      </ul>
    </li>
  </ul>

</section>

<section>
  <h2 id="more-about-nan">More About NaN</h2>

  <p>Again, <strong>NaN</strong> stands for <em>not a number</em></p>

  <ul>
    <li><code>NaN</code> is <em>toxic</em> &#8230;</li>
    <li>using it in any other numeric operations <strong>always results in NaN</strong> &#8594;
      <ul>
        <li><code>NaN + 1</code> &#8594; <code class="fragment">NaN</code></li>
      </ul>
    </li>
    <li>the only way to check if a value is <code class="highlighter-rouge">NaN</code> is by using the built-in function <code class="highlighter-rouge">isNaN(val)</code></li>
    <li>oddly, <code class="highlighter-rouge">NaN === NaN</code> is <code class="highlighter-rouge">false</code> (!? &#8230; as specified by IEEE)</li>
  </ul>

</section>
<section>
  <h2 id="more-about-infinity">More About Infinity</h2>

  <p>So, there&#39;s  <strong>Infinity</strong> and  <strong>-Infinity</strong></p>

  <ul>
    <li><strong>Infinity</strong> <code> + 1</code> or <strong>Infinity</strong> <code>+</code> <strong>Infinity</strong>&#8594; is still <code>Infinity</code></li>
    <li><code>Infinity</code> represents all values greater than 1.79769313486231570e+308</li>
    <li>dividing by 0 yields <code class="highlighter-rouge">infinity</code></li>
    <li>equality operators and the global function <code class="highlighter-rouge">isFinite</code> can be used to determine if a value is <code class="highlighter-rouge">Infinity</code></li>
  </ul>

</section>

<section>
  <h2 id="special-numeric-values-and-bitwise-operators">Special Numeric Values and Bitwise Operators</h2>

  <p><strong>For bitwise operators&#8230; <code>Nan</code>, <code>Infinity</code>, and <code>-Infinity</code> are all converted to 0</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
NaN | 2 // evaluates to 2
Infinity &amp; 10 // evaluates to 0
</code></pre>

  <p>Why? Because <a href="http://es5.github.io/#x11.10">the specs</a> <a href="http://es5.github.io/#x9.5">say so</a></p>

  <p>Also&#8230; there is definitely a binary representation for these special numbers (<code>Nan</code>, <code>Infinity</code>, and <code>-Infinity</code>)&#8230; the <a href="http://www.2ality.com/2012/04/number-encoding.html">closest I came to determining it was here</a></p>
</section>

<section>
  <h2 id="strings">Strings</h2>

  <p>A <strong>string</strong> is an ordered sequence of <a href="http://unicodesnowmanforyou.com/">Unicode</a> characters (<strong>what&#39;s Unicode?</strong> &#8594;).  You can tell that a value is a string if it is surrounded by single or double quotes:</p>

  <pre><code data-trim="" contenteditable="">
'I am a string'
"I'm a string too!"
</code></pre>

</section>

<section data-background="#440000">
  <h2 id="quoted-text-is-a-string">Quoted text is a string!</h2>
</section>

<section>
  <h2 id="strings-continued">Strings Continued</h2>

  <p>A <strong>string</strong> can be composed of <em>any</em> characters: numbers, letters, punctuation, spaces, etc.</p>

  <p>The following is a string with nothing in it&#8230; or an <em>empty string</em>:</p>

  <pre><code data-trim="" contenteditable="">
""
</code></pre>

</section>

<section>
  <h2 id="escape-characters">Escape Characters</h2>

  <p><strong>If there is a backslash in a string (\), that means:</strong></p>

  <ul>
    <li>the next character has a special meaning</li>
    <li>the initial backslash will not be printed out</li>
  </ul>

  <p><br />
For example, <strong>\n</strong> is a newline and <strong>\t</strong> is a tab</p>
  <pre><code data-trim="" contenteditable="">
"\n"
"\t" 
</code></pre>

  <p><strong>How would we put a double quote in a double quoted string?</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
"\""
</code></pre>

  <p class="fragment"><strong>And what about an <em>actual</em> backslash?</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
"\\"
</code></pre>
</section>

<section>
  <h2 id="unicode-escape-sequence">Unicode Escape Sequence</h2>

  <p><strong>You can specify characters by using their unicode code point!</strong></p>

  <ul>
    <li><strong>start with <code class="highlighter-rouge">\u</code></strong></li>
    <li>follow it with a <strong>a hexadecimal number</strong> representing a unicode code point</li>
  </ul>

  <p><br />
How does that work? Welll&#8230;. &#8594;</p>

  <ul>
    <li class="fragment"><code class="highlighter-rouge">console.log('\u0041')</code> - 65 - uppercase A</li>
    <li class="fragment">as an aside,
      <ul>
        <li><a href="http://airhadoken.github.io/2015/04/22/javascript-string-handling-emoji.html">JavaScript stores strings internally as UTF-16</a>, but the code points for emoji are outside of what UTF-16 can represent</li>
        <li>consequently, to represent those higher code points, <strong>2 consecutive UTF-16 characters can be used</strong></li>
        <li>for example, &#39;\uD83D\uDE28&#39; is a fearful face &#128552; (AKA the face I make when I see a hex number or read the word, unicode)</li>
      </ul>
    </li>
  </ul>

  <p><br /></p>

</section>

<section>
  <h2 id="string-operators">String Operators</h2>

  <p>A few string operators:</p>

  <ul>
    <li><strong>string concatenation</strong>, or <strong>+</strong>, is an operator that takes two strings and joins them:
      <pre><code data-trim="" contenteditable="">
"hello " + "there"
</code></pre>
    </li>
    <li><strong>indexing</strong>, or []&#8230; can be used to retrieve the character at an index, such as <code class="highlighter-rouge">'emoji'[3]</code> (or use <code class="highlighter-rouge">charAt</code>)</li>
    <li><strong>comparison operators</strong>, you can use <code class="highlighter-rouge">&lt;</code>, <code class="highlighter-rouge">&lt;=</code>, etc. &#8230; unicode code points are compared <code class="highlighter-rouge">'B' &gt; 'A' // true</code></li>
  </ul>
</section>

<section>
  <h2 id="template-literals-es6">Template Literals (ES6)</h2>

  <p>If you want <strong>multiline strings</strong> or <strong>string interpolation</strong>, use <strong>template literal</strong> syntax:</p>

  <ul>
    <li>use backticks to delimit your template literal (instead of quotes)</li>
    <li>use <code class="highlighter-rouge">${variableName}</code> to output the value of a variable in a string</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
const s1 = `such
lines
wow`;

const food1 = 'bacon';
const food2 = 'pancakes';
const s2 = `Makin' ${food2}, makin' ${food1} ${food2}!`;

console.log(s1)
console.log(s2);
</code></pre>
</section>

<section>
  <h2 id="booleans">Booleans</h2>

  <p>A <strong>boolean</strong> is a data type that has two possible values: <code>true</code> or <code>false</code>.</p>

  <p>As one would expect, the literals for these values are (all lowercase):</p>

  <pre><code data-trim="" contenteditable="">
true
false
</code></pre>
</section>

<section>
  <h2 id="inherent-truthiness">Inherent Truthiness</h2>

  <p><strong>When non-boolean types are converted to booleans, the followings rules are used</strong> &#8594;</p>

  <ul>
    <li><code>0</code>, <code>NaN</code>, empty string (<code>""</code>), and <code>undefined/null</code> are false</li>
    <li>other values are true-ish</li>
  </ul>

  <p><br /></p>

  <p><strong>Let&#39;s test this out&#8230;</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
// outputs "in here"
if("this string says false, but...!?") {
	console.log("in here!");
}

// no output
var myString = "";

if(myString) {
	console.log("you shouldn't see me!");
}
</code></pre>

</section>

<section>
  <h2 id="logical-operators">Logical Operators</h2>

  <p><strong>Boolean</strong> values can be combined and manipulated using logical operators.  <strong>What are some logical operators, and what do they do?</strong> &#8594;</p>

  <ul>
    <li class="fragment"><strong>and</strong> - <strong>&amp;&amp;</strong> - returns true if and only if both operands are true, otherwise, returns false</li>
    <li class="fragment"><strong>or</strong> - <strong>||</strong> - returns false if and only if both operands are false, otherwise, returns true</li>
    <li class="fragment"><strong>not</strong> - <strong>!</strong> - returns the opposite boolean value of its single operand to the right</li>
  </ul>
</section>

<section>
  <h2 id="logical-operators-continued-precedence">Logical Operators Continued, Precedence</h2>

  <p><strong>What do the following boolean expressions return?</strong></p>

  <pre class="fragment"><code data-trim="" contenteditable="">
false &amp;&amp; true
false || true
false || !true
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
false
true
false
</code></pre>

  <p class="fragment"><br /> The operator precedence for logical operators is <strong>not</strong>, <strong>and</strong>, and <strong>or</strong>.</p>

</section>

<section>
  <h2 id="and-and-or-with-non-boolean-values">And and Or With Non Boolean Values</h2>

  <p>Some details about <code>&amp;&amp;</code> and <code>||</code>:</p>

  <ul>
    <li>if operands are not actually boolean, convert the value on the left side to a boolean
      <ul>
        <li><code>||</code>
          <ul>
            <li>will return the <strong>left operand</strong>&#39;s value if it&#39;s <strong>true</strong></li>
            <li>otherwise, return the value on the right</li>
            <li>can be used as a way to fall back to a default value <code>potentially_falsey || default_value</code></li>
          </ul>
        </li>
        <li><code>&amp;&amp;</code>
          <ul>
            <li>will return the <strong>left operand</strong>&#39;s value if it&#39;s <strong>false</strong></li>
            <li>otherwise, return the value on the right</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>also&#8230; <strong>short-circuit</strong> evaluation applies</li>
  </ul>

</section>

<section>
  <h2 id="and-and-or-continued">And and Or Continued</h2>

  <p>Based on the previous slide, <strong>what are the values produced by the following expressions?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
5 - 5 || 2
5 - 5 &amp;&amp; 2
"hello" || "goodbye"
"hello" &amp;&amp;  "goodbye"
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
2
0
hello
goodbye
</code></pre>

  <p class="fragment">This syntax is actually sometimes used to <strong>assign a default value</strong> if a value doesn&#39;t exist:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
// we haven't seen objects yet, but you get the idea
const obj = {prop1: "a value"}; 
const val1 = obj.prop1 || "default value"
const val2 = obj.prop2 || "default value"
</code></pre>
</section>

<section>
  <h2 id="ternary-operator">Ternary Operator</h2>

  <p><strong>What will this code return?</strong></p>

  <pre><code data-trim="" contenteditable="">
true ? "ok" : "not ok!"
</code></pre>

  <ul>
    <li class="fragment">&quot;ok&quot;</li>
    <li class="fragment">format is <code>test</code> (boolean expression) <strong>?</strong> <code>value</code> to return if true <strong>:</strong> <code>value</code> to return if false</li>
  </ul>

  <p class="fragment"><br />
The ternary operator <strong>works like an if/else statement</strong>, but it&#39;s <strong>one line</strong> and it <strong>evaluates to a value</strong>:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
// ternary followed by equivalent if/else
let x = 5 &gt; 2 ? 'yes' : 'no';

let x;
if(5 &gt; 2) {
    x = 'yes';
} else {
    x = 'no';
}
</code></pre>

</section>
<section>
  <h2 id="comparison-operators">Comparison Operators</h2>

  <p><strong>Booleans</strong> can be produced from comparison operators. Without knowing anything about JavaScript, <strong>what do you think are some available comparison operators?</strong> &#8594;</p>

  <ul>
    <li class="fragment"><strong>&lt;</strong>, <strong>&gt;</strong>, <strong>&lt;=</strong>, <strong>&gt;=</strong> - greater than, less than, etc.</li>
    <li class="fragment"><strong>===</strong> - equals, checks both type and value</li>
    <li class="fragment"><strong>!==</strong> - not equals, checks both type and value</li>
    <li class="fragment"><strong>==</strong> - equals, coerces operands to appropriate types</li>
    <li class="fragment"><strong>!=</strong> - not equals, coerces operands</li>
  </ul>
</section>

<section>
  <h2 id="comparison-operators-continued">Comparison Operators Continued</h2>

  <p><strong>Comparison Operators</strong> are <strong>binary</strong> , <strong>infix</strong> operators that can be used to compare two operands:</p>

  <ul>
    <li><strong>numbers</strong> are obvious: <code>5 &gt; 2</code> &#8594;</li>
    <li><strong>strings</strong> are compared from left to right (by character code): <code>"aardvark" &gt; "bison"</code> (more or less, <em>alphabetic</em>) &#8594;</li>
    <li><strong>NaN</strong> is the only value not equal to itself &#8594;</li>
    <li><strong>You&#39;ll probably always want to use ===</strong> &#8594;</li>
  </ul>

</section>

<section>
  <h2 id="undefined-and-null"><code class="highlighter-rouge">undefined</code> and <code class="highlighter-rouge">null</code></h2>

  <p>See the <a href="http://speakingjs.com/es5/ch08.html#undefined_null">section on undefined and null in our book</a></p>

  <ul>
    <li><strong>undefined</strong> means no value
      <ul>
        <li>think of a function that doesn&#39;t return a value</li>
        <li>or the value of a declared variable that hasn&#39;t been given a value yet</li>
        <li>or a missing argument to a function</li>
      </ul>
    </li>
    <li><strong>null</strong> means &quot;no object&quot;&#8230; it&#39;s a value that can be assigned to a variable to represent &quot;no object&quot;  &#8594;</li>
    <li>the subtle differences between <code class="highlighter-rouge">undefined</code> and <code class="highlighter-rouge">null</code> are an accident of language design!
      <ul>
        <li>you&#39;ll typically find <code class="highlighter-rouge">undefined</code> when something wasn&#39;t initialized</li>
        <li>you&#39;ll find <code class="highlighter-rouge">null</code> if an object is explicitly set to <code class="highlighter-rouge">null</code></li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="type-coercion">Type Coercion</h2>

  <p><strong>What values would you expect from the following lines of code?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
5 + 5
"5" + 5
"five" + 5
5 == "5"
5 === "5"
5 * undefined
5 * null
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
10
'55'
'five5'
true
false
NaN
0
</code></pre>

  <p><br /></p>

  <p class="fragment">How do we know? We can read the <a href="http://www.ecma-international.org/ecma-262/#sec-addition-operator-plus">ECMAScript specifications</a>!</p>
</section>

<section>
  <h2 id="type-coercion-continued">Type Coercion Continued</h2>

  <ul>
    <li><strong>JavaScript</strong> is a <strong>dynamic</strong> and <strong>weakly</strong> typed language.</li>
    <li>It often goes out of its way to make sure that operators and functions work, regardless of what types are given as operands or arguments.</li>
    <li>It will try to <strong>coerce</strong> types into other types to make operators and functions <em>work</em>.</li>
  </ul>

</section>

<section>
  <h2 id="type-coercion-with-numeric-operators">Type Coercion With Numeric Operators</h2>

  <ul>
    <li>for <strong>addition</strong>:
      <ul>
        <li>when one operand is a string and the other is not, the other operand is converted into a string, and the two strings are concatenated</li>
        <li>for all other cases, the operands are converted to numbers
          <ul>
            <li>true &#8594; 1</li>
            <li>false &#8594; 0</li>
            <li>null &#8594; 0</li>
            <li>undefined is still undefined, and result gives back <strong>NaN</strong></li>
          </ul>
        </li>
      </ul>
    </li>
    <li>for other numeric operators, such as <strong>subtraction</strong>:
      <ul>
        <li>will usually try to convert to number</li>
        <li>if something <em>cannot be converted easily</em> (like the string, &quot;hello&quot;), the result is <code>NaN</code></li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="type-coercion-with-equality-operators">Type Coercion With Equality Operators</h2>

  <ul>
    <li>JavaScript will do its best to convert types so that they can be checked for equality - <strong>these all return true</strong> &#8594;
      <ul>
        <li><code>"10" == 10</code></li>
        <li><code>0 == false</code></li>
        <li><code>"" == false</code></li>
      </ul>
    </li>
    <li>this is Usually an unwanted behavior; <strong>to avoid this, use: === and !==</strong>
      <ul>
        <li>these operators check <strong>type</strong> and <strong>value</strong></li>
        <li>use these three-character comparison operators to prevent unexpected type conversions</li>
      </ul>
    </li>
  </ul>

  <p><br />
If you want to see the <strong>details for every possible operand combination for double equals</strong>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using">check out mdn&#39;s table</a> ðŸ‘€</p>
</section>

<section data-background="#440000">
  <h2 id="use--instead-of-">Use === Instead of ==</h2>

  <h3 id="mostly">(mostly)</h3>
</section>

<section>
  <h2 id="relational--ordering-operators">Relational / Ordering Operators</h2>

  <p><strong>For relational / ordering operators like &gt;, &lt;, etc.</strong> &#8594;</p>

  <ol>
    <li>convert objects to a <em>primitive</em>: booleans, numbers, strings, null, and undefined</li>
    <li>if strings, compare lexicographically</li>
    <li>otherwise convert both to numbers</li>
    <li>NaN is compared as unordered with everything (which is why NaN === NaN is false)</li>
  </ol>
</section>
<section>
  <h2 id="back-to-unary-operators">Back to Unary Operators</h2>

  <p>What the what????</p>

  <pre><code data-trim="" contenteditable="">
+-12 
-+12
+"hello"
</code></pre>

  <p class="fragment">These expressions evaluate to&#8230;</p>
  <pre class="fragment"><code data-trim="" contenteditable="">
-12
-12
NaN
</code></pre>

  <p class="fragment">From the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_negation_(-)">docs on mdn</a>&#8230;</p>

  <ul class="fragment">
    <li>unary + &#8230; will try to convert its operand to a number (if it can&#39;t be converted to a number, then <code class="highlighter-rouge">NaN</code>)</li>
    <li>unary - &#8230; will convert its operand to negative number</li>
  </ul>

  <p class="fragment"><br />
The order of operations is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">innermost prefix operator first (right to left)</a>.</p>

</section>

<section>
  <h2 id="ugh-all-of-that-is-kind-of-crazy">Ugh All of That is Kind of Crazy</h2>

  <h3 id="a-quick-summary-of-all-of-that-automatic-conversion-business">A quick summary of all of that automatic conversion business.</h3>

  <ul>
    <li><strong>when adding values</strong>
      <ul>
        <li>if either of the values is a string, coerce the other to perform string concatenation</li>
        <li>otherwise convert both sides to numbers (if they aren&#39;t already) and perform addition</li>
      </ul>
    </li>
    <li><strong>when comparing values with &lt;</strong>
      <ul>
        <li>try to convert both sides to numbers first, so that comparison can be easily performed</li>
        <li>if either operand is NaN, the result is False</li>
      </ul>
    </li>
    <li><strong>when it doubt, check the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators">some online resources, like mdn</a></strong> (or, of course <a href="http://stackoverflow.com/questions/14687876/how-do-the-javascript-relational-comparison-operators-coerce-types">SO</a> it)</li>
  </ul>
</section>

<section>
  <h2 id="handling-automatic-type-conversion">Handling Automatic Type Conversion</h2>

  <h3 id="how-do-we-get-out-of-this-mess">How do we get out of this mess?</h3>

  <p><strong>&#8230;Without having to remember a series of obscure rules</strong> &#8594;</p>

  <ol>
    <li class="fragment">one way is to <strong>use triple equals</strong> - <code>===</code> (we&#39;ve gone over this before!)</li>
    <li class="fragment">another way is to just explicitly <em>cast</em> your operand(s) to minimize surprises</li>
  </ol>
</section>

<section>
  <h2 id="casting">Casting</h2>

  <p>We can use <strong>object contructors</strong> as functions to cast to a type:</p>

  <ul>
    <li class="fragment"><strong>use constructors</strong> (named after their corresponding type) <strong>as functions</strong> by dropping the keyword <code>new</code> to convert to that type</li>
    <li class="fragment">note that if you use <code>new</code> with your constructor (avoid!)&#8230;
      <ul>
        <li>primitive type is wrapped in an object (to be discussed later!)</li>
        <li>when asked for a value, these objects <em>usually</em> yield the value of their primitive type</li>
      </ul>
    </li>
  </ul>

  <pre class="fragment"><code data-trim="" contenteditable="">
// do this (call constructor named after type as a function)
i = Number("2")
a = Boolean(false);
// not this (not a good idea to use new!)
b = new Boolean(false);
// because
console.log(typeof a); // --&gt; boolean
console.log(typeof b); // --&gt; object
// ... and ðŸ˜’
Boolean(new Boolean(false)) // True!?
</code></pre>
</section>

<section>
  <h2 id="casting-continued">Casting Continued</h2>

  <p>Another option is to use some of the <strong>operators</strong> that we learned to coax JavaScript into doing a predictable automatic conversion for us:</p>

  <ul>
    <li><strong>convert to a boolean</strong>
      <ul>
        <li>use <em>not</em> twice (negate the not, but preserve the type conversion)</li>
        <li><code>!!"hello"</code></li>
      </ul>
    </li>
    <li><strong>convert to a number</strong>
      <ul>
        <li>use unary <code>+</code></li>
        <li>for example: <code>+"5"</code>, <code>+"hello"</code></li>
        <li>use <code class="highlighter-rouge">parseInt</code></li>
      </ul>
    </li>
    <li><strong>convert to a string</strong>
      <ul>
        <li>just add an empty string to it</li>
        <li><code>5 + ""</code></li>
      </ul>
    </li>
  </ul>

  <p><br />
For mind boggling detail, see <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch4.md">You Don&#39;t Know JS</a> on coercion.</p>
</section>

<section>
  <h2 id="checking-for-undefined">Checking for undefined</h2>

  <p>Undefined (and also null) means <strong>the absence of a <em>meaningful</em> value</strong>.</p>

  <p>How would you check if a value is <strong>undefined</strong>? <strong>The two ways to do this are</strong>: &#8594;</p>

  <ul>
    <li class="fragment">(preferred) <code>if (myVar === undefined)</code></li>
    <li class="fragment"><code>if (typeof myVar === 'undefined')</code>
      <ul>
        <li class="fragment">handles undeclared variables</li>
      </ul>
    </li>
  </ul>

</section>

<section>
  <h2 id="checking-for-nan">Checking for NaN</h2>

  <p>Use the isNaN function to determine if a value is <strong>not a number</strong>.</p>

  <p><strong>(comparing NaN to itself always yields false)</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
NaN == NaN
NaN === NaN

// false
// false
// weird, eh?
</code></pre>

  <p>Remember&#8230; NaN is not ordered with any value!. Use <code>isNaN</code>&#8230;</p>

  <pre><code data-trim="" contenteditable="">
isNaN(NaN)
</code></pre>
</section>

<section>
  <h2 id="some-style">Some Style</h2>

  <p>The previous material in this set of slides are about general best practices. Not adhering to them may:</p>

  <ul>
    <li>result in your code yielding unexpected results</li>
    <li>difficult to understand / non-standard code</li>
  </ul>

  <p><br />
<strong>The next few suggestions, however, are purely stylistic - just about how code is formatted:</strong> &#8594;</p>

  <div class="img">
    <p><img src="http://i.kinja-img.com/gawker-media/image/upload/s--ZbZrlXcj--/xnfzofkxpckzxbkqxnbq.jpg" alt="poochie" /></p>
  </div>

</section>
<section>
  <h2 id="style-continued">Style Continued</h2>

  <ul>
    <li>use 1TBS, <strong>One True Brace Style</strong>: open curly brace on same line of code as last line preceding the current block of code / statement header (not on a new line)</li>
  </ul>
  <pre><code data-trim="" contenteditable="">
if (some_boolean_expression) { // &lt;-- curly brace here!
	// do stuff
}
</code></pre>
  <ul>
    <li>use (lower) camel case to separate words in identifiers / variables names: <code>myVerboseVariableName</code></li>
    <li>remember to indent blocks of code!</li>
  </ul>
</section>

<section>
  <h2 id="summary">Summary</h2>

  <ul>
    <li><strong>automatic type conversion is tricky</strong>; sometimes it&#39;s helpful to check the specs, mdn, speaking javascript or even stackoverflow</li>
    <li>you can get around automatic type conversion (if that&#39;s desirable) by <strong>casting</strong>
      <ul>
        <li>use object constructors as functions (<code class="highlighter-rouge">Number</code>, <code class="highlighter-rouge">Boolean</code>, etc.)</li>
        <li>use operators like <code>!!</code>, <code>+</code>, <code>+ ""</code></li>
      </ul>
    </li>
    <li>to <strong>check for undefined</strong>: <code>if(typeof myVar == 'undefined')</code></li>
    <li>to <strong>check for NaN</strong>: <code>isNan(myVar)</code></li>
  </ul>
</section>

<section>
  <h2 id="order-of-operations">Order of Operations</h2>

  <p>All of those operators! What goes first again!?  (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">Check out operators precedence here.</a>)</p>

  <p>A quick summary:</p>

  <ul>
    <li><strong>parentheses</strong></li>
    <li><strong>unary operators</strong> like logical NOT, typeof and negative</li>
    <li>the rest of l<strong>PEMDAS</strong> (number, string operators) - left to right if same precedence</li>
    <li><strong>bitwise shift</strong> operators</li>
    <li><strong>comparison operators</strong> - left to right</li>
    <li><strong>equality operators</strong> - left to right</li>
    <li><strong>remaining logical operators</strong> - and, or - left to right</li>
    <li><strong>other bitwise operators</strong> - bitwise and, bitwise or - left to right</li>
  </ul>

  <p><br /></p>
</section>

<section>
  <h2 id="and-a-quick-review-on-types">And&#8230; a Quick Review on Types</h2>

  <p><strong>Name 6 types (as given by typeof) that we know in JavaScript and a literal example of each.</strong> &#8594;</p>

  <ul class="fragment">
    <li>number - <code>317</code></li>
    <li>string - <code>"yup, a string"</code></li>
    <li>boolean - <code>true</code></li>
    <li>function - <code>function f(x) {return x * 2}</code></li>
    <li>object - <code>{'classSection': '002'}</code></li>
    <li>undefined - <code>undefined</code> (of course!)</li>
  </ul>
</section>

<section>
  <h2 id="lastly-a-quick-review-on-operators">Lastly, a Quick Review on Operators</h2>

  <p>We talked about a bunch of operators. The following are categories of operators, <strong>give examples of each</strong> &#8594;.</p>

  <ul>
    <li><strong>arithmetic</strong>: <code class="fragment">+&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/&nbsp;&nbsp;%</code> <!--* --></li>
    <li><strong>bitwise</strong>: <code class="fragment">&amp;&nbsp;&nbsp;|&nbsp;&nbsp;^&nbsp;&nbsp; ~&nbsp;&nbsp; &lt;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&gt;&gt;</code></li>
    <li><strong>logical operators</strong>: <code class="fragment">&amp;&amp;&nbsp;&nbsp;||&nbsp;&nbsp;!</code></li>
    <li><strong>comparison operators</strong>: <code class="fragment">==&nbsp;&nbsp;!=&nbsp;&nbsp;===&nbsp;&nbsp;!==&nbsp;&nbsp;&gt;&nbsp;&nbsp;&lt;&nbsp;&nbsp;&gt;=&nbsp;&nbsp;&lt;=</code></li>
    <li><strong>miscellaneous</strong>:
      <ul class="fragment">
        <li>unary <code>+</code> and <code>-</code> &#8230; convert to positive or negative number</li>
        <li><code>typeof</code> &#8230; obvs, returns string representation of type of operand</li>
        <li>unary and postfix <code>++</code> and <code>--</code> &#8230; increment and decrement</li>
      </ul>
    </li>
  </ul>

</section>

:ET