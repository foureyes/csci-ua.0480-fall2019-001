I"Lš<section class="intro-slide">
  <h1 id="ajax">AJAX</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="writing-an-express-app">Writing an Express App</h2>

  <p>We&#39;ve made a couple of dynamic, database driven web applications.</p>

  <p><strong>How did they work? What made the request? How was the response generated? What did the response consist of?</strong> &#8594;</p>

  <ol>
    <li class="fragment">the browser would make some request based on url entered, a clicked link or a submitted form</li>
    <li class="fragment">our Express application would respond to that request by:
      <ol>
        <li>getting or writing data to the database</li>
        <li>using resulting data to fill out a template</li>
        <li>sending back html in the response body</li>
      </ol>
    </li>
    <li class="fragment">the browser would render the resulting html page</li>
  </ol>
</section>
<section>
  <h2 id="a-high-level-view">A High Level View</h2>

  <p>Let&#39;s make a quick diagram of how that all worked. <strong>A run-of-the-mill database driven web application.</strong> &#8594;</p>

  <div class="img fragment">

    <p><img src="../../resources/img/html-small.png" alt="html" /></p>

  </div>
</section>

<section>
  <h2 id="traditional-web-applications"><em>Traditional</em> Web Applications</h2>

  <p><strong>We&#39;ve made <em>traditional</em> web applications.</strong></p>

  <ul>
    <li class="fragment">the application itself is <strong>mostly server-side</strong>; the client side is usually just presentation</li>
    <li class="fragment"><strong>it&#39;s typical for most interactions to result in another page being loaded entirely (or in the same page being refreshed)</strong>.</li>
    <li class="fragment">sometimes, you have to <strong>wait a little bit</strong> for the next page (bummer)</li>
    <li class="fragment">this is kind of expected behavior, though. After all, the web <em>is just</em> a bunch of interconnected documents, right?</li>
  </ul>

  <p><br /></p>

  <p class="fragment"><strong>How does this user experience differ from <em>native</em> desktop and mobile apps?</strong> &#8594;</p>

  <ul class="fragment">
    <li>generally speaking, desktop and mobile apps <em>seem more real time</em></li>
    <li>there&#39;s no waiting for a page to load; it <em>just</em> happens</li>
  </ul>
</section>

<section>
  <h2 id="single-page--hybrid-web-applications">Single Page / Hybrid Web Applications</h2>

  <p><strong>Another way to deliver a web application is as a single page:</strong></p>

  <ul class="fragment">
    <li>in this type of application, a single page is loaded</li>
    <li>appropriate data and resources are added to the page as necessary (usually in response to user interactions)
      <ul>
        <li><strong>without the page reloading</strong></li>
        <li><strong>without transferring control to another page</strong></li>
      </ul>
    </li>
    <li>the majority of the application itself is on the client side, and the server acts as a simple data store</li>
    <li>which results in a faster and more responsive user experiences (again, similar to a desktop or mobile application)</li>
  </ul>
</section>

<section>
  <h2 id="single-page--hybrid-web-applications-continued">Single Page / Hybrid Web Applications Continued</h2>

  <p><strong>How do you think this is achieved? What processes would need to take place?</strong> &#8594;</p>

  <ul class="fragment">
    <li>while on a page, the user can trigger background requests to the server through certain interactions</li>
    <li>the server sends back data rather than an html document&#8230;</li>
    <li>when these requests return they augment or modify the page that the user is on</li>
    <li>consequently, the page does not reload, but ui elements change based on the interaction</li>
  </ul>
  <p class="fragment"><br />
<strong>This is possible using combination of client side technologies, commonly called AJAX&#8230;</strong> &#8594;</p>
</section>
<section>
  <h2 id="ajax-1">AJAX</h2>

  <p><strong>AJAX</strong> is short for asynchronous JavaScript and XML. It&#39;s basically a bunch of interrelated technologies and techniques used to create <em>asynchronous</em> web applications:</p>

  <ol>
    <li class="fragment">HTML and CSS for presentation</li>
    <li class="fragment"><strong>JS</strong> and access to the <strong>DOM</strong> to create dynamic user interfaces</li>
    <li class="fragment"><strong>JS and XMLHttpRequest</strong> (or the new <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">fetch api</a>) to allow asynchronous data exchange between browser and server</li>
    <li class="fragment"><strong>Server side applications</strong> to allow reading and writing of data</li>
    <li class="fragment"><strong>JSON</strong> as a convenient and flexible data format
      <ul>
        <li class="fragment">the XML part of the name is a misnomer, as the data format can be anything else, such as JSON or even HTML fragments!</li>
        <li class="fragment">sometimes you may run into other funny acronyms to accommodate this (<a href="http://en.wikipedia.org/wiki/AJAJ">AJAJ</a> comes to mind)</li>
      </ul>
    </li>
  </ol>

</section>

<section>
  <h2 id="ajax---a-high-level-view">AJAX - a High Level View</h2>

  <p><strong>Let&#39;s draw out how all of these technologies may come together as a single page web app&#8230;</strong> &#8594;</p>

  <div class="img fragment">

    <p><img src="../../resources/img/ajax-small.png" alt="ajax" /></p>

  </div>

</section>

<section>
  <h2 id="putting-everything-together--the-missing-ingredient">Putting Everything Together / The Missing Ingredient</h2>

  <p>When these technologies are combined, our client side web applications can make incremental updates to the user interface without reloading the entire page. Great!</p>

  <p><strong>We know most of these technologies. What&#39;s missing?</strong> &#8594;</p>

  <ul>
    <li class="fragment">
      <strike>HTML and CSS</strike>
      <p>(most of you already knew this coming into class, and we did a quick review)</p>
    </li>
    <li class="fragment">
      <strike>JavaScript and access to the DOM</strike>
      <p>(we went over this <em>a lot</em>)</p>
    </li>
    <li class="fragment">
      <strike>Server side applications</strike>
      <p>(Express)</p>
    </li>
    <li class="fragment">
      <strike>JSON</strike>
    </li>
    <li class="fragment">however, we have yet to look at <strong>XMLHttpRequest</strong></li>
  </ul>
</section>

<section>
  <h2 id="http-requests">HTTP Requests</h2>

  <p>Hey. So. <strong>Remember that time when we actually used some Server Side Javascript to make HTTP Requests?</strong> &#8594;</p>

  <ul class="fragment">
    <li>we used the <em>request</em> module to issue asynchronous http requests from Node</li>
    <li>(specifically, we saw it in the basketball homework assignment)</li>
    <li>note that it&#39;s a <strong>server side</strong> module</li>
  </ul>

</section>
<section>
  <h2 id="xmlhttprequest">XMLHttpRequest</h2>

  <p>In client-side JavaScript, there&#39;s a feature analogous to the request module.</p>

  <p><strong><code>XMLHttpRequest</code></strong> is JavaScript object that allows browser based JavaScript to make http requests!</p>

  <ul>
    <li>it provides an interface for retrieving data from a URL</li>
    <li>(without having to reload a page or load another page)</li>
    <li>a page can update just a part of the itself rather than reloading itself entirely</li>
  </ul>

  <p><br />
<strong>THIS IS AMAZING!</strong> (though the api is kind of terrible)</p>

  <p><br />
(Again, you can <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">check out the fetch api</a>, for a newer, but less supported way of making background http requests)</p>

</section>

<section>
  <h2 id="xmlhttprequest-history">XMLHttpRequest History</h2>

  <p>We need a campfire. We don&#39;t have one. <strong>But here it goes</strong>: &#8594;</p>

  <ul>
    <li class="fragment"><strong>XMLHttpRequest</strong> was originally designed by Microsoft for Internet Explorer in the 1990&#39;s (crazy times, eh?)</li>
    <li class="fragment">XML (a robust, but <a href="http://c2.com/cgi/wiki?XmlSucks">fairly <em>heavy</em></a> markup-language / data exchange format) was en vogue at the time (<strong>anyone familiar with it?</strong>)</li>
    <li class="fragment">so rather than just calling the object HttpRequest (which would have been totally accurate)</li>
    <li class="fragment">XML was tacked on to the beginning of the name
      <ul>
        <li class="fragment">though&#8230; XML was a valid response format</li>
        <li class="fragment">(as was JSON, HTML, etc.)</li>
      </ul>
    </li>
    <li class="fragment">it became so popular (because it allowed features such as type-ahead autocomplete) that it was adopted by Mozilla</li>
    <li class="fragment">it&#39;s currently being standardized by the w3c</li>
    <li class="fragment">(also, what&#39;s going on with the <a href="http://programmers.stackexchange.com/questions/157375/why-does-xmlhttprequest-not-seem-to-follow-a-naming-convention">inconsistent casing</a>)? XMLHttpRequest?</li>
  </ul>
</section>

<section>
  <h2 id="great-xmlhttprequest">Great&#8230; XMLHttpRequest</h2>

  <p><strong>How does it work?</strong> &#8594;</p>

  <ul>
    <li>create an XMLHttpRequest object</li>
    <li>configure it with the appropriate request method and url</li>
    <li>specify what it should do:
      <ul>
        <li>on error</li>
        <li>when the content loads</li>
      </ul>
    </li>
    <li>send the request</li>
  </ul>
</section>

<section>
  <h2 id="xmlhttprequest-creation-and-open">XMLHttpRequest, Creation and Open</h2>

  <p>Create an XMLHttpRequest object using the constructor:</p>

  <pre><code data-trim="" contenteditable="">
const req = new XMLHttpRequest();
</code></pre>

  <p>Use the <code>open</code> method to configure the object. It takes 3 arguments:</p>

  <ul>
    <li>request method (string)</li>
    <li>url (string)</li>
    <li>asynchronous (boolean)</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
req.open('GET', url, true);
</code></pre>
</section>

<section>
  <h2 id="xmlhttprequest-load-and-error">XMLHttpRequest, Load and Error</h2>

  <p><strong>Specify what it should do on error vs onload.</strong></p>

  <p>You can also use the <strong>addEventListener</strong> interface that we just learned:</p>

  <pre><code data-trim="" contenteditable="">
req.addEventListener('load') { ... };
req.addEventListener('error') { ... };
</code></pre>

  <p class="fragment">There&#39;s also the older style <strong><code>onerror</code></strong> and <strong><code>onload</code></strong> properties on the XMLHttpRequest object:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
req.onload = function() { ... };
req.onerror = function() { ... };
</code></pre>

</section>

<section>
  <h2 id="xmlhttprequest-responsetext-and-status">XMLHttpRequest responseText and status</h2>

  <p>Your <strong>XMLHttpRequest</strong> object has a couple of useful properties:</p>

  <ul>
    <li><strong><code>status</code></strong> - the response status code (for example, 200)</li>
    <li><strong><code>responseText</code></strong> - the actual body of the response</li>
  </ul>

  <p><br />
Typically, you would use the status to determine if the request were successful:</p>

  <pre><code data-trim="" contenteditable="">
if (req.status &gt;= 200 &amp;&amp; req.status &lt; 400) {
	// do some cool stuff
}
</code></pre>
</section>

<section>
  <h2 id="xmlhttprequest-send">XMLHttpRequest, send()</h2>

  <p>Use <strong><code>send()</code></strong> to actually send your request.</p>

  <ul>
    <li>send has an optional argument &#8211; the data that you want send as your request body
      <ul>
        <li>you&#39;ll usually leave out this argument</li>
        <li>unless you&#39;re posting data (in which case the POST data is sent along as the arugument)</li>
      </ul>
    </li>
    <li>any event listeners you wish to set must be set before calling send()</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
req.send();
</code></pre>
</section>
<section>
  <h2 id="a-quick-example">A Quick Example</h2>

  <p>Using <a href="../../code/hello.json">this json file</a>:</p>

  <ul>
    <li>request the file from a blank page</li>
    <li>parse the JSON&#8230; and insert each object&#39;s message into document.body as a div</li>
  </ul>

  <p><br />
<strong>Some setup to serve this exercise, as well as a few others:</strong> &#8594;</p>

  <ol>
    <li class="fragment">setup a barebones express app</li>
    <li class="fragment">create the json file above in your public folder</li>
    <li class="fragment">create an html file called <code>hello.html</code> in your public folder
      <ul>
        <li>set up some boilerplate html</li>
        <li>just add script tags to include the following</li>
      </ul>
    </li>
    <li class="fragment">create a JavaScript file called <code>hello.js</code> in your public/javascripts folder</li>
  </ol>

</section>

<section>
  <h2 id="setting-up-a-request">Setting Up a Request</h2>

  <p>In your JavaScript file, <code>hello.js</code>:</p>

  <ul>
    <li>write code to setup a request to the following url:
      <ul>
        <li><code>'http://localhost:3000/hello.json'</code></li>
      </ul>
    </li>
    <li>the request should be GET, and asynchronous should be true</li>
  </ul>

  <p><br /></p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const url = 'http://localhost:3000/hello.json';
const req = new XMLHttpRequest();
req.open('GET', url, true);
</code></pre>
</section>

<section>
  <h2 id="on-load-event-handler">On Load Event Handler</h2>

  <p>Once we&#39;ve successfully received data, <strong>add each object&#39;s message as a div to the body of the blank document.</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
req.addEventListener('load', function() {
	if (req.status &gt;= 200 &amp;&amp; req.status &lt; 400) {
		const messages = JSON.parse(req.responseText);
		messages.forEach(function(obj) {
			document.body.appendChild(
				document.createElement('div')).
				textContent = obj.message;
		});
	}
});

</code></pre>
</section>

<section>
  <h2 id="on-error-event-handler-and-sending">On Error Event Handler&#8230; and Sending</h2>

  <p><strong>If there&#39;s an error&#8230; just create a text node for now:</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
req.addEventListener('error', function(e) {
	document.body.appendChild(document.createTextNode('uh-oh, something went wrong ' + e));
});
</code></pre>

  <p class="fragment"><strong>Lastly&#8230; send the request.</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
req.send();
</code></pre>
</section>

<section>
  <h2 id="what-happened">What Happened?</h2>

  <p>Hey - we started out with a completely blank html page, but it has some text in it!?</p>

  <p><strong>Let&#39;s check out the network tab and refresh the page.</strong> &#8594;</p>

  <ul class="fragment">
    <li>we made a request to <code>hello.html</code></li>
    <li>which in turn requested <code>hello.js</code></li>
    <li>which in turn used XMLHttpRequest to request <code>hello.json</code></li>
  </ul>

  <p class="fragment"><br />
<strong>hello!</strong></p>

</section>

<section>
  <h2 id="lets-cause-an-error">Let&#39;s Cause an Error!</h2>

  <p><strong>How do you think we can get an error to show up?</strong> &#8594;</p>

  <ul class="fragment">
    <li>change the domain to something that doesn&#39;t exist</li>
    <li>change the page we&#39;re accessing so that we get a 404
      <ul>
        <li>um&#8230; wait, do we handle a 404?</li>
        <li>we can! <strong>let&#39;s try it&#8230;</strong> &#8594;</li>
      </ul>
    </li>
  </ul>

  <pre class="fragment"><code data-trim="" contenteditable="">
else {
	document.body.appendChild(
		document.createTextNode(
		'request received a ' + req.status));
}
</code></pre>
</section>

<section>
  <h2 id="triggering-from-a-click">Triggering From a Click</h2>

  <p>We could also modify the code so that the request is only made when a user clicks a button. <strong>Let&#39;s start off by adding this markup.</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
&lt;h1&gt;Messages&lt;/h1&gt;
&lt;input type="button" id="get-messages-button" value="GET MAH MSGS"&gt;
</code></pre>

  <p><strong>How would we change our JavaScript so that whenever you click the button above, it requests the messages in the json file and inserts them into the DOM?</strong> &#8594;</p>
</section>

<section>
  <h2 id="integrating-a-click-event">Integrating a Click Event</h2>

  <p>Just get the button and add a &quot;click&quot; event listener.</p>

  <pre><code data-trim="" contenteditable="">
const button = document.getElementById('get-messages-button');
button.addEventListener('click', function() { 
.
.
.
});
</code></pre>

  <p>You can drop in all of you request code in the callback above.</p>

  <ul>
    <li>notice each time you press a button, a new request comes up in the network tab.</li>
  </ul>
</section>

<section>
  <h2 id="will-this-work-with-any-url">Will This Work With Any URL?</h2>

  <p>Let&#39;s try a little experiment:</p>

  <ul>
    <li>instead of requesting hello.json</li>
    <li>what if we tried requesting a page from cs.nyu.edu?</li>
  </ul>

  <p><br /></p>

  <p><strong>What do you think will happen? (Ignore the fact that the documents don&#39;t match at all, and we&#39;re not getting back json; there&#39;s something else off)</strong> &#8594;</p>

  <ul class="fragment">
    <li>totally not allowed!</li>
    <li>the request will fail</li>
    <li><strong>let&#39;s see.</strong> &#8594;</li>
  </ul>

</section>

<section>
  <h2 id="what-access-control-allow-origin-huh-what">What? Access-Control-Allow-Origin. Huh? What?</h2>

  <p>Here&#39;s the error that we get:</p>

  <pre><code data-trim="" contenteditable="">
XMLHttpRequest cannot load ...

'No Access-Control-Allow-Origin' header is present on 
the requested resource. Origin 'http://localhost:3000' 
is therefore not allowed access.
</code></pre>

  <p><strong>What do you think it means?</strong> &#8594;</p>

  <ul>
    <li class="fragment">there&#39;s some header that&#39;s not present in the response</li>
    <li class="fragment">so we can&#39;t have access to the content / resource</li>
    <li class="fragment">(uh, maybe that wasn&#39;t much help)</li>
  </ul>
</section>

<section>
  <h2 id="cors-and-sop">CORS and SOP</h2>

  <p><strong>No, really, what does it mean?</strong> &#8594;</p>

  <p>We were not given access to the content, <strong>because we&#39;re not allowed to make cross domain requests to that server</strong>.</p>

  <p>The two ideas that govern this are:</p>

  <ul>
    <li>Same Origin Policy (<strong>SOP</strong>)</li>
    <li>Cross Origin Resource Sharing (<strong>CORS</strong>)</li>
  </ul>
</section>

<section>
  <h2 id="same-origin-policy">Same Origin Policy</h2>

  <p>The <strong>same origin policy</strong> is a policy implemented by browsers that <strong>restricts how a document, script or data from one <em>origin</em> can interact with a document, script or data from <em>another origin</em>.</strong></p>

  <ul>
    <li class="fragment">it <strong>permits scripts</strong> running on pages originating from the same site to access documents, scripts or data from each other</li>
    <li class="fragment">but <strong>prevents scripting</strong> access to these resources if they are on different sites
      <ul>
        <li>note that <strong>access</strong> depends on the kind of request being made</li>
        <li>(for regular GET requests, this usually means that the request can be made, but the response is not allowed to be read by the script)</li>
        <li>(for other requests, the request may be outright denied!)</li>
      </ul>
    </li>
    <li class="fragment">of course, because this is specification includes scripting access, it applies to XMLHttpRequests (we&#39;ll see an exception shortly)</li>
  </ul>
</section>

<section>
  <h2 id="same-site">Same Site?</h2>

  <p><strong>What does <em>same site</em> or <em>same origin</em> mean exactly?</strong> &#8594;</p>

  <p class="fragment">From MDN&#8230;</p>

  <ul>
    <li class="fragment">two pages have the same origin if the <strong>protocol</strong>, <strong>port</strong> (if one is specified), and <strong>host</strong>  are the same for both pages</li>
    <li class="fragment"><strong>determine if the following pages would have the same origin as</strong>: &#8594; <code>http://store.company.com/dir/page.html</code>
      <ul>
        <li class="fragment"><code>http://store.company.com/dir2/other.html</code> <span class="fragment">Yes</span></li>
        <li class="fragment"><code>http://store.company.com/dir/inner/another.html</code> <span class="fragment">Yes</span></li>
        <li class="fragment"><code>https://store.company.com/secure.html</code> <span class="fragment">No - different protocol</span></li>
        <li class="fragment"><code>http://store.company.com:81/dir/etc.html</code> <span class="fragment">No - different port</span></li>
        <li class="fragment"><code>http://news.company.com/dir/other.html</code> <span class="fragment">No- different host</span></li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="why-same-origin-policy">Why Same Origin Policy?</h2>

  <p>That seems weirdly restrictive, right? <strong>Why do you think same origin policy exists? What is it trying to prevent?</strong> &#8594;</p>

  <p class="fragment">A hint from wikipedia: &quot;This mechanism bears a particular significance for modern web applications that extensively depend on HTTP cookies to maintain authenticated user sessions&quot;</p>

  <ul class="fragment">
    <li>if a user is logged in to another site</li>
    <li>and a script from a different origin is allowed to make requests</li>
    <li>it could make requests to and from the site that the user is logged into!</li>
    <li><strong>Cross Site Request Forgery! (CSRF)</strong></li>
  </ul>
</section>

<section>
  <h2 id="an-example-of-csrf">An Example of CSRF</h2>

  <p><strong>Imagine that you&#39;re logged into your bank account:</strong> &#8594;</p>

  <ul>
    <li class="fragment">same origin policy is <strong>not implemented</strong> in your browser, and your bank has no additional csrf protection (<em>bad news</em>)</li>
    <li class="fragment">I send you a link to my page of <em>animated gifs of dancing pizza</em></li>
    <li class="fragment">no one can resist animated gifs and pizza, so you click on the link</li>
    <li class="fragment">once on my page, behind the scenes, I can use <code class="highlighter-rouge">XMLHttpRequest</code> to&#8230;</li>
    <li class="fragment">get a page that&#39;s behind your bank&#39;s login (something like mybank/account) because you&#39;re already logged in</li>
    <li class="fragment">from there I can:
      <ul>
        <li>steal data - read information that I should not be allowed to read</li>
        <li>possibly take actions by issuing POST requests</li>
        <li>(^^^ slightly more complicated than this, but&#8230; you get the idea)</li>
        <li>YIKES!</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="convinced">Convinced?</h2>

  <p>I think we can agree that Same Origin Policy is kind of&#8230; um <em>important</em>.</p>

  <p><strong>But&#8230; how do we share data across sites? How do APIs work?</strong> &#8594;</p>

  <p><strong>Let&#39;s try a quick experiment with githubs public API.</strong> &#8594;</p>
</section>

<section>
  <h2 id="github-api">GitHub API</h2>

  <p>You can actually get info from a GitHub user through <a href="https://developer.github.com/v3/">GitHub&#39;s api</a> by using the following URL:</p>

  <pre><code data-trim="" contenteditable="">
https://api.github.com/users/[a username]/repos
</code></pre>

  <p>Let&#39;s try checking out what it says about one of my GitHub accounts by hitting the actual api url: <a href="https://api.github.com/users/foureyes/repos">https://api.github.com/users/foureyes/repos</a></p>

  <pre><code data-trim="" contenteditable="">
[{
"id": 26084780,
"name": "bjorklund",
"full_name": "foureyes/bjorklund",
"owner": { 
	"login": "foureyes",
	"avatar_url": "https://avatars.githubusercontent.com/u/356512?v=3",
	"url": "https://api.github.com/users/foureyes",
	.
	.
},
"private": false,
.
.
}]
</code></pre>
</section>

<section>
  <h2 id="lets-build-a-repository-browser">Let&#39;s Build a Repository Browser</h2>

  <p><strong>We could probably build a quick form that takes in a username</strong> &#8594;</p>

  <ul>
    <li>&#8230;and lists off all of the repositories that the user has</li>
    <li><strong>let&#39;s give it a try.</strong> &#8594;
      <ul>
        <li>how about a wireframe?</li>
        <li>a use case?</li>
        <li>maybe some markup first (what form elements would we need? should we have some styles&#8230; sure!)</li>
        <li>then some JavaScript</li>
      </ul>
    </li>
  </ul>

  <p><br /></p>

  <p><strong>Some more docs regarding the GitHub API:</strong> &#8594;</p>

  <ul>
    <li><a href="https://developer.github.com/v3/rate_limit/">rate limit status</a></li>
    <li><a href="https://developer.github.com/v3/repos/#list-user-repositories">list user repos</a></li>
  </ul>

</section>

<section>
  <h2 id="repository-viewer-wireframe">Repository Viewer Wireframe</h2>

  <p><strong>Our repository viewer will have:</strong> &#8594;</p>

  <ul>
    <li>one text field where you can input a github username</li>
    <li>a list all of that person&#39;s pubic repositories when you click on submit</li>
    <li>(optionally) a button to check for rate limit (of course!)</li>
  </ul>

  <p><br /></p>

  <p>It might look like this:</p>

  <div class="img">
    <p><img src="../../resources/img/github-repo-browser.jpg" alt="github" /></p>
  </div>

</section>

<section>
  <h2 id="reading-api-documentation">Reading API Documentation</h2>

  <p>Typically, API documentation will specify:</p>

  <ul>
    <li class="fragment">http request method to use</li>
    <li class="fragment">the path to the resource</li>
    <li class="fragment">the response format and status code</li>
    <li class="fragment">the actual data contained within the response</li>
  </ul>

  <p class="fragment"><br />
<strong>Let&#39;s take a look at the two end points we&#39;ll be using.</strong> &#8594;</p>

</section>

<section>
  <h2 id="show-rate-limit-status">Show Rate Limit Status</h2>

  <p>The endpoint / URL for retrieving info about the rate limit is:</p>

  <pre><code data-trim="" contenteditable="">
GET /rate_limit
</code></pre>

  <p>Using this URL with my account: <a href="https://api.github.com/rate_limit">https://api.github.com/rate_limit</a></p>

  <p>We&#39;re interested in resources.core.limit&#8230; this is what we get back:</p>

  <pre><code data-trim="" contenteditable="">
{
  "resources": {
    "core": {
      "limit": 60,
      "remaining": 58,
      "reset": 1447761547
    },
    "search": {
      "limit": 10,
      "remaining": 10,
      "reset": 1447759711
    }
  },
  "rate": {
    "limit": 60,
    "remaining": 58,
    "reset": 1447761547
  }
}

</code></pre>

</section>

<section>
  <h2 id="list-user-repos">List User Repos</h2>

  <p>The endpoint / URL for retrieving repository info from GitHub is:</p>

  <pre><code data-trim="" contenteditable="">
GET /:username/repos
</code></pre>

  <p>Using this URL with my account: <a href="https://api.github.com/users/foureyes/repos">https://api.github.com/users/foureyes/repos</a></p>

  <p>We get back&#8230;</p>

  <pre><code data-trim="" contenteditable="">
[{
"id": 26084780,
"name": "bjorklund",
"full_name": "foureyes/bjorklund",
"owner": { 
	"login": "foureyes",
	"avatar_url": "https://avatars.githubusercontent.com/u/356512?v=3",
	"url": "https://api.github.com/users/foureyes",
	.
	.
},
"private": false,
.
.
}]
</code></pre>
</section>

<section>
  <h2 id="lets-start-with-some-markup">Let&#39;s Start With Some Markup</h2>

  <p>We&#39;ll need:</p>

  <ul>
    <li>a text input for the username</li>
    <li>a button to submit</li>
    <li>a button to ask for the rate limit</li>
    <li>a place to insert the repository names as a list</li>
    <li>a place to insert the rate limit info</li>
  </ul>

</section>

<section>
  <h2 id="maybe-some-markup-like-this">Maybe Some Markup Like This?</h2>

  <p>Here&#39;s our HTML:</p>

  <pre><code data-trim="" contenteditable="">
&lt;h2&gt;Repository Viewer&lt;/h2&gt;
&lt;input type="button" id="get-rate-limit" name="get-rate-limit" value="Get Rate Limit"&gt;
&lt;pre id="rate-limit"&gt;
&lt;/pre&gt;
&lt;label for="username"&gt;GitHub Username&lt;/label&gt;
&lt;input type="text" id="username" name="username"&gt;
&lt;input type="button" id="get-repos" name="get-repos" value="Get Repositories"&gt;
&lt;div id="container"&gt;
			&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
</code></pre>
</section>

<section>
  <h2 id="setting-up--getting-required-elements">Setting Up &#8230; Getting Required Elements</h2>

  <p><strong>Let&#39;s gather the buttons and add event listeners to them.</strong> &#8594;</p>
  <pre><code data-trim="" contenteditable="">
document.addEventListener('DOMContentLoaded', init);

function init() {
	console.log('init');
	var button = document.getElementById('get-repos'),
		rateLimitButton = document.getElementById('get-rate-limit');

	button.addEventListener('click', handleClick);
	rateLimitButton.addEventListener('click', handleRateLimitClick);
}
</code></pre>
</section>

<section>
  <h2 id="handling-a-click-on-the-rate-limit-button">Handling a Click on the Rate Limit Button</h2>

  <p>To get the rate limit, we can use the following url <a href="http://api.github.com/rate_limit">http://api.github.com/rate_limit</a>.  <strong>Let&#39;s set up the request in our <code>handleRateLimitClick</code> function</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function handleRateLimitClick() {
	var req = new XMLHttpRequest(),
		url = 'http://api.github.com/rate_limit';

	req.open('GET', url, true);
	req.addEventListener('load', handleRateLimitResponse);
	req.send();
}
</code></pre>
</section>

<section>
  <h2 id="dealing-with-the-response">Dealing with the Response</h2>

  <p><strong>Let&#39;s define a function that populates an element, the pre tag, with the data from the API Limit call.</strong> &#8594;</p>
  <pre class="fragment"><code data-trim="" contenteditable="">
function handleRateLimitResponse() {
	var pre = document.getElementById('rate-limit'), 
		response = JSON.parse(this.responseText);
	if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) {
		pre.textContent = response.rate.limit + ' Limit, ' 
				+ response.rate.remaining + ' Remaining, ' 
				+ new Date(response.rate.reset * 1000);
	}
}
</code></pre>
</section>

<section>
  <h2 id="now-for-the-actual-repo-browser">Now for the Actual Repo Browser&#8230;</h2>

  <p>When clicking view repositories, we should retrieve the repositories for the user in the text field. <strong>First, let&#39;s set up our click handler&#8230; and configure a request within it.</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function handleClick(evt) {
	var req = new XMLHttpRequest(),
		url = 'http://api.github.com/users/' + 
			document.getElementById('username').value + '/repos';

	req.open('GET', url, true);
	req.addEventListener('load', handleResponse);
	req.send();
}
</code></pre>
</section>

<section>
  <h2 id="lastly-once-we-have-the-repository-data">Lastly, Once we Have the Repository Data&#8230;.</h2>

  <p>We can use the response from the API to drop in the repositories. <strong>Create a function that gets called when the data from the request has loaded.</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function handleResponse() {
	if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) {
		var div = document.getElementById('container'), 
			oldList = document.querySelector('#container ul'),
			ul = document.createElement('ul'),
			repos = JSON.parse(this.responseText);

		repos.forEach(function(obj) {
			ul.appendChild(document.createElement('li')).textContent = obj.name;
		});
		div.replaceChild(ul, oldList);
	}
}
</code></pre>
</section>

<section>
  <h2 id="take-a-quick-look-at-the-domains">Take a Quick Look at the Domains</h2>

  <p><strong>See anything strange?</strong> &#8594;</p>

  <p class="fragment">Yeah&#8230; wait a second. Those are different domains? <strong>Aren&#39;t cross domain requests allowed?</strong> &#8594;</p>

  <ul class="fragment">
    <li>Well. Yes&#8230;</li>
    <li>That is, unless the server your sending your request to sets some specific headers</li>
    <li>That&#39;s where CORS or Cross Origin Resource Sharing comes in</li>
  </ul>
</section>

<section>
  <h2 id="cross-origin-resource-sharing">Cross Origin Resource Sharing</h2>

  <p><strong>Cross Origin Resource Sharing</strong> (CORS) is a mechanism that allows resources, such as JSON, fonts, etc. to be requested from a domain from a different origin.  From <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">mdn</a>:</p>

  <ul>
    <li>it works by adding HTTP headers that allow servers to describe the set of origins that are permitted to read that information using a web browser</li>
    <li>for example, <strong>Access-Control-Allow-Origin</strong> (a URL that specifies an allowed origin, or * for all), is header that the server will set in the response</li>
    <li>the browser will use that information to determine how to deal with cross domain requests</li>
  </ul>
</section>

<section>
  <h2 id="hm-if-thats-the-case">Hm. If That&#39;s The Case</h2>

  <p><strong>How do you think we were able to contact GitHub&#39;s api?</strong> &#8594;</p>

  <ul>
    <li>it must have had some of those fancy CORS headers set</li>
    <li>Access-Control-Allow-Origin must be set to *</li>
    <li><strong>how can we tell; how can we prove this?</strong> &#8594;</li>
    <li class="fragment"><strong>let&#39;s check out the network tab on Chrome&#39;s developer tools</strong> &#8594;</li>
  </ul>

</section>

<section>
  <h2 id="its-up-to-the-browser-and-the-server">It&#39;s Up to the Browser (and the Server)</h2>

  <p><strong>So&#8230; how does this work <em>behind</em> the scenes.</strong> &#8594;</p>

  <ul>
    <li class="fragment">for GETs and POSTs, the script <em>can actually</em> make a cross domain request and get a response back (wait, what?)</li>
    <li class="fragment">but the browser, at the network level, prevents access to the response from the script</li>
    <li class="fragment">for other HTTP request methods (and maybe more <em>complicated</em> GETs and POSTs), browsers will &quot;preflight&quot; the request by:
      <ul>
        <li>soliciting supported methods from the server with an HTTP OPTIONS request method</li>
        <li>and then, upon &quot;approval&quot; from the server, sending the actual intended request with the appropriate HTTP request method</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="back-to-csrf">Back to CSRF</h2>

  <p>Going to our example of cross-site request forgery, issuing a background POST via scripting &#8230; to another domain seems like it&#39;ll work, because the request will actually go through!</p>

  <p><strong>Then&#8230; how is CSRF prevented, and how does SOP/CORS help in preventing CSRF</strong></p>

  <ol>
    <li class="fragment">one common method is to have token generated for each form that&#39;s a hidden input</li>
    <li class="fragment">this token is checked when the form is submitted&#8230; <strong>but wait, this seems like we can circumvent it</strong> &#8594;</li>
    <li class="fragment">the 1st background request can read the form&#39;s token! &#8230; <strong>but can it?</strong> &#8594;</li>
    <li class="fragment">SOP prevents this from happening!</li>
    <li class="fragment">some resources: <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery#Prevention">CSRF prevention</a>, <a href="http://stackoverflow.com/questions/12823390/what-stops-someone-from-reading-csrf-tokens-in-form-inputs-with-js">SOP vs CSRF</a></li>
  </ol>

</section>

<section>
  <h2 id="whoah-neat-cross-domain-totally-works">Whoah Neat. Cross Domain Totally Works.</h2>

  <p>However, you may not always have access or contact with the server that&#39;s running the services. So, maybe they won&#39;t set the CORS headers for you. <strong>What are some other options around cross domain requests?</strong> &#8594;</p>

  <ul>
    <li class="fragment">create a proxy that requests the resource for you (server side), but is on your domain</li>
    <li class="fragment">request the data server side and <em>cache</em> the data; create a service that serves the cached data</li>
    <li class="fragment">of course, these are all likely against terms of use</li>
    <li class="fragment">(probably don&#39;t do this)</li>
    <li class="fragment">also note that many apis have rate limits</li>
    <li class="fragment">they also mostly require some sort of authentication</li>
  </ul>
</section>

<section>
  <h2 id="hm-does-that-mean-we-can-make-our-own-apis">Hm. Does That Mean We Can Make Our Own APIs?</h2>

  <p>Yes. <strong>We can make our own APIs with Express</strong>.</p>

  <p>The secret is:</p>

  <pre><code data-trim="" contenteditable="">
res.json()
</code></pre>

  <p>This returns a json response of the object that is passed in.</p>

  <p><strong>Let&#39;s try one where we read message objects out of MongoDB</strong> &#8594;</p>
</section>

<section>
  <h2 id="heres-a-schema">Here&#39;s a Schema</h2>

  <p>Just a run-of-the-mill message:</p>

  <pre><code data-trim="" contenteditable="">
const Message = new mongoose.Schema({
	message: String,
	dateSent: Date
});
</code></pre>

</section>
<section>
  <h2 id="a-router-that-exposes-the-api">A Router That Exposes the API</h2>

  <p>Get all messages as JSON&#8230;</p>

  <pre><code data-trim="" contenteditable="">
router.get('/api/messages', function(req, res) {
  Message.find({}, function(err, messages, count) {
    res.json(messages.map(function(ele) {
      return {
        'message': ele.message,
        'date': ele.dateSent
      }; 
    }));
  });
});
</code></pre>
</section>
<!--
<section markdown="block">
## 

* AJAX overview
* NBA Example, push button... spinner that's replaced
	* try with local to show example that's actually working
		* show json loading
		* show nettab
		* note that there's not an additional request to the server
	* try with live example to show cors
	* demo transition effects and timer TODO: youmightnotneedjquery
* Same Origin Policy
* How to get around?
* Wait, what about different domains
* Why?
* promises?
	* CORs
* GitHub Example... another one with a form

* Tumblr Example... show that you can look for trending tags... click... get images
* CORS
* lots of callbacks... what about promises?
</section>
-->
:ET