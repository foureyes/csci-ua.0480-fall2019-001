I"T<section>
  <h2 id="integrating-with-express">Integrating with Express</h2>

  <p>(Without Codepen / JSbin / Glitch / create-react-app) Sooo&#8230; how do you think we could serve up our small React client side examples through Express? <strong>What would we minimally need to do to even start a React app?</strong> &#8594;</p>

  <ul>
    <li class="fragment">include the react library in our client side code</li>
    <li class="fragment"><em>serve</em> any of the components that we create</li>
  </ul>
</section>

<section>
  <h2 id="integrating-with-express-continued">Integrating With Express Continued</h2>

  <p>This would normally be a straightforward task:</p>

  <ol>
    <li>just serve up our client side JavaScript from the public/javascripts directory using express static</li>
    <li>do the same with the react library&#8230;
      <ul>
        <li>download it or use some sort of client side package manager like bower&#8230; and, again, serve it from our public/javascripts folder</li>
        <li>or just include the file from someone else that&#39;s hosting it (like a <a href="https://cdnjs.com/libraries/react">content delivery network / cdn</a>&#8230; <a href="https://facebook.github.io/react/downloads.html">or from facebook</a>)</li>
      </ul>
    </li>
  </ol>
</section>

<section>
  <h2 id="some-setup">Some Setup</h2>

  <ol>
    <li>create an Express app</li>
    <li>create an html file in <code>public</code></li>
    <li>include the appropriate scripts&#8230; using the examples for setting up a dev version of a react app <a href="https://facebook.github.io/react/downloads.html">from facebook</a>:</li>
  </ol>

  <pre><code data-trim="" contenteditable="">
<script src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
</code></pre>

</section>

<section>
  <h2 id="create-and-mount-a-test-component">Create and Mount a Test Component</h2>

  <p>Markup</p>

  <pre><code data-trim="" contenteditable="">
&#x9;&#x3C;div id=&#x22;app&#x22;&#x3E; &#x3C;/div&#x3E;
</code></pre>

  <p>Component</p>

  <pre><code data-trim="" contenteditable="">
class MyComponent extends React.Component{
&#x9;render() {
&#x9;&#x9;return React.createElement(&#x27;h1&#x27;, {}, &#x27;hello&#x27;);
&#x9;}
}

ReactDOM.render(
&#x9;React.createElement(MyComponent),
&#x9;document.getElementById(&#x27;app&#x27;)
);
</code></pre>

</section>

<section>
  <h2 id="easy-right">Easy, Right?</h2>

  <p>Hey&#8230; wait, I thought we used JSX with react. Let&#39;s change our code&#8230;</p>

  <pre><code data-trim="" contenteditable="">
class MyComponent extends React.Component({
&#x9;render() {
&#x9;&#x9;return (
&#x9;&#x9;&#x9;&#x3C;h1&#x3E;Hello&#x3C;/h1&#x3E;
&#x9;&#x9;);
&#x9;}
}

ReactDOM.render(
&#x9;&#x3C;MyComponent /&#x3E;
&#x9;document.getElementById(&#x27;app&#x27;)
);
</code></pre>

  <p><strong>Let&#39;s see what happens</strong> &#8594;</p>
</section>

<section>
  <h2 id="sad-face">Sad Face</h2>

  <pre><code data-trim="" contenteditable="">
Uncaught SyntaxError: Unexpected token &lt;
</code></pre>

  <p>This <em>is</em> valid JSX, right? It works on Glitch and Codepen&#8230; <strong>so what do you think happened here</strong>? &#8594;</p>

  <ul>
    <li class="fragment">Hmmm&#8230; looks like our browser doesn&#39;t understand JSX!</li>
    <li class="fragment">We need to somehow compile it&#8230;</li>
  </ul>
</section>

<section>
  <h2 id="babel">Babel</h2>

  <p><a href="https://babeljs.io/">Babel</a> is a set of tools that allows you to use <strong>new JavaScript</strong> syntax, now, <strong>even if browsers don&#39;t support it yet</strong>!!! YES. THE FUTURE IS NOW!</p>

  <ul>
    <li>it transforms syntax from ES6/ES2015, ES2016, ES2017, etc. to plain ol&#39; ES5&#8230;</li>
    <li>&#8230;so that you can write ES6 without having to wait for full browser support ðŸ™Œ</li>
    <li>&#8230;and, of course, <strong>it&#39;ll compile JSX to plain JavaScript</strong></li>
  </ul>
</section>

<section>
  <h2 id="how-about-in-browser">How About In-Browser?</h2>

  <p><strong>So when/where do we use a transformer, like babel?</strong> &#8594;</p>

  <p class="fragment">Things would be pretty easy if we could just use babel or some other transformer by including some client side JavaScript?</p>

  <ul>
    <li class="fragment">our client side JavaScript will include a JSX transformer script / library</li>
    <li class="fragment">which means that compilation of JSX into JavaScript will happen in the user&#39;s browser</li>
    <li class="fragment">so&#8230; it seems like we just find this thing, and magically, JSX will work in our browser, right?</li>
  </ul>

</section>

<section>
  <h2 id="but-wait">But Wait</h2>

  <p>So&#8230; all signs point to the fact that compiling in browser is a bad idea, (sigh, yes, it is).</p>

  <ul>
    <li><a href="https://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html">facebook says so (don&#39;t use JSX-Transformer)</a></li>
    <li><a href="https://github.com/Daniel15/babel-standalone"><em>this</em> project exists (babel-standalone)and is folded into babel, but it lists out very specific use cases</a>
      <ul>
        <li><a href="https://reactjs.org/docs/try-react.html">react&#39;s docs suggest this</a></li>
        <li>but it also says&#8230;  <em>donâ€™t use it in production</em></li>
      </ul>
    </li>
  </ul>

  <p><br /></p>

  <p class="fragment">There&#39;s probably a reason why everyone says avoid in-browser transform&#8230; <strong>why</strong> &#8594;</p>

  <ul>
    <li class="fragment">facebook docs say &quot;(the JSX transformer) is fairly large and results in extraneous computation client-side that can be avoided - do not use it in production&quot;</li>
    <li class="fragment">we really only want to transform once (not once per client!)</li>
    <li class="fragment">why transform on the client for every user (slowing down the user experience), when we can just transform once on the server by precompiling before deploy!?</li>
  </ul>

</section>

<section>
  <h2 id="ohhh-kaaay-so-now-what">Ohhh Kaaay. So Now What?</h2>

  <p><strong>So here&#39;s where things get kind of complicated. We&#39;ll need:</strong> &#8594;</p>

  <ul>
    <li><strong>babel</strong> to do the processing</li>
    <li><strong>and some tool to find the files that need processing</strong>, and apply the transformation to those files</li>
    <li><strong>why do you think we need a separate tool for this - why can&#39;t we just compile our one js file and call it a day?</strong> &#8594;</li>
    <li class="fragment">your file may have dependencies which may also need to be compiled</li>
    <li class="fragment">dependencies can get complicated really fast, even for small projects</li>
  </ul>

</section>

<section>
  <h2 id="enter-webpack">Enter Webpack</h2>

  <p>This is where <strong>webpack</strong> comes in. Webpack will do two things for us:</p>

  <ol>
    <li>it&#39;ll investigate our app using some <strong>entry point</strong> JavaScript file that we specify&#8230; and figure out all of that file&#39;s dependencies
      <ul>
        <li>for example, we may have a client side JavaScript file, client.js, that depends on React and socket.io</li>
      </ul>
    </li>
    <li>then, it&#39;ll use additional libraries (<strong>loaders</strong> to <strong>run some processes</strong>) based on the extension of each dependency
      <ul>
        <li>for example, for all of our js files, it may compile any jsx syntax into regular JavaScript</li>
        <li>there&#39;s a <strong>loader</strong> that integrates <strong>babel</strong> into the webpack workflow</li>
      </ul>
    </li>
  </ol>

  <p><br />
Note that there&#39;s some intersection in functionality among <strong>webpack</strong>, <strong>grunt</strong>, and <strong>gulp</strong> (for example, they can all be used to concatenate files)</p>
</section>

<section>
  <h2 id="webpack-vs-grunt-and-gulp">webpack vs grunt and gulp</h2>

  <p>So <strong>grunt</strong> and <strong>gulp</strong> are build tools. That is, you specify some tasks, and they&#39;ll run them automatically. For example, you want your build tools to:</p>

  <ul>
    <li>minify your client side JavaScript and CSS</li>
    <li>concatenate all of those files</li>
    <li>even run your JSX transformations!</li>
  </ul>

  <p><br /></p>

  <p>And&#8230; this will all be done without having to run separate commands. However, grunt and gulp are focused on files, while webpack is focused on a <em>project</em>. <strong>What does that exactly mean&#8230;</strong> &#8594;</p>
</section>

<section>
  <h2 id="webpack-and-dependencies">Webpack and Dependencies</h2>

  <p><strong>Webpack requires that you specify a single entry point to your application.</strong></p>

  <ul>
    <li>typically, this is a single js file like <code>main.js</code> or <code>client.js</code></li>
    <li>then, it&#39;ll figure out what that file depends on by <code>require</code> statements (or import statements for ES6 syntax!)&#8230;</li>
    <li>this will also work for assets like urls in CSS or hrefs in image tags!</li>
  </ul>

  <p><br />
It&#39;ll take all of these dependencies and output them as static assets based on your configuration.</p>

</section>
<section>
  <h2 id="setting-up-express-with-webpack">Setting up Express with Webpack</h2>

  <p>Assuming we have a barebones Express app, the <a href="">webpack docs</a> recommend installing it both globally and locally in your project:</p>

  <p>Globally (since you&#39;ll likely use for multiple projects)</p>

  <pre><code data-trim="" contenteditable="">
npm install webpack -g
</code></pre>

  <p>Then&#8230; install webpack as a development dependency in case you want to use a <em>specific</em> version.</p>

  <pre><code data-trim="" contenteditable="">
npm install webpack --save-dev
</code></pre>

  <p>This gives us a commandline tool, <strong>webpack</strong> (of course), that we&#39;ll use to bundle our JavaScript&#8230;</p>

  <pre><code data-trim="" contenteditable="">
webpack --help
</code></pre>
</section>

<section>
  <h2 id="babel-and-webpack">babel and webpack</h2>

  <p>Of course, we&#39;ll also need to integrate babel into the mix - that was the whole point. We&#39;ll want to install the following libraries:</p>

  <ul>
    <li class="fragment"><code>babel-core</code> -  babel itself</li>
    <li class="fragment"><code>babel-loader</code> - webpack plugin for babel</li>
    <li class="fragment"><a href="https://babeljs.io/docs/plugins/preset-react/"><code>babel-preset-react</code></a> - a bunch of plugins for babel that are useful for react apps (most notably, JSX transform)</li>
  </ul>

  <p class="fragment"><br />
Install all of these with <code>--save-dev</code> since they&#39;re for building our project (not actual libraries that the app depends on).</p>
</section>

<section>
  <h2 id="webpack-everything">webpack Everything</h2>

  <p>Since we&#39;re using webpack (which relies on <code>require</code>s), we&#39;ll download local versions of React rather than relying on a hosted / CDN version.</p>

  <p>We can install with npm&#8230; remember to use <code>--save</code>)</p>

  <pre><code data-trim="" contenteditable="">
react
react-dom
</code></pre>

</section>

<section>
  <h2 id="setting-up-our-app-for-webpack">Setting up our App for webpack</h2>

  <p><strong>Let&#39;s modify where we place our code so that we can use webpack.</strong> &#8594;</p>

  <ol>
    <li>Move our code to external JavaScript</li>
    <li>Perhaps separate out our <strong>component</strong>, and the <strong>initial mounting of the component</strong></li>
    <li>Designate one of those files as the <strong>entry point</strong> &#8230;</li>
    <li>Add <code>require</code>s so that webpack knows what to put together</li>
  </ol>

  <pre><code data-trim="" contenteditable="">
PROJECT_DIR 
|
+-webpack.config.js // config options for webpack
|
+-client.js // entry point into our client side code
|
+-components
  |
  +-MyComponent.js // a single react component
</code></pre>
</section>

<section>
  <h2 id="our-bare-bones-page">Our Bare Bones Page</h2>

  <p>So&#8230; let&#39;s get rid of that inline JavaScript&#8230;</p>

  <ul>
    <li><strong>and assume that we&#39;ll have a single js file available to us once webpack is done generating assets for us.</strong> &#8594;</li>
    <li>(<code>bundle.js</code>) <strong>doesn&#39;t exist yet</strong>!</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
&#x3C;div id=&#x22;app&#x22;&#x3E;
&#x3C;/div&#x3E;
&#x3C;script src=&#x22;javascripts/bundle.js&#x22;&#x3E;&#x3C;/script&#x3E;
</code></pre>

  <p>Of course, we&#39;ll have to remember to <strong>tell webpack that our output should be <code>javascripts/bundle.js</code></strong>.</p>
</section>

<section>
  <h2 id="move-the-component-into-a-separate-file">Move the Component into a Separate File</h2>

  <p>Create a directory in our project folder that will contain all of our components. Drop our <code>MyComponent</code> code there. Remember to export it&#8230; to make it available when using <code>require</code>.</p>

  <p>In <code>components/MyComponent.js</code>:</p>

  <pre><code data-trim="" contenteditable="">
const React = require(&#x27;react&#x27;);
class MyComponent extends React.Component {
&#x9;render() {
&#x9;&#x9;return (
&#x9;&#x9;&#x9;&#x3C;h1&#x3E;Hello&#x3C;/h1&#x3E;
&#x9;&#x9;);
&#x9;}
}
module.exports = MyComponent;
</code></pre>

</section>
<section>
  <h2 id="our-entry-point">Our Entry Point</h2>

  <p>Our entry point will just be a file in the project directory called <code>client.js</code>. <strong>Within it, we can mount the component that we created to our DOM.</strong> &#8594;</p>

  <ul>
    <li><code class="highlighter-rouge">require</code> the React libraries</li>
    <li><code class="highlighter-rouge">require</code> our component</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
const React = require(&#x27;react&#x27;);
const ReactDOM = require(&#x27;react-dom&#x27;);
const MyComponent = require(&#x27;./components/MyComponent&#x27;);
ReactDOM.render(&#x3C;MyComponent /&#x3E;, document.getElementById(&#x27;app&#x27;));

</code></pre>

</section>
<section>
  <h2 id="webpack-configuration">Webpack Configuration</h2>

  <p>The webpack configuration file is called <code>webpack.config.js</code>. This will be in the root of your project directory.</p>

  <pre><code data-trim="" contenteditable="">
const path = require('path');
module.exports = {
  mode: 'development' // or production
  // configure the entry point
  // where to output the bundle of static assets
  // and configure the plugins / modules that we'll use
};
</code></pre>

  <p>This is the <em>entry point</em> into our client side web app&#8230; (anything that this file requires will be bundled by webpack)</p>

  <pre><code data-trim="" contenteditable="">
  entry: './client.js',
</code></pre>
</section>

<section>
  <h2 id="webpack-configuration-continued">webpack Configuration Continued</h2>

  <p>Specify where the resulting JavaScript file should go&#8230; (<code>javascripts/bundle.js</code>)</p>

  <pre><code data-trim="" contenteditable="">
  output: {
    path: path.join(__dirname, '/public', 'javascripts'),
    filename: 'bundle.js',
    publicPath:'/javascripts'
  },
</code></pre>

  <p><br /></p>

  <ul>
    <li><code>path</code> - where on the file system we&#39;re writing to</li>
    <li><code>filename</code> - name of resulting .js file</li>
    <li><code>publicPath</code> - the path where you&#39;re serving this file from (<code>http://localhost:3000/javascripts &lt;-- /javascripts</code>)</li>
  </ul>

</section>

<section>
  <h2 id="webpack--babel-configs">Webpack / Babel Configs</h2>

  <p><strong>Specify our loaders (the transformations we&#39;ll be using&#8230;)</strong> &#8594;</p>

  <ul>
    <li>this means&#8230; use babel for the transformation</li>
    <li>and the default configuration will be react specific (for example, transpile JSX)</li>
  </ul>

  <p><br /></p>

  <pre><code data-trim="" contenteditable="">
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: [/node_modules/, /"app.js/],
        loader: "babel-loader",
        options: {
          presets: ["react"]
        }
      }
    ]
  },
</code></pre>
</section>

<section>
  <h2 id="whew-finally">Whew. Finally</h2>

  <p>In the root of your project folder, just run webpack&#8230; aaand hopefully we&#39;ll find a new <code>js</code> file in <code>public/javascripts</code></p>

  <p class="fragment"><strong>Running webpack:</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
webpack
# magic
</code></pre>

  <p class="fragment"><strong>Checking if it created bundle.js:</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
ls public/javascripts
# hopefully bundle.js
</code></pre>

</section>

<section>
  <h2 id="lets-try-changing-our-component">Let&#39;s Try Changing Our Component</h2>

  <p>Ok&#8230; instead of hello, we&#39;ll change the text in our component. <strong>Let&#39;s see the output. What happened?</strong> &#8594;</p>

  <ul>
    <li class="fragment">nothing changed! <strong>why</strong> &#8594;</li>
    <li class="fragment">probably because <code>bundle.js</code> is still the same&#8230; <strong>what do we have to do?</strong> &#8594;
      <ul>
        <li class="fragment">ugh&#8230; we have to recompile with <code>webpack</code></li>
        <li class="fragment">(wait, what? are we working with C or Java, here&#8230; I thought this was JavaScript!?)</li>
      </ul>
    </li>
  </ul>

</section>

<section>
  <h2 id="automatically-rebuilding-on-change">Automatically Rebuilding on Change</h2>

  <p>Soooo&#8230; there are a lot of ways to automatically refresh the contents of <code>bundle.js</code>. We&#39;re going to use one that:</p>

  <ul>
    <li>skips the <em>actual</em> compilation to a file on disk</li>
    <li>and&#8230; instead, creates an in-memory version on file change</li>
    <li>and intercepts requests to the file using middleware (so that it picks up the in memory version rather than the one on the file system)</li>
  </ul>

</section>

<section>
  <h2 id="webpack-dev-middleware">Webpack Dev Middleware</h2>

  <p>We&#39;ll use <code>webpack-dev-middleware</code> to do this.</p>

  <ul>
    <li><strong>webpack-dev-middleware</strong> is express middleware that serves the files created from webpack</li>
    <li>however, instead of writing the files to disk, <strong>it just stores the file in memory</strong></li>
    <li>by default, it&#39;ll monitor the file system for changes, and if it does, it <strong>automatically rebuilds the in-memory JavaScript bundle</strong></li>
  </ul>

  <p><br /></p>

  <p>Install via npm&#8230;</p>

  <pre><code data-trim="" contenteditable="">
npm install --save-dev webpack-dev-middleware
</code></pre>
</section>

<section>
  <h2 id="integrating-webpack-dev">Integrating Webpack Dev</h2>

  <p>In <code>app.js</code> add the code below <strong>before the express static middleware</strong>.</p>

  <pre><code data-trim="" contenteditable="">
if(process.env.NODE_ENV === 'development') { 
    // configure webpack-dev-middlware with our original webpack config
    // then... "use" webpack-dev-middleware

    const webpackDevMiddleware = require("webpack-dev-middleware");
    const webpackConfig = require('./webpack.config.js')
    const webpack = require("webpack");
    const compiler = webpack(webpackConfig);
    app.use(webpackDevMiddleware(compiler, {
        publicPath:'/javascripts'
    }));
}
</code></pre>
</section>

<section>
  <h2 id="webpack-dev-notes">Webpack Dev Notes</h2>

  <p><strong>A few things about the webpack-dev-middleware integration&#8230;</strong> &#8594;</p>

  <ul>
    <li>notice that we&#39;re essentially just reading our <em>plain ol&#39;</em> webpack configuration</li>
    <li><code>publicPath</code> is the path in the url
      <ul>
        <li>(so <code>localhost:3000/javascripts</code> &lt;&#8211; <code>/javascripts</code>)</li>
        <li>should match what&#39;s in <code>webpack.config.js</code></li>
      </ul>
    </li>
    <li>you can see it rebuild the javascript bundle on your server&#39;s output</li>
    <li>we can even delete <code>bundle.js</code>, and we&#39;ll see that it all works out fine (since the in-memory version is being used)!</li>
    <li>as mentioned previously, <strong>put this before the express static middleware</strong>
      <ul>
        <li>otherwise&#8230; you&#39;ll <em>have</em> to delete <code>bundle.js</code></li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="dev-means-dev">Dev Means Dev</h2>

  <p>The example code is only active when there&#39;s an environment variable called <code>NODE_ENV</code> present and equal to <code>'development'</code>:</p>

  <ul>
    <li><code>if(<code>process.env.NODE_ENV === 'development') { ... }</code>)</code></li>
    <li>which means&#8230; only run the webpack dev middleware when we&#39;re in development, not production</li>
    <li>in production we should build the javascript once only, and serve the <em>compiled</em> files</li>
    <li>sooo &#8230; this means <strong>to start with the middelware enabled</strong>, we <em>must</em> use <code>NODE_ENV=development nodemon bin/www</code></li>
  </ul>
</section>
:ET