I"õ'<section class="intro-slide">
  <h1 id="mongoose">Mongoose</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="nosql-database-odm">NoSQL Database, ODM</h2>

  <p><strong>What&#39;s a NoSQL database again?</strong>?</p>

  <ul class="fragment">
    <li>a database that doesn&#39;t model data using tables and relations between those tables</li>
    <li>instead, usually a key value store</li>
    <li>or a document store</li>
  </ul>

  <p class="fragment"><br />
<strong>And what&#39;s an ODM?</strong> &#8594;</p>

  <ul class="fragment">
    <li>object document mapper</li>
    <li>maps application objects (objects in your code) to documents in your database
      <ul>
        <li>allows CRUD operations on those documents</li>
      </ul>
    </li>
  </ul>

  <p class="fragment"><br />
<strong>We&#39;re using MongoDB as our database and Mongoose as our ODM</strong></p>

</section>
<section>
  <h2 id="mongoose-1">Mongoose</h2>

  <div class="img">
    <p><img src="../../resources/img/mongoose.jpg" alt="mongoose" /></p>
  </div>
</section>

<section>
  <h2 id="vocabulary">Vocabulary</h2>

  <p><strong>What&#39;s a document&#8230; and what&#39;s a collection?</strong> &#8594;</p>

  <p class="fragment">In MongoDB</p>

  <ul class="fragment">
    <li><strong>document</strong> - a single row or object in your database (like&#8230; an instance of a pizza or cat)</li>
    <li><strong>collection</strong> - a group of documents, similar to a table in a relational database</li>
  </ul>

  <p class="fragment"><strong>What&#39;s a schema, model&#8230; and object?</strong> &#8594;</p>

  <p class="fragment">In Mongoose&#8230;</p>

  <ul class="fragment">
    <li><strong>schema</strong> - describes a collection, provides properties and other constraints (think class)</li>
    <li><strong>model</strong> - built from a schema, a constructor that allows you to create objects (think constructor for class)</li>
    <li><strong>objects/model instances</strong> - represent a document</li>
  </ul>

</section>

<section>
  <h2 id="schemas">Schemas</h2>

  <p>A schemas is analogous to a collection. We create a schema with the <code>mongoose.Schema</code> constructor.</p>

  <ul>
    <li>the convention is that your schema&#39;s name will match a lowercase, plural colleciton in your database</li>
    <li>the Schema constructor takes an object with keys as names of keys that the documents created from this schema will have</li>
    <li>&#8230;and values that represent the configuration of these keys (for example, type)</li>
  </ul>
</section>

<section>
  <h2 id="models">Models</h2>

  <p>Once you have a schema, you can then register a model. A model is a constructor for creating objects that represent MongoDB Documents.</p>

  <p>Instance Methods</p>

  <ul>
    <li><code>save</code> (create a new document)</li>
  </ul>

  <p>Static Methods</p>

  <ul>
    <li><code>find</code></li>
    <li><code>findOne</code></li>
    <li><code>findOneAndUpdate</code></li>
  </ul>

</section>

<section>
  <h2 id="slugs-and-plugins-slug-ins">Slugs and Plugins (Slug-ins?)</h2>

  <p>To add extra features to your schemas, you can use plug-ins.</p>

  <p>One plug-in, mongoose-url-slugs&#8230;</p>

  <ul>
    <li>can be used to generate a <strong>slug</strong> (human readable string that&#39;s unique for each document) for all of your objects</li>
    <li><strong>without having to manually specify slug in the schema!</strong></li>
  </ul>
</section>

<section>
  <h2 id="pizza">Pizza</h2>

  <p><strong>Let&#39;s try creating a schema for a pizza and toppings.</strong> &#8594;</p>

  <ul>
    <li>it should allow pizzas to have a size and crust</li>
    <li>it should associate pizzas with toppings</li>
    <li>the pizza should have a short-name (a slug)</li>
    <li>toppings should have a name, and some way of noting whether or not you&#39;d like &#39;extra&#39; toppings</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
{
	size: 'medium',
	crust: 'thin',
	slug: 'medium-thin-2'
	toppings: [{name:'mushroom', extra:true}, {name:'peppers'}]
}
</code></pre>
</section>

<section>
  <h2 id="lets-start-with-some-setup">Let&#39;s Start With Some Setup</h2>

  <p>Make sure that you have the required modules for connecting to the database&#8230; and creating a slug!</p>

  <ul>
    <li>mongoose</li>
    <li>mongoose-url-slugs</li>
  </ul>

  <p><br /></p>
  <pre><code data-trim="" contenteditable="">
npm install --save mongoose mongoose-url-slugs
</code></pre>

  <p>Require and connect&#8230;</p>

  <pre><code data-trim="" contenteditable="">
const mongoose = require('mongoose');
const URLSlugs = require('mongoose-url-slugs');

// more stuff goes here

mongoose.model('Pizza', Pizza);
mongoose.model('Topping', Topping);
mongoose.connect('mongodb://localhost/pizzadb');
</code></pre>
</section>

<section>
  <h2 id="types--embedded-documents">Types / Embedded Documents</h2>

  <ul>
    <li>one way to define relationships is to <strong>embed</strong> one document in another&#8230;
      <ul>
        <li>for example, this specifies that field Foo contains an Array / list of Bar objects</li>
        <li>Foo: [Bar]</li>
      </ul>
    </li>
    <li>additionally, instead of specifying the type outright, you can use an object that defines some field specifications:
      <ul>
        <li>type</li>
        <li>max</li>
        <li>min</li>
        <li>required</li>
        <li>default (for default value)</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <h2 id="your-schema">Your Schema</h2>

  <p>Schemas represent collections (tables). Notice the different ways of specifying the type of a field:</p>

  <pre><code data-trim="" contenteditable="">
const Topping = new mongoose.Schema({
	name: String,
	extra: {type: Boolean, default:false}
});

const Pizza = new mongoose.Schema({
	size: {type: String, enum: ['small', 'medium', 'large']},
	crust: String,
	toppings: [Topping]
});
</code></pre>

  <pre><code data-trim="" contenteditable="">
// note that we left out slug from the schema... 
// (the plugin will add it for you!)
// this should go before registering model!
Pizza.plugin(URLSlugs('size crust'));
</code></pre>
</section>

<section>
  <h2 id="models-1">Models</h2>

  <p>With mongoose, a model allows you to:</p>

  <ul>
    <li>create new instances and save them</li>
    <li>find saved instances (using a static method)</li>
    <li>update existing instances</li>
  </ul>

  <p><br /></p>
  <pre><code data-trim="" contenteditable="">
Pizza = mongoose.model('Pizza');
</code></pre>
</section>

<section>
  <h2 id="creating-and-saving">Creating and Saving</h2>

  <pre><code data-trim="" contenteditable="">
const pizza1 = new Pizza({
	size: 'small',
	crust: 'thin'
});

pizza1.save(function(err, pizza, count) {
	console.log('made me some pizza', pizza, count, err);
});

// call mongoose.disconnect() in callback function to close
// database connection;
</code></pre>
</section>

<section>
  <h2 id="finding--retrieving">Finding / Retrieving</h2>

  <p>Ok&#8230; just like the commandline client, we can use <strong>find</strong>:</p>

  <pre><code data-trim="" contenteditable="">
// find all (try with query/criteria)
Pizza.find(function(err, pizzas, count) {
	console.log(err, pizzas, count);
});
</code></pre>

  <p>Notice that we get back an Array!</p>
</section>
<section>
  <h2 id="finding-only-one">Finding Only One!</h2>

  <p><strong>But I only want one!</strong> Sometimes it&#39;s annoying to have to index into an Array if you only want one of something, so there&#39;s also <strong>findOne</strong> &#8594;</p>
  <pre><code data-trim="" contenteditable="">
// find only one (returns first)
Pizza.findOne({slug: 'small-2' }, function(err, pizza, count) {
	console.log(err, pizza, count);
});
</code></pre>
</section>

<section>
  <h2 id="finding-then-updating">Finding Then Updating</h2>

  <p>In Mongoose&#8230; instead of using the push operator (like in the commandline client), we have a method, <strong>push</strong>, that can be called on a property if it represents a list / Array of embedded values:</p>
  <pre><code data-trim="" contenteditable="">
// update one after finding (hello callbacks!)
Pizza.findOne({slug: 'small-2' }, function(err, pizza, count) {
    // we can call push on toppings!
	pizza.toppings.push({name: 'mushroom'});
	pizza.save(function(saveErr, savePizza, saveCount) {
		console.log(savePizza);	
	});
});
</code></pre>
</section>

<section>
  <h2 id="finding-then-updating-take-two">Finding Then Updating Take Two</h2>

  <p>But of course&#8230; we can <em>actually</em> use push in an update query. In this case, we&#39;re using <strong>findOneAndUpdate</strong> to do the find and update all at once!</p>

  <pre><code data-trim="" contenteditable="">
// find one and update it; maybe better than previous?
// ...notice $push?
Pizza.findOneAndUpdate({slug:'small-2'}, {$push: {toppings: {name:'peppers'}}}, function(err, pizza, count) {
	console.log(err, pizza, count);
});
</code></pre>
</section>
<section>
  <h2 id="finding-by-embedded-documents">Finding by Embedded Documents</h2>

  <p>We can also adjust our query to find by an embedded document. In this case, we use the property of the list of embedded documents&#8230; and use another object that describes the embedded document that we&#39;d like to match.</p>

  <pre><code data-trim="" contenteditable="">
Pizza.find({toppings: {name:'mushroom'}}, function(err, pizzas, count) {
	console.log(pizzas);
});
</code></pre>
</section>
<section>
  <h2 id="finding-and-updating-multiple-embedded-documents">Finding and Updating Multiple Embedded Documents</h2>

  <p>Notice that when we update an embedded document, before we save the parent, we have to let mongoose know that we made changes to embedded documents. (shrug)</p>

  <pre><code data-trim="" contenteditable="">
Pizza.findOne({slug:'small-2'}, function(err, pizza, count) {
	for (let i = 0; i &lt; pizza.toppings.length; i++) {
		pizza.toppings[i].extra = true;
	}
	pizza.markModified('toppings');
	pizza.save(function(err, modifiedPizza, count) {
		console.log(err, modifiedPizza);
	});
});
</code></pre>

  <p>(whew!)</p>
</section>
:ET