I"Y%<section class="intro-slide">
  <h1 id="networking-and-sockets">Networking and Sockets</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="some-definitions">Some Definitions</h2>

  <p>Before we start, we should probably get a few definitions out of the way!</p>

  <ul>
    <li><strong>ip address</strong> - number given to a computer / device on a network</li>
    <li><strong>port</strong> - a number given to a communication end point that usually represents some specific service&#8230; allowing multiple services to be run on the same device&#8230; an analogy from this <a href="http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html">guide to network programming</a> compares an ip address to a street address of a building, and a port to an apartment number in that building</li>
    <li><strong>socket</strong> - an endpoint to a connection&#8230; so there are two sockets per connection, but in network programming apis, a socket object is typically the object that mediates communication (reads/writes) to a connected client or server&#8230; <a href="http://stackoverflow.com/questions/152457/what-is-the-difference-between-a-port-and-a-socket">this SO article goes deep on sockets vs ports</a></li>
    <li><strong>localhost</strong> - 127.0.0.1 &#8230; or your <em>local</em> computer&#8230; when used as the domain name in <code class="highlighter-rouge">nc</code>, your browser, etc. &#8230; the connection is made from your computer to a service running on itself</li>
  </ul>

</section>
<section>
  <h2 id="net-module">net module</h2>

  <p>Node comes with a built in <code class="highlighter-rouge">net</code> module. It provides <strong>functions for creating servers and clients</strong>.</p>

  <p>The following creates a server that listens on port <code class="highlighter-rouge">8080</code>. It will log out the address and port that connected to it.</p>

  <p>(Details in following slide)</p>

  <pre><code data-trim="" contenteditable="">
const net = require('net');
const HOST = '127.0.0.1';
const PORT = 8080;

const server = net.createServer((sock) =&gt; {
    console.log(`got connection from ${sock.remoteAddress}:${sock.remotePort}`);
});

server.listen(PORT, HOST);
</code></pre>

</section>

<section>
  <h2 id="running-the-above-example">Running the Above Example</h2>

  <p>To run the above example, you&#39;ll have to have two terminal windows / tabs open.</p>

  <ol>
    <li>run <code class="highlighter-rouge">node myFile.js</code> in one window
      <ul>
        <li>this is your <strong>server</strong>, it&#39;s waiting for connections</li>
        <li>note that it&#39;ll look like terminal is <em>frozen</em> or waiting for <em>something</em></li>
        <li>anything you <code class="highlighter-rouge">console.log</code> out will be shown in this window</li>
        <li>to stop your server, use CTRL + c</li>
      </ul>
    </li>
    <li>in another terminal, use netcat as a client to connect to your server
      <ul>
        <li><code class="highlighter-rouge">nc localhost 8080</code></li>
        <li>you can type text that gets sent to the server&#8230;</li>
        <li>again, CTRL + c will close the client</li>
      </ul>
    </li>
  </ol>

</section>

<section>
  <h2 id="createserver">createServer</h2>

  <p><strong>The <code class="highlighter-rouge">createServer</code> function</strong>:</p>

  <ol>
    <li>can be called with one argument, a callback function specifying what to when a client connects
      <ul>
        <li>the callback has an argument, the &quot;socket&quot; that represents a &quot;connection&quot; to the client</li>
        <li>(though again, a socket conceptually is just an end point)</li>
      </ul>
    </li>
    <li>returns an instance of a <code class="highlighter-rouge">Server</code> object
      <ul>
        <li>this object can be bound to a port and address</li>
        <li>&#8230; so that it can start listening for client connections</li>
      </ul>
    </li>
  </ol>

</section>

<section>
  <h2 id="server-object-and-listen">Server Object and Listen</h2>

  <p><strong>Again, the server object has a <code class="highlighter-rouge">listen</code> method</strong> &#8594;</p>

  <ul>
    <li class="fragment">this tells the server to start accepting connections on the supplied port and hostname</li>
    <li class="fragment">127.0.0.1 is <em>localhost</em></li>
    <li class="fragment">if hostname is left out, it&#39;ll accept connections on <em>any</em> address (for example, binding to the current address of the machine that it&#39;s running on so that it&#39;s accessible outside of localhost)</li>
    <li class="fragment">leaving out the port number lets the os decide what the port number should be</li>
  </ul>

</section>

<section>
  <h2 id="socket-object-events">Socket Object Events</h2>

  <p><strong>You can specify what your server will do based on specific events by using the socket object that&#39;s passed in to your anonymous function / callback for initial connection.</strong></p>

  <p>Some examples of socket events include:</p>

  <ul>
    <li><code class="highlighter-rouge">data</code> - generated when socket receives data</li>
    <li><code class="highlighter-rouge">close</code> - generated when socket is closed</li>
  </ul>

  <p><br />
Use <code class="highlighter-rouge">someSocketObject.on(eventName, callback)</code> to specify what to do on these events.</p>
</section>

<section>
  <h2 id="on-data-and-on-close">On Data and On Close</h2>

  <p>Here&#39;s an example of logging out when a socket receives data&#8230; and when a socket is closed:</p>

  <pre><code data-trim="" contenteditable="">
// setup above
const server = net.createServer((sock) =&gt; {

    sock.on('data', (binaryData) =&gt; {
        console.log(`got data\n=====\n${binaryData}`);
    });

    sock.on('close', (data) =&gt; {
        console.log(`closed - ${sock.remoteAddress}:${sock.remotePort}`);
    });
});

// listen below
</code></pre>

  <p><br /></p>
</section>

<section>
  <h2 id="socket-on">Socket On&#8230;.</h2>

  <p>Let&#39;s take a closer look at one of these event handlers:</p>

  <pre><code data-trim="" contenteditable="">
sock.on('data', function(data) {
});
</code></pre>

  <p><br />
The callback function for <code class="highlighter-rouge">sock.on</code> has a single parameter, <code class="highlighter-rouge">data</code>, which represents the binary data sent to the server.</p>

  <ul>
    <li><code class="highlighter-rouge">data</code> is (usually) going to be a <code class="highlighter-rouge">Buffer</code> object</li>
    <li>a <code class="highlighter-rouge">Buffer</code> is just a representation of binary data (perhaps it&#39;s in this format because no encoding was specified!)</li>
    <li>you can call <code class="highlighter-rouge">toString</code> on a <code class="highlighter-rouge">Buffer</code> object which assumes <code class="highlighter-rouge">utf-8</code></li>
    <li>you can create a buffer from a string using <code class="highlighter-rouge">Buffer.from("some string", encoding)</code>, where encoding can be:
      <ul>
        <li><code class="highlighter-rouge">'utf8'</code></li>
        <li><code class="highlighter-rouge">'ascii'</code></li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="write-and-end">Write and End</h2>

  <p>Of course, you can also send data to the client with socket&#39;s <code class="highlighter-rouge">write</code> and <code class="highlighter-rouge">end</code> methods</p>

  <ol>
    <li><strong><code class="highlighter-rouge">write(data, encoding)</code></strong> - sends data back to the connected client
      <ul>
        <li>you can send back binary data (a buffer)</li>
        <li>or a string (which, by default uses utf-8 for encoding&#8230; otherwise specify by explicitly passing encoding)</li>
      </ul>
    </li>
    <li><strong><code class="highlighter-rouge">end</code></strong> - let&#39;s the client know that it wants to stop the connection
      <ul>
        <li>end also takes a single argument&#8230; which is just data to send just before closing  (like calling <code class="highlighter-rouge">write</code> then <code class="highlighter-rouge">end</code> consecutively)</li>
      </ul>
    </li>
  </ol>

  <p><br />
Example usage demonstrating a few writes, and then an end:</p>
  <pre><code data-trim="" contenteditable="">
sock.write('hello'); 
sock.write('how are you?'); 
sock.end('goodbye');  // lets client know connection will be closed 
// (there's also sock.destroy to close the connection immediately)
</code></pre>

</section>

<section>
  <h2 id="echo">Echo</h2>

  <p>Here&#39;s a server that just sends back the data that it is sent to it by the client. To have it disconnect after it gets data, uncomment <code class="highlighter-rouge">sock.end()</code>.</p>

  <pre><code data-trim="" contenteditable="">
// within create server
sock.on('data', function(binaryData) {
    console.log('got data\n=====\n' + binaryData); 
    sock.write(binaryData);

    // uncomment me if you want the connection to close
    // immediately after we send back data
    // sock.end();
});
</code></pre>
</section>

<section>
  <h2 id="some-things-to-try">Some Things to Try</h2>

  <ol>
    <li>point your browser to your server!</li>
    <li>check out what data you receive</li>
    <li>is that data meaningful?</li>
    <li>how can you extract information from it?</li>
    <li>try sending stuff back to the browser!</li>
  </ol>

</section>

:ET