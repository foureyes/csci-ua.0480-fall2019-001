I"ßF<section class="intro-slide">
  <h1 id="objects">Objects</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="topics">Topics</h2>

  <ul>
    <li>Objects, Object Creation</li>
    <li>Properties</li>
    <li>Methods</li>
    <li>Math Methods</li>
    <li>Modifying and Deleting Properties</li>
    <li>Mutability</li>
    <li>Detecting Properties</li>
    <li>Looping Over Objects</li>
  </ul>
</section>
<section>
  <h2 id="types-again-according-to-the-specification">Types (Again) According to the Specification</h2>

  <p><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8">The ECMAScript 5 specifications list 6 types, but they&#39;re not the ones that typeof returns</a> (of course!):</p>

  <ul>
    <li><code>Undefined</code></li>
    <li><code>Null</code></li>
    <li><code>Boolean</code></li>
    <li><code>String</code></li>
    <li><code>Number</code></li>
    <li><code>Object</code></li>
    <li>We didn&#39;t talk about this, but also&#8230; <code>Symbol</code> (ES6)</li>
  </ul>

</section>

<section>
  <h2 id="ok-so-what-about-typeof">Ok&#8230; So What About typeof?</h2>

  <ol class="fragment">
    <li>number</li>
    <li>string</li>
    <li>boolean</li>
    <li>object</li>
    <li>function</li>
    <li>undefined</li>
  </ol>

</section>

<section>
  <h2 id="the-one-we-havent-talked-about-">The One We Haven&#39;t Talked About &#8230;</h2>

  <p>We&#39;ve explored <code>numbers</code>, <code>strings</code>, <code>booleans</code>, <code>undefined</code> and <code>functions</code> a bit, but we haven&#39;t really talked about <strong>objects</strong> yet.</p>

  <div class="fragment">
    <p><strong>Objects</strong> are essentially:</p>

    <ul>
      <li>an &quot;arbitrary collections of properties&quot;</li>
      <li>&#8230;and their associated values</li>
      <li>these properties can be added, removed and modified</li>
    </ul>

    <p><br />
<strong>Can anyone think of analogous types in other languages?</strong> &#8594;</p>

    <ul class="fragment">
      <li><strong>HashMaps</strong> in Java</li>
      <li><strong>associative arrays</strong> in PHP</li>
      <li><strong>dictionaries</strong> in Python</li>
      <li><strong>Hashes</strong> in Ruby</li>
    </ul>

    <p><br />
(Note that ES6 introduces a <code class="highlighter-rouge">Map</code> data structure because objects carry excess baggage, such as inherited properties, with them, making them poor substitutes for <em>actual</em> maps)</p>

  </div>
</section>

<section>
  <h2 id="creating-objects">Creating Objects</h2>

  <p>Here&#39;s an example of an object:</p>

  <pre><code data-trim="" contenteditable="">
const course = {name:'AIT', section:8, undergraduate:true};
</code></pre>

  <p><strong>Object literals</strong> consist of:</p>

  <ul>
    <li>surrounding curly braces - <code>{}</code>
      <ul>
        <li>an empty object is just <code>{}</code></li>
      </ul>
    </li>
    <li>property/value pairs separated by commas - <code>,</code></li>
    <li>properties and values separated from each other with a colon - <code>:</code>
      <ul>
        <li><strong>properties that aren&#39;t valid variables names or valid numbers must be quoted</strong></li>
        <li>for example: <code>{"still a property name":true}</code></li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="object-literals-continued">Object Literals Continued&#8230;</h2>

  <h3 id="ah-thats-better">Ah, that&#39;s better.</h3>

  <p><strong>Internal white space and newlines won&#39;t cause any syntax issues.</strong> &#8594;</p>

  <ul>
    <li>you could use them for formatting</li>
    <li>indentation also helps with readability</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
const course = {
    name:'Applied Internet Technology',
    section:8,
    undergraduate:true
};
</code></pre>
</section>

<section>
  <h2 id="properties">Properties</h2>

  <ul>
    <li><strong>properties can be any value</strong>, including numbers, strings, and booleans</li>
    <li>they can also contain other objects&#8230; <strong>even functions</strong></li>
    <li>a <strong>method</strong> is a <strong>property that contains a function</strong></li>
    <li><strong>almost all JavaScript values have properties</strong>
      <ul>
        <li>the only exceptions are <code>null</code> and <code>undefined</code></li>
        <li>strings, numbers and booleans <em>act like they have properties</em></li>
      </ul>
    </li>
    <li>which implies that <strong>almost everything in JavaScript is an object</strong> (or again, <em>acts like</em> an object for some values)!</li>
  </ul>
</section>

<section>
  <h2 id="es6-shorthand-property-names">ES6 Shorthand Property Names</h2>

  <p><strong>There&#39;s also a shortcut to creating properties and values if you already have variables defined.</strong>  &#8594;</p>

  <ul>
    <li>In ES6&#8230;</li>
    <li>creating an object that consists of only variable names</li>
    <li>will initialize an object with those variable names as properties</li>
  </ul>

  <p><br /></p>

  <pre><code data-trim="" contenteditable="">
const a = 'foo';
const b = 'baz';
const obj = { a, b};
console.log(obj)
</code></pre>

</section>

<section>
  <h2 id="accessing-properties">Accessing Properties</h2>

  <p>Sooo&#8230; how do we access properties? Using our previous object:</p>

  <pre><code data-trim="" contenteditable="">
const course = {
    name:'Applied Internet Technology',
    section:8,
    undergraduate:true
};
</code></pre>

  <p>There are two ways to access properties:</p>

  <ul>
    <li>the <strong>dot operator</strong></li>
  </ul>
  <pre class="fragment"><code data-trim="" contenteditable="">
// gives us 8
console.log(course.section);
</code></pre>
  <ul>
    <li><strong>square brackets</strong></li>
  </ul>
  <pre class="fragment"><code data-trim="" contenteditable="">
// gives us 8
console.log(course["section"]);
</code></pre>
</section>

<section>
  <h2 id="accessing-properties-continued">Accessing Properties Continued</h2>

  <p><strong>What&#39;s the difference between the two ways of accessing properties?</strong> &#8594;</p>
  <pre><code data-trim="" contenteditable="">
course.section;
course["section"];
</code></pre>

  <ul>
    <li>when using <strong>dot</strong>, the part after the <strong>dot</strong> directly names the property
      <ul>
        <li>the property name must adhere to the rules of valid variables names.<br />
  (<strong>what were they again?</strong> &#8594;)</li>
        <li class="fragment">start with a <strong>letter</strong>, <strong>underscore</strong> ( <code>_</code> ), or <strong>dollar</strong> ( <code>$</code> ) <!--_ --></li>
        <li class="fragment">following characters can be any of above, and/or <strong>digits (0-9)</strong></li>
      </ul>
    </li>
    <li>when using <strong>square brackets</strong>, the part within the brackets is evaluated and is used as the property name
      <ul>
        <li>this allows for <em>dynamically</em> created property names</li>
        <li>also allows property names that are not valid variable names <code>obj["I'm ok"] = true</code> (oof, maybe avoid that))</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="dynamic-properties">Dynamic Properties</h2>

  <p><strong>To clarify the use of brackets for property access, let&#39;s examine this scenario. The code below&#8230;</strong> &#8594;</p>

  <ol>
    <li>asks for user input, specifying a key / property name</li>
    <li>and <em>should</em> output the value at the key</li>
  </ol>

  <pre><code data-trim="" contenteditable="">
// using the same object from previous slides...
const course = { name:'Applied Internet Technology', section:8, undergraduate:true };
</code></pre>

  <pre><code data-trim="" contenteditable="">
// setting up user input
const readline = require('readline');
const p = readline.createInterface({ input: process.stdin, output: process.stdout });
p.question('Type in an object key\n&gt;', function (resp) {
	// TODO: print value at key
    p.close();
});
</code></pre>

  <p class="fragment">Here, we have to use bracket notation: <code class="highlighter-rouge">console.log(course[resp])</code>.</p>
</section>

<section>
  <h2 id="hey-wait">Hey Wait&#8230;</h2>

  <p>Let&#39;s see some examples of these <em>so called</em> properties (and methods) on some values that we&#39;ve already seen. <strong>Can you recall any?</strong> &#8594;</p>

  <ul>
    <li class="fragment">length is a property of both Strings and Arrays</li>
  </ul>
  <pre class="fragment"><code data-trim="" contenteditable="">
var exclamation = 'wow!',
    listOfExclamations = ['golly!', 'gosh!'];
console.log(exclamation.length, listOfExclamations.length)
</code></pre>
  <ul>
    <li class="fragment">log is a method of the built-in, global <strong>console</strong> object</li>
  </ul>
  <pre class="fragment"><code data-trim="" contenteditable="">
console.log("here's one!")
</code></pre>
</section>

<section>
  <h2 id="methods-again">Methods (Again)</h2>

  <p>It&#39;s worthwhile to repeat that <strong>an object property can be a function</strong>.</p>

  <ul>
    <li>if object&#39;s property is a function, it&#39;s sometimes called a <strong>method</strong></li>
    <li>let&#39;s try creating some methods&#8230;</li>
  </ul>

  <pre class="fragment"><code data-trim="" contenteditable="">
const obj = {};
function f() {
    console.log("Hi, I'm a method!");
}
obj.doStuff = f;
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
const obj = {
    doStuff: function() {
        console.log("Hi, I'm a method!");    
    },
};
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
const obj = {};
obj.doStuff = function() {
    console.log("Hi, I'm a method!");    
};
</code></pre>

</section>

<section>
  <h2 id="es6-shorthand-methods">ES6 Shorthand Methods</h2>

  <p>It&#39;s pretty <strong>common to create methods on objects</strong>, so <strong>ES6 introduces a shortcut for creating methods on objects</strong> simply by setting properties equal to function expressions: &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const obj = {
    f() {console.log('fffff!');},
    g() {console.log('ggggg!');},
};
obj.f();
obj.g();
</code></pre>

  <p class="fragment">Contrast this with the ES5 way of creating methods:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const obj = {
  f: function() {console.log('fffff!');},
  g: function() {console.log('ggggg!');},
};
</code></pre>
</section>

<section>
  <h2 id="whew-back-to-objects-the-math-one">Whew. Back to Objects. The Math One</h2>

  <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">There are a bunch of built-in objects that are available globally</a>. We&#39;ve already seen some&#8230; like the <code>console</code> object or the <code>isNan()</code> and <code>parseInt</code> functions.</p>

  <p>There&#39;s also the built-in <code>Math</code> object. It provides a bunch of miscellaneous <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math#Methods">number crunching methods</a>&#8230;</p>

  <ul>
    <li>the usual trig functions like <strong>sin</strong>, <strong>cos</strong>, etc.</li>
    <li>of course, <strong>ceil</strong> and <strong>floor</strong> (don&#39;t know? <strong>let&#39;s try</strong> &#8594;) to round up or down</li>
    <li>&#8230;and the related <strong>round</strong></li>
    <li><strong>random</strong> - returns a random number between 0 and 1</li>
  </ul>
</section>

<section>
  <h2 id="reading-modifying-and-deleting">Reading, Modifying and Deleting</h2>

  <ul>
    <li><strong>if the property doesn&#39;t exist</strong>, we&#39;ll get back <code>undefined</code>:</li>
  </ul>
  <pre><code data-trim="" contenteditable="">
// &rarr; gives us undefined
console.log(course.nothingToSeeHere);
</code></pre>
  <ul>
    <li>you can assign values to properties by using the <strong><code>=</code> operator</strong>:</li>
  </ul>
  <pre><code data-trim="" contenteditable="">
course.nothingToSeeHere = 'maybe something';
console.log(course.nothingToSeeHere);
</code></pre>
  <ul>
    <li>you can remove properties by using the <strong>delete operator</strong>:</li>
  </ul>
  <pre><code data-trim="" contenteditable="">
delete course.nothingToSeeHere;
console.log(course.nothingToSeeHere);
</code></pre>

</section>

<section>
  <h2 id="objects-and-mutability">Objects and Mutability</h2>

  <p><strong>Uh&#8230; so what&#39;s the implication here regarding objects and mutability?</strong> &#8594;</p>

  <ul>
    <li class="fragment">clearly <strong>objects are mutable</strong>
      <ul>
        <li>functions are objects; they&#39;re mutable too!</li>
        <li>arrays are objects; they&#39;re mutable too (we&#39;ll see this again later)!</li>
      </ul>
    </li>
    <li class="fragment">primitives (such as numbers, strings, booleans, null, and undefined) are not, though!</li>
  </ul>
</section>

<section>
  <h2 id="mutability-and-references">Mutability and References</h2>

  <p><strong>What will this print out?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
const a = {'foo':1, 'bar':2};
const b = a;
b['baz'] = 3;
b.qux = 4;
console.log(a);
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
{ foo: 1, bar: 2, baz: 3, qux: 4 }
</code></pre>

</section>

<section>
  <h2 id="detecting-properties">Detecting Properties</h2>

  <p>Note that if a property doesn&#39;t exist, reading that property yields <code>undefined</code>.</p>

  <p><strong>Why might this be confusing?</strong> &#8594;</p>

  <p class="fragment">How can we distinguish between a property that actually exists, but is intentionally <code>undefined</code> versus a property that doesn&#39;t actually exist?</p>

</section>

<section>
  <h2 id="detecting-properties-continued">Detecting Properties Continued</h2>

  <p>There are two ways to determine if a property actually exists (rather than being undefined by default). Using the <code>course</code> object from before:</p>

  <ul>
    <li class="fragment"><strong>hasOwnProperty</strong> - method on all objects that tests if argument is property of object that hasOwnProperty is called on</li>
    <li class="fragment">
      <pre><code data-trim="" contenteditable="">
course.hasOwnProperty('name'); // true
course.hasOwnProperty('oh no, not here'); // false
</code></pre>
    </li>
    <li class="fragment"><strong>in</strong> - an operator that tests if left operand (a string or number) is property of object in right operand&#8230; picks up &quot;inherited&quot; properties</li>
    <li class="fragment">
      <pre><code data-trim="" contenteditable="">
'name' in course; // true
'oh no, not here' in course; // false
</code></pre>
    </li>
  </ul>

  <p><br /></p>

  <p class="fragment"><strong>Use hasOwnProperty for now&#8230; so you won&#39;t have to worry about &quot;inherited&quot; properties.</strong></p>
</section>

<section>
  <h2 id="looping-over-properties">Looping Over Properties</h2>

  <p><strong>Use a <code>for (const prop in obj)</code> loop:</strong> &#8594;</p>

  <ul>
    <li class="fragment">note that prop can be <code class="highlighter-rouge">const</code> declared</li>
    <li class="fragment">make sure that you use <code class="highlighter-rouge">obj</code>.<strong>hasOwnProperty</strong> in loop to exclude <em>inherited</em> properties</li>
    <li class="fragment">avoid using this kind of loop for <code>Arrays</code>
      <ul>
        <li>does not preserve order</li>
      </ul>
    </li>
  </ul>

  <pre class="fragment"><code data-trim="" contenteditable="">
for (const property in course) {
	if (course.hasOwnProperty(property)) {
		console.log(property +  " is " + course[property]);
	}
}
</code></pre>
</section>
<section>
  <h2 id="some-behind-the-scenes">Some Behind the Scenes</h2>

  <p>In reality, though, <code>strings</code>, <code>numbers</code> and <code>booleans</code> aren&#39;t objects; they&#39;re <strong>primitives</strong> (you know, kind of like Java).</p>

  <p>However, as soon as you perform an <em>object-like</em> operation on them, such as a method call:</p>

  <ul>
    <li><strong>JavaScript creates an actual String, Number or Boolean object that wraps that primitive&#8230;</strong></li>
    <li>and throws it away immediately, once the operations is done</li>
    <li>this does mean, however, that <strong>you can&#39;t create arbitrary properties on primitives</strong></li>
  </ul>

  <p><br /></p>

  <p><a href="http://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/">See this article on the <em>secret</em> life of JavaScript primitives!</a></p>
</section>

<section>
  <h2 id="and-finally-json">And Finally&#8230; JSON</h2>

  <p><strong>JSON or <em>JavaScript Object Notation</em> is a data storage and communication format</strong> based off of JavaScript object literals&#8230; but with a few modifications:</p>

  <ul>
    <li class="fragment">all property names are surrounded by <strong>double quotes</strong></li>
    <li class="fragment">values are restricted to <strong>simple data</strong>: no function calls, variables, comments or computations</li>
  </ul>

  <p class="fragment"><br />
Conversion to-and-from JSON can be done using the following methods on the built-in JSON object:</p>

  <ul class="fragment">
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code class="highlighter-rouge">stringify(value)</code></a> - returns a JSON string representation of the value passed in</li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code class="highlighter-rouge">parse(text)</code></a> - returns an object created from the supplied JSON text</li>
    <li>for example: <code class="highlighter-rouge">JSON.parse("[1, 2, 3]")</code></li>
  </ul>

</section>

:ET