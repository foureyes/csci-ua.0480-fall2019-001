I"Ä<section class="intro-slide">
  <h1 id="where-not-to-use-arrow-functions">Where Not to Use Arrow Functions</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>
<section>
  <h2 id="arrow-functions-are-useful">Arrow Functions are Useful!</h2>

  <p>In arrow functions, <code class="highlighter-rouge">this</code> is whatever <code class="highlighter-rouge">this</code> refers to in the context where the arrow function was created. So, the code below, which produces a bunch of <code class="highlighter-rouge">undefined</code>&#39;s,  <strong>can be fixed by converting the anonymous function into an arrow function</strong>. &#8594;</p>

  <pre><code data-trim="" contenteditable="">
const counter = {numbers: [1, 2, 3, 4], animal:'owl'};
counter.count = function() {
    this.numbers.forEach(function(n) {
        console.log(n, this.animal + (n &gt; 1 ? 's' : ''));
    });
};
counter.count(); // uh-oh... prints undefined 4 times!!!!
</code></pre>

  <p class="fragment"><strong>Fixed by arrow functions:</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
counter.count = function() {
    this.numbers.forEach((n) =&gt; {
        // this refers to the this in count!
        console.log(n, this.animal + (n &gt; 1 ? 's' : ''));
    });
}; // ah, saved by an arrow function
</code></pre>
</section>

<section>
  <h2 id="where-not-to-use-arrow-functions-1">Where <em>Not</em> to Use Arrow Functions</h2>

  <p>Well, if arrow functions are so great, <strong>why don&#39;t we use arrow functions all of the time?</strong> &#8594;</p>

  <p class="fragment"><strong>There are some places where they don&#39;t work quite right.</strong></p>

  <ul>
    <li class="fragment">creating constructors</li>
    <li class="fragment">creating methods
      <ul>
        <li class="fragment">either on object literals</li>
        <li class="fragment">or on prototypes</li>
      </ul>
    </li>
    <li class="fragment">(not relevant now, but) creating <code class="highlighter-rouge">addEventListener</code> callbacks where you want <code class="highlighter-rouge">this</code> to refer to the element that generated the event</li>
  </ul>

  <p class="fragment"><br />
<strong>But why not?</strong> &#8594;</p>

  <p class="fragment">Remember, arrow functions do not bind <code class="highlighter-rouge">this</code> to a new value, and instead gets its <code class="highlighter-rouge">this</code> from the enclosing scope</p>
</section>

<section>
  <h2 id="arrow-functions-cannot-be-constructors">Arrow Functions Cannot be Constructors</h2>

  <p><strong>In the following code, we try to use an arrow function as a constructor.</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
const Cat = (name) =&gt; {
    this.name = name;
}
</code></pre>

  <p>Creating the function works fine, but if we try to use it with <code class="highlighter-rouge">new</code>:</p>

  <pre><code data-trim="" contenteditable="">
var c = new Cat();
</code></pre>

  <p>We get&#8230;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
var c = new Cat();
        ^
TypeError: Cat is not a constructor
</code></pre>

  <p class="fragment">Instead, use the usual function declaration to create constructors:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function Cat(name) {
    this.name = name;
}
</code></pre>

</section>

<section>
  <h2 id="arrow-functions-as-methods">Arrow Functions as Methods</h2>

  <p><strong>What is the output of this code?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
function Cat(name) {
    this.name = name;
}
Cat.prototype.meow = (() =&gt; {
    console.log(this.name, 'meows');
});
var c = new Cat('paw newman');
c.meow();
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
undefined meows
</code></pre>

  <ul>
    <li class="fragment">&#8230;because arrow functions do not bind a new value to <code class="highlighter-rouge">this</code></li>
    <li class="fragment">again, <code class="highlighter-rouge">this</code> remains the same as the <code class="highlighter-rouge">this</code> in the containing context / scope</li>
    <li class="fragment">(which, in this case is the global object)</li>
  </ul>
</section>

<section>
  <h2 id="arrow-functions-as-methods-on-object-literals">Arrow Functions as Methods on Object Literals</h2>

  <p><strong>What&#39;s the output of this code?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">const cat = {
    sound: 'meow',
    meow: () =&gt; {console.log(this.sound);}
};
cat.meow();
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
// once again...
undefined
</code></pre>
</section>
<section>
  <h2 id="arrow-functions-and-addeventlistener">Arrow Functions and <code class="highlighter-rouge">addEventListener</code></h2>

  <p><strong>To be complete&#8230; be careful when using arrow functions and <code class="highlighter-rouge">addEventListener</code></strong> &#8594;</p>

  <p>Starting with this code:</p>
  <pre><code data-trim="" contenteditable="">
const button = document.createElement('button');
document.body.appendChild(button).textContent = 'Click Me';
</code></pre>

  <p class="fragment">The following listeners alert different messages!</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
// alerts window object (essentially global)
button.addEventListener('click', () =&gt; {alert(this)});
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
// alerts button element
button.addEventListener('click', function()  {alert(this)});
</code></pre>

  <ul>
    <li class="fragment">if you want <code class="highlighter-rouge">this</code> in your event handler to reference the element event&#39;s target element, then use function expressions</li>
    <li class="fragment">&#8230;because arrow functions don&#39;t create their own <code class="highlighter-rouge">this</code>, and instead use the this from the surrounding context</li>
  </ul>

</section>

:ET