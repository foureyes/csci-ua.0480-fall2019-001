I"Fr<section class="intro-slide">
  <h1 id="socketio">socket.io</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="its-time-to-get-realtime">It&#39;s Time to Get Real(time)</h2>

  <p>In all of our web applications so far (with the exception the client-side only app)&#8230;</p>

  <p><strong>We&#39;ve always had to ask the server if there was new information or data.</strong> &#8594;</p>

  <ul>
    <li class="fragment">the server couldn&#39;t push information to the browser without being asked first</li>
    <li class="fragment">that&#39;s the way http (well, 1.1) works (it&#39;s a request / response protocol)</li>
    <li class="fragment">it&#39;s kind of <a href="http://i.stack.imgur.com/TK1ZG.png">like this</a>, right? (thanks for <a href="http://stackoverflow.com/questions/11077857/what-are-long-polling-websockets-server-sent-events-sse-and-comet">the diagrams</a>, Stack Overflow)</li>
  </ul>
</section>

<section>
  <h2 id="so-what">So What?</h2>

  <p><strong>What are the consequences of the client not being able to be updated for a user&#39;s experience on an application that relies changing data?</strong> &#8594; (like&#8230; say a chat application, a stock ticker, or a game)</p>

  <ul>
    <li class="fragment">the user doesn&#39;t see the data unless they ask for it</li>
    <li class="fragment">the data that a user sees gets stale / out of date</li>
    <li class="fragment">it&#39;s not <em>real time</em></li>
  </ul>

</section>

<section>
  <h2 id="we-can-fake-real-time-though">We Can Fake Real Time Though</h2>

  <p>Our attempt at making a <em>chat application</em> looked pretty real time, though. <strong>How did that work again?</strong> &#8594;</p>

  <ul>
    <li class="fragment">we used <strong>AJAX polling</strong>&#8230;</li>
    <li class="fragment">we loaded the initial page</li>
    <li class="fragment">in the background, we used JavaScript to continually ask if there were any new messages (approximately every 500 ms! &#8230; looks realtime enough ,right?)</li>
    <li class="fragment">still http based (request / response)</li>
  </ul>

</section>

<section>
  <h2 id="ajax-polling">AJAX Polling</h2>

  <p><strong>AJAX Polling</strong> is totally a fine solution, and may actually be the optimal solution based on the problem at hand. <strong>But there are some drawbacks.</strong> &#8594;</p>

  <ul>
    <li class="fragment">there still could be delays! it&#39;s not <em>actually</em> realtime, so if you can&#39;t have lag, this isn&#39;t the way to go</li>
    <li class="fragment">that&#39;s a lot of requests / responses! kind of not really that efficient</li>
    <li class="fragment">it <a href="http://i.stack.imgur.com/qlMEU.png">looks like this</a></li>
  </ul>
</section>

<section>
  <h2 id="techniques-for-realtime-or-near-realtime-communication">Techniques for Realtime (or Near Realtime) Communication</h2>

  <p>So&#8230; there are actually a bunch of ways to have (or at least mimic) realtime communication between a client and a server. We know the first one, of course!</p>

  <ul>
    <li><strong>AJAX Polling</strong></li>
    <li><strong>Long Polling</strong></li>
    <li><strong>Server-Sent Events</strong></li>
    <li><strong>Web Sockets</strong></li>
  </ul>

</section>

<section>
  <h2 id="long-polling">Long Polling</h2>

  <p><strong>Long Polling</strong> is actually just a slight variation on the regular polling technique from before.</p>

  <ul>
    <li>like regular polling, long polling isn&#39;t actually realtime, it just fakes it</li>
    <li>it polls as well, but less frequently</li>
    <li>when the server receives a request it immediately returns new data if it&#39;s available</li>
    <li>however, if there&#39;s no new data to return, it keeps the connection open, and returns the data once it becomes available</li>
    <li>once the client receives data, it immediately sends another request to the server again</li>
    <li>it&#39;s still over http</li>
    <li><a href="http://i.stack.imgur.com/ziR5h.png">it looks like this</a></li>
  </ul>
</section>

<section>
  <h2 id="server-side-events">Server Side Events</h2>

  <p><strong>Server Side Events, or SSEs</strong> allow servers to push data to their clients!</p>

  <ul>
    <li>still over http</li>
    <li>after the initial page is loaded&#8230;</li>
    <li>in the background, JavaScript connects to the server</li>
    <li>the connection remains open, and the server is able to <em>push</em> data</li>
    <li>the client can&#39;t send data back to the server</li>
    <li><a href="http://i.stack.imgur.com/ziR5h.png">here&#39;s what it looks like</a></li>
  </ul>
</section>

<section>
  <h2 id="web-sockets">Web Sockets</h2>

  <p>Finally, there&#39;s <strong>WebSocket</strong>. <strong>It&#39;s not HTTP</strong>.  <strong>WebSocket</strong> is actually <strong>another protocol</strong>. It allows simultaneous communication in both directions (that is, it&#39;s <em>full duplex</em>).</p>

  <ul>
    <li>designed to be <em>implemented</em> by both browsers and servers</li>
    <li>it&#39;s independent from HTTP</li>
    <li>however, the initial page is still loaded using HTTP</li>
    <li>but after that, the page uses JavaScript to create a two way connection with the server (there&#39;s a point where the protocol is <em>upgraded</em> from HTTP to Web Sockets)</li>
    <li>the server and client can send messages to each other freely!</li>
    <li><strong>allows cross origin communication</strong> (though, possibly at the cost of security!)</li>
    <li><a href="http://i.stack.imgur.com/CgDlc.png">here&#39;s what it looks like</a></li>
  </ul>
</section>

<section>
  <h2 id="web-sockets-continued">Web Sockets Continued</h2>

  <p>Web Sockets are <strong>great</strong>! They&#39;re pretty much the <em>real</em> deal when it comes to <em>real</em> time communication. The server and client can send data whenever they want! There are a few drawbacks, though:</p>

  <ul>
    <li>both the server and the client have to support an entirely new, and additional protocol</li>
    <li>as a protocol, it&#39;s more complex than HTTP (but, fortunately, we don&#39;t really have to deal with implementation details)</li>
  </ul>
</section>

<section>
  <h2 id="socketio-1">Socket.IO</h2>

  <p>So&#8230; that&#39;s quite a few competing technologies! Instead of choosing a single one, let&#39;s use a library that supports multiple techniques. <strong>Let&#39;s use Socket.IO</strong> &#8594;</p>

  <p class="fragment"><strong>Socket.IO</strong> is a library for realtime web applications.</p>

  <ul class="fragment">
    <li>it has both a server side and a client side component</li>
    <li>both have very similar APIs (<em>nice</em>)</li>
    <li>it&#39;s event driven</li>
    <li>behind the scenes, it primarily uses Web Sockets, but it can fall back to polling (maybe the server or client doesn&#39;t support Web Sockets)</li>
    <li>(though that&#39;s hidden away, as it <em>really</em> uses its own protocol that works on top of these)</li>
  </ul>
</section>

<section>
  <h2 id="socketio-continued">Socket.IO Continued</h2>

  <p>Again, Socket.IO is made up of two parts:</p>

  <ul>
    <li>a server that mounts on or attaches to Node&#39;s HTTP Server</li>
    <li>a client-side library that allows interaction with the server</li>
  </ul>

</section>
<section>
  <h2 id="socketio-client-and-server-api">Socket.IO Client and Server API</h2>

  <p>Both the client and server parts essentially do the same thing:</p>

  <ul>
    <li>allow the sending (or emitting) of events</li>
    <li>provide a way to define event handlers</li>
  </ul>
</section>

<section>
  <h2 id="setting-up-the-socketio-server-component">Setting up the Socket.IO Server Component</h2>

  <p><strong>The general steps for working on the server-side with Socket-IO are:</strong> &#8594;</p>

  <ul>
    <li class="fragment">create a Socket.IO server and attach it to your existing HTTP server</li>
    <li class="fragment">define what the server will do on connection</li>
    <li class="fragment">within that connection handler:
      <ul>
        <li class="fragment">define what the server will handle other <em>custom</em> events</li>
        <li class="fragment">emit messages</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="setting-up-socketio-on-the-client">Setting up Socket.IO on the Client</h2>

  <p><strong>To get the client portion of Socket.IO working:</strong> &#8594;</p>

  <ul>
    <li class="fragment">bring in the client side library</li>
    <li class="fragment">create a socket object (an interface to the connection)</li>
    <li class="fragment">use that socket object to:
      <ul>
        <li class="fragment">send messages</li>
        <li class="fragment">define callbacks that get triggered on specific events</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="notes-about-the-available-objects">Notes About the Available Objects</h2>

  <p>On the server, you&#39;ll be using these two objects to send messages to clients and to handle events from clients.:</p>

  <ul>
    <li>a <a href="http://socket.io/docs/server-api/#server">Server object</a> (a convention is to name this io)
      <ul>
        <li></li>
      </ul>
    </li>
    <li>a <a href="http://socket.io/docs/server-api/#socket">Socket object</a> - the main object used for interacting with the browser</li>
  </ul>

  <p><br /></p>

  <p>On the client:</p>

  <ul>
    <li>you&#39;ll get a global <a href="http://socket.io/docs/client-api/#client-api">IO object</a> that allows you to create a Socket object</li>
    <li>your client-side <a href="http://socket.io/docs/client-api/#socket">Socket object</a> let&#39;s you communicate with the server</li>
  </ul>
</section>
<section>
  <h2 id="some-server-functions">(Some) Server Functions</h2>

  <p>The <code class="highlighter-rouge">Server</code> object represents socket.io server. Instantiate it by:</p>

  <pre><code data-trim="" contenteditable="">
const io = require('socket.io')();
</code></pre>

  <p>Some methods that you can call on it are:</p>

  <ul>
    <li><strong><code>io.on('event name', callback)</code></strong>
      <ul>
        <li class="fragment">register a callback to handle a server event</li>
        <li class="fragment">callback takes a socket as a param; socket is an object that allows interaction with a connected client</li>
        <li class="fragment">start off by defining what to do on the &#39;connect&#39; event</li>
      </ul>
    </li>
    <li><strong><code>io.emit('event name', 'message')</code></strong> (or <code>io.sockets.emit('event name', 'message')</code>)
      <ul>
        <li class="fragment">send a message to all connected clients (including the one that is on the <em>current</em> socket!)</li>
        <li class="fragment">the message can be anything supported by JSON (strings, objects, etc. &#8230; but not functions)</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="more-server-functions-and-properties">(More) Server Functions (and Properties)</h2>

  <p>The callback passed to <code class="highlighter-rouge">on</code> for a connection event has a <strong>socket</strong> as a parameter. This socket object can be used to interact with the connected client:</p>

  <ul>
    <li><strong><code>socket.on('event name', callback)</code></strong>
      <ul>
        <li class="fragment">define a callback to handle socket event</li>
        <li class="fragment">usually custom event names (events that you create)</li>
      </ul>
    </li>
    <li><strong><code>socket.emit('event name', 'message')</code></strong> <span class="fragment"> - send a message to this connected client only</span></li>
    <li><strong><code>socket.broadcast.emit('event name', 'message')</code></strong>
      <ul>
        <li class="fragment">send a message to all connected clients <strong>except</strong> for yourself (the socket that sends the message)</li>
      </ul>
    </li>
    <li><strong><code>socket.id</code></strong> <span class="fragment"> - a unique identifier for the socket session / connected client</span></li>
  </ul>
</section>

<section>
  <h2 id="some-client-functions">(Some) Client Functions</h2>

  <ul>
    <li><strong><code>io</code></strong>
      <ul>
        <li class="fragment">a function that gives back a socket object</li>
        <li class="fragment">socket can be used to interact with server</li>
        <li class="fragment"><code class="highlighter-rouge">const socket = io('http://localhost');</code></li>
      </ul>
    </li>
    <li><strong><code>socket.on('event name', callback)</code></strong>
      <ul>
        <li class="fragment">listen for an event name, trigger the callback</li>
      </ul>
    </li>
    <li><strong><code>socket.emit('event name', 'message')</code></strong>
      <ul>
        <li class="fragment">send a message to the server</li>
      </ul>
    </li>
  </ul>

</section>
<section>
  <h2 id="events">Events</h2>

  <p>Both the server and client side of have built-in events. <strong>A couple of common ones are:</strong> &#8594;</p>

  <ul>
    <li><code>connect</code> - a client connects to the server</li>
    <li><code>disconnect</code> - a client disconnects from the server</li>
  </ul>

  <p class="fragment"><br />
Note, however, <strong>you can define any custom event name that you&#39;d like</strong> - just specify it as the first argument when calling your <code>emit</code> or <code>on</code> methods.</p>
</section>

<section>
  <h1 id="lets-start-simple-just-log-some-client-server-connections">Let&#39;s Start Simple&#8230; Just Log Some Client Server Connections</h1>
</section>

<section>
  <h2 id="installing-on-the-server">Installing on the Server</h2>

  <p>First, create your Express project. We can generate a project as usual or build an express app from scratch.</p>

  <p><strong>Then, install the Socket.IO Node module:</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
npm install --save socket.io
</code></pre>
</section>

<section>
  <h2 id="some-server-side-set-up">Some Server-Side Set Up</h2>

  <p>Socket.IO requires access to the underlying HTTP server object that backs express (you remember the <strong><code>http</code></strong> module, right!?).</p>

  <p>In its simplest form, you can <em>attach</em> a socket.io Server to Express using this code:</p>

  <pre><code data-trim="" contenteditable="">
const express = require('express');
const app = express();
const server = require('http').Server(app);
const io = require('socket.io')(server);
app.use(express.static('public'));


server.listen(3000);
</code></pre>

</section>
<section>
  <h2 id="server-side-set-up-with-with-generator">Server Side Set Up with with Generator</h2>

  <p>That was a little different than what we&#39;re used to doing. If you want to use express generator, a quick way to attach a socket.io server is to:</p>

  <ul>
    <li>copy the contents of <strong><code>/bin/www</code></strong></li>
    <li>&#8230; to <strong><code>app.js</code></strong></li>
    <li>remove the unnecessary require line</li>
    <li>the end of your app.js file should now look like this (after: module.exports = app)</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
const debug = require('debug')('projectname');

app.set('port', process.env.PORT || 3000);

const server = app.listen(app.get('port'), function() {
  debug('Express server listening on port ' + server.address().port);
});
</code></pre>
</section>

<section>
  <h2 id="set-up-the-socketio-server">Set Up the Socket.IO Server</h2>

  <p>Create a Socket.IO server by</p>

  <ul>
    <li>requiring <code>socket.io</code></li>
    <li>and immediately calling it as a function, passing in your HTTP server from your previous Express setup code</li>
  </ul>

  <p><br /></p>
  <pre><code data-trim="" contenteditable="">
const io = require('socket.io')(server);
</code></pre>

  <p>This adds Socket.IO support to your HTTP server!</p>
</section>

<section>
  <h2 id="listen-for-connections">Listen for Connections</h2>

  <p>Once your server is set up, you can define what it should do when a client connects. <strong>Let&#39;s just log that someone has connected, along with their ID.</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
io.on('connection', function(socket) {
	console.log(socket.id, 'has connected!');
}
</code></pre>

  <p class="fragment">Note that the callback:</p>

  <ul class="fragment">
    <li>has a single parameter, a Socket object</li>
    <li>you&#39;ll use that within your callback to define other event handlers</li>
    <li><strong>the socket object is unique per connected client</strong></li>
  </ul>
</section>

<section>
  <h2 id="setting-up-you-client">Setting Up You Client</h2>

  <p>Create a new static page in your <code>/public</code> folder&#8230; or create an appropriate view / route combination for the page that you&#39;ll serve.</p>

</section>

<section>
  <h2 id="including-the-client-side-library">Including the Client Side Library</h2>

  <p>The <em>development</em> server automatically serves up the client-side library at:</p>

  <pre><code data-trim="" contenteditable="">
/socket.io/socket.io.js
</code></pre>

  <p>This gives your page access to a global <code>io</code> object. So&#8230; make sure to include the library:</p>

  <pre><code data-trim="" contenteditable="">
&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;
</code></pre>
</section>

<section>
  <h2 id="create-a-socket">Create a Socket</h2>

  <p>Use the global io object to create a Socket object</p>

  <pre><code data-trim="" contenteditable="">
const socket = io();
</code></pre>

  <p>&#8230;And <strong>that&#39;s it!</strong>. Let&#39;s test it out. <strong>Start your server and load your page in a few browser windows.</strong></p>

</section>

<section>
  <h2 id="adding-another-event-on-the-server">Adding Another Event on the Server</h2>

  <p>We can listen for disconnects using the <code>disconnect</code> event. Instead of using the Server object, we&#39;ll use the socket that we have from the connect event handler.</p>

  <p><strong>Add this code within your connect event handler.</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
socket.on('disconnect', function() {
	console.log(socket.id, 'good bye!');
});
</code></pre>
  <p><strong>Try closing a connected browser tab. Try refreshing.</strong></p>
</section>

<section>
  <h2 id="send-and-receive-custom-events">Send and Receive Custom Events</h2>

  <p>Let&#39;s try sending an event from our client immediately after connecting:</p>

  <p><strong>Set up a connect handler on the client.</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
socket.on('connect', onConnect); 
</code></pre>

  <p><strong>In your callback, send a custom event to the server.</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
function onConnect() {
	socket.emit('my awesome event', 'a message');
}
</code></pre>
</section>

<section>
  <h2 id="send-and-receive-custom-events-continued">Send and Receive Custom Events Continued</h2>

  <p>Now our server has to listen for that custom event. <strong>Within your main on connect handler in app.js&#8230;</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">

socket.on('my awesome event', function(message) {
	console.log(message);
}
</code></pre>

  <p>You can name your callback&#39;s argument whatever you like. It represents the second value passed in to your client&#39;s emit.</p>

  <p>In fact&#8230; <strong>we can try changing the data that we send from a plain old string to an object!</strong> &#8594;</p>

</section>

<section>
  <h2 id="lets-rewrite-our-chat">Let&#39;s Rewrite Our Chat</h2>

  <p>We can write a simpler version of our chat (it&#39;ll be slightly different, since we won&#39;t have it be database backed) using Socket.IO.</p>

  <p><strong>How might we do this?</strong> &#8594;</p>

  <ul class="fragment">
    <li>set up as described above</li>
    <li>create a custom event for chat messages
      <ul>
        <li>these will be emitted from the client</li>
        <li>&#8230;when received by the server, the message, in turn, will be relayed to all clients using some version of emit</li>
        <li>the client will listen for that event in order to update the ui</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="server-side-chat-code">Server Side Chat Code</h2>

  <p>Really&#8230; <strong>all we have to add here is a custom event handler that just emits to everyone (<code>io.sockets.emit</code>)</strong>: &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
// our previous setup 
const io = require('socket.io')(server);
io.on('connection', function(socket) {
  console.log(socket.id, 'connected');  
  socket.on('disconnect', function() {
    console.log(socket.id, 'disconnected');
  });
  // our custom event handler goes here
});
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">

  // handling our custom event
  socket.on('chat message', function(msg) {
    console.log('got message:' + msg);
    io.sockets.emit('chat message', msg);
  });
</code></pre>
</section>

<section>
  <h2 id="client-side-markup">Client Side Markup</h2>

  <p><strong>Minimally, what markup would we need for this app?</strong> &#8594;</p>

  <ul class="fragment">
    <li>a text input and a button</li>
    <li>a place to dump the messages</li>
    <li>(remember to include the Socket.IO client library)</li>
  </ul>

  <p><br /></p>
  <pre class="fragment"><code data-trim="" contenteditable="">
&lt;ul id="messages"&gt;&lt;/ul&gt;
&lt;input id="message-input" type=text autocomplete="off"&gt;&lt;input type="button" value="Submit"&gt;
&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;
</code></pre>
</section>

<section>
  <h2 id="now-for-some-setup">Now for Some Setup</h2>

  <p><strong>Let&#39;s create our socket&#8230; and setup our button to trigger a function called <code>sendMessage</code> when it&#39;s clicked:</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const socket = io();
const button = document.querySelector('input[type=button]');
console.log(button);
button.addEventListener('click', sendMessage);
</code></pre>
</section>

<section>
  <h2 id="define-sendmessage">Define SendMessage</h2>

  <p>Send message should simply grab the value of the input field and emit it to the server using our custom event name.</p>

  <p><strong>How would we code that up?</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
function sendMessage(evt) {
	console.log('sending message', evt);
	socket.emit('chat message', document.querySelector('#message-input').value);
	document.querySelector('#message-input').value = '';
}
</code></pre>

  <p class="fragment"><strong>Let&#39;s pause here to test it out. We should get some console output both in our client and server.</strong> &#8594;</p>
</section>

<section>
  <h2 id="now-lets-handle-a-message-from-the-server">Now, Let&#39;s Handle a Message From the Server</h2>

  <p>Ok&#8230; so the server should be emitting messages whenever it receives them from a client. How do we define some action to take on the message emitted from the server?</p>

  <p><strong>Define a function that listens for a chat message from the server&#8230; and add a list item to our unordered list.</strong> &#8594;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
socket.on('chat message', onMessage);
function onMessage(msg) {
	document.querySelector('#messages').appendChild(document.createElement('li')).textContent = msg;
}
</code></pre>

  <p class="fragment"><strong>Let&#39;s see if it works!</strong> &#8594;</p>

  <p class="fragment"><strong>Such real time! (maybe, if all goes well)</strong></p>
</section>

<section>
  <h1 id="but-how-realtime-can-we-get-can-we-track-mouse-info">But how realtime can we get? Can we track mouse info?</h1>
</section>

<section>
  <h2 id="mouse-tracking">Mouse Tracking</h2>

  <p>Create an app that:</p>

  <ul>
    <li>that shows the mouse position of other connected users</li>
    <li>their position should be tracked realtime</li>
    <li>their cursor can be represented by their socket id</li>
    <li>maybe a <code>div</code> element with a textContent equal to their socket id</li>
    <li><strong>that div element can have an id that&#39;s set to the socket id&#8230; so that we can track each individual mouse</strong></li>
  </ul>
</section>

<section>
  <h2 id="about-mouse-movement">About Mouse Movement</h2>

  <p>We know that we can grab a <code>click</code> event from our mouse.  It turns out that we can also trigger a function <em>whenever our mouse moves!</em>.</p>

  <ul>
    <li>call addEventListener on the element that you want to track mouse moves over (use <code>document</code> for the whole page)</li>
    <li><strong>The event object passed to your callback will hold the mouse coordinates!</strong></li>
  </ul>

  <p><br /></p>
  <pre><code data-trim="" contenteditable="">
document.addEventListener('mousemove', function(evt) {
	console.log(evt.x, evt.y);
});
</code></pre>

  <p>Again, note that evt has <code>x</code> and <code>y</code> properties. <strong>Let&#39;s try it.</strong> &#8594;</p>

  <p><strong>Armed with this knowledge, we can code up our mouse tracking application.</strong> &#8594;</p>

</section>

<section>
  <h2 id="lets-start-on-the-client-this-time">Let&#39;s Start on the Client This Time</h2>

  <p>First&#8230; let&#39;s modify our mousemove handler so that it sends over its x and y coordinates to the server instead of just logging it.</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
document.addEventListener('mousemove', function(evt) {
	console.log(evt.x, evt.y);
	socket.emit('mouse', {x:evt.x, y:evt.y});
});
</code></pre>
</section>

<section>
  <h2 id="now-on-the-server">Now, on the Server&#8230;</h2>

  <p><strong>How do we listen for all of these mouse events that are being sent our way!? Let&#39;s log out the x and y coordinates AND the socket.id where they came from.</strong> &#8594;</p>

  <p class="fragment">Within our connection handler, specify what we should do when we receive a mouse event.</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
// inside our main connection handler

socket.on('mouse', function(data) {
	// might be nice to see who's moving
	data.id = socket.id;
	console.log('other mouse', data);
});
</code></pre>

  <p class="fragment"><strong>Note that we add the socket id here. We&#39;ll use that later!</strong></p>
</section>

<section>
  <h2 id="if-that-works-lets-broadcast">If That Works, Let&#39;s Broadcast</h2>

  <p>Hopefully we&#39;ll get console output on the server for every mouse move!</p>

  <p>If we do, we can go ahead and emit those coordinates and id as another custom event to all <em>other</em> clients. <strong>Let&#39;s make a simple addition. The whole thing should look like:</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
io.on('connection', function(socket) {
  socket.on('mouse', function(data) {
    data.id = socket.id;
	console.log('other mouse', data);
    socket.broadcast.emit('other mouse', data);
  });
});
</code></pre>
</section>

<section>
  <h2 id="aaaaaand-back-to-the-client">Aaaaaand Back to the Client</h2>

  <p>Let&#39;s create our custom <code>other mouse</code> event handler. <strong>What do you think it should:</strong> &#8594;</p>

  <ul class="fragment">
    <li>listen for the custom event</li>
    <li>check to see if an element with the socket id from the event exists</li>
    <li>if it doesn&#39;t, create one
      <ul>
        <li>set its textContent to the socket id</li>
        <li>set its id to the socket id</li>
        <li>set its class to otherMouse so that we can add some styling&#8230;</li>
      </ul>
    </li>
    <li>set the coordinates of the div</li>
    <li><strong>(by the way, how do we get this div to be positioned at specific coordinates)</strong> &#8594;</li>
  </ul>

  <p class="fragment">Use top and left &#8230; and</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
.otherMouse {
	position: fixed;
}
</code></pre>
</section>

<section>
  <h2 id="ok-lets-get-some-code-together">OK&#8230; Let&#39;s Get Some Code Together</h2>

  <p>So&#8230; from the description in the previous slide, <strong>the analogous code may look like this.</strong> &#8594;</p>
  <pre class="fragment"><code data-trim="" contenteditable="">
socket.on('other mouse', function(data) {
	console.log(data);
	let otherMouse = document.getElementById(data.id);
	if (!otherMouse) {
		otherMouse = document.body.appendChild(document.createElement('div'));
		otherMouse.id = data.id;
		otherMouse.textContent = data.id;
		otherMouse.classList.add('otherMouse');
	}
	otherMouse.style.top = data.y + "px";
	otherMouse.style.left = data.x + "px";
});
</code></pre>

  <p class="fragment"><strong>Note that the top and left values are in pixels.</strong></p>

</section>
:ET