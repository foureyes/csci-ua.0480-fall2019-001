I"?F<style>
hr {
    color: #ccc;
    border-color: #ccc;
}
</style>

<div class="panel panel-default">
	<div class="panel-heading">Homework #3</div>
	<div class="panel-body">

    <h1 id="creating-a-tiny-web-framework-due-monday-feb-19th-by-11pm-wednesday-feb-21st-by-11pm">Creating a Tiny Web Framework, Due <strike>Monday, Feb 19th by 11PM</strike> <strong>Wednesday, Feb 21st by 11PM</strong></h1>

    <p>⚠️⚠️⚠️NO GRACE PERIOD⚠️⚠️⚠️</p>

    <p>Extended due to length of homework.</p>

    <h2 id="overview">Overview</h2>

    <h3 id="description">Description</h3>

    <p>There are two major parts to this assignment:</p>

    <ol>
      <li>create a simple web server and website by using the <code class="highlighter-rouge">net</code> module</li>
      <li>move the functionality from part 1 into classes so that they your code can be reused as a library for making web apps without having to deal with low-level <code class="highlighter-rouge">net</code> module code</li>
    </ol>

    <p>By the end of both parts, you&#39;ll have a <em>toy</em>  web framework that allows a developer to write simple web applications.</p>

    <p>Again, both parts will be built off of and run from node&#39;s built-in TCP server (from the <code class="highlighter-rouge">net</code> module).</p>

    <p><strong>You can only use the following two modules for this assignment</strong> &#8594;</p>

    <ol>
      <li><code class="highlighter-rouge">net</code> - a module for creating TCP servers and clients</li>
      <li><code class="highlighter-rouge">fs</code> - a module for file system related tasks, such as reading and writing files</li>
    </ol>

    <p><strong>You can&#39;t use the <code class="highlighter-rouge">http</code> module&#8230; or install additional frameworks, such as <code class="highlighter-rouge">express</code></strong></p>

    <h3 id="submission-process">Submission Process</h3>

    <p>You will be given access to a private repository on GitHub. It will contain:</p>

    <ol>
      <li>stub source files in the <code class="highlighter-rouge">src</code> directory</li>
      <li>some testing assets in the <code class="highlighter-rouge">public</code> folder</li>
      <li>unit tests in <code class="highlighter-rouge">test</code></li>
      <li>linting files <code class="highlighter-rouge">.eslintrc</code>, etc.</li>
      <li><strong>you&#39;ll have to create your own <code class="highlighter-rouge">package.json</code></strong></li>
    </ol>

    <ul>
      <li><strong>Push</strong> your changes to the homework repository on GitHub.</li>
      <li>Commits later than the deadline will not be included in grading</li>
    </ul>

    <h3 id="points-make-at-least-4-commits">(4 points) Make at Least 4 Commits</h3>

    <ul>
      <li>Commit multiple times throughout your development process.</li>
      <li>Make at least 3 separate commits - (for example, one option may be to make one commit per part in the homework).</li>
    </ul>

    <h2 id="part-1---an-introduction">Part 1 - An Introduction</h2>

    <p>In this part, you&#39;ll familiarize yourself with the <code class="highlighter-rouge">net</code> module by creating a simple server that responds to http requests. You&#39;ll use events and callback functions to handle a new client connection, data arriving on a socket from a client, and a connection being closed.</p>

    <p>Work with the following files:</p>

    <ol>
      <li><code class="highlighter-rouge">src/intro.js</code> - your web server (run this file to serve your site)</li>
      <li><code class="highlighter-rouge">src/webutils.js</code> - a module that contains helper functions</li>
    </ol>

    <p>You&#39;ll start off by writing some helper functions. Then at the end of this part, you should have an application that uses those helper functions to respond to the following requests:</p>

    <ol>
      <li><code class="highlighter-rouge">GET /</code> - responds with a page that contains links to other pages and a form</li>
      <li><code class="highlighter-rouge">GET /such/stylish</code> - responds with a page that includes a stylesheet</li>
      <li><code class="highlighter-rouge">GET /css/base.css</code> - responds with a stylesheet</li>
      <li><code class="highlighter-rouge">GET /picsplz</code> - responds with a page that includes an image</li>
      <li><code class="highlighter-rouge">GET /img/animal.jpg</code> - responds with an image of your favorite animal</li>
      <li><code class="highlighter-rouge">GET /showanimage</code> - responds with a redirect to <code class="highlighter-rouge">picsplz</code></li>
      <li><code class="highlighter-rouge">POST /</code> - responds with the body of the post request as plain text</li>
      <li>A request that isn&#39;t <code class="highlighter-rouge">GET</code> or <code class="highlighter-rouge">POST</code> - a <code class="highlighter-rouge">405</code> is sent back saying that the method is not allowed</li>
      <li>A request that is a <code class="highlighter-rouge">GET</code> or <code class="highlighter-rouge">POST</code> but does not have a matching path - a <code class="highlighter-rouge">404</code> is sent back saying that the resource/page was not found</li>
    </ol>

    <p>Before starting, <strong>make sure to review the course materials on the net module and creating tcp/ip servers</strong>:</p>

    <ol>
      <li>check out the <a href="../slides/06/sockets.html#/2">slides on the <code class="highlighter-rouge">net</code> module</a>, paying close attention to the <a href="../slides/06/sockets.html#/10">the last slide</a>.</li>
      <li>go over the <a href="../examples/class06/notes.js">notes from previous classes</a></li>
      <li>lastly, make sure that you can write back a valid http response by reviewing::
        <ul>
          <li><a href="../slides/05/web.html#/16">the slides on http</a></li>
          <li><a href="../slides/05/web.html#/24">and an example response</a></li>
        </ul>
      </li>
    </ol>

    <h3 id="create-helper-functions">Create helper functions</h3>

    <p>Start by creating some helper functions in <code class="highlighter-rouge">webutils.js</code> to ease development. Export these function so that You can use them in <code class="highlighter-rouge">intro.js</code>. Minimally, implement the following functions (of course, you can create more functions, as the functions will only help with a subset of the part 1&#39;s requirements).</p>

    <h3 id="getextensionfilename"><code class="highlighter-rouge">getExtension(fileName)</code></h3>

    <p><strong>Parameters:</strong></p>

    <ul>
      <li><code class="highlighter-rouge">fileName</code> - a string representing the name of the file</li>
    </ul>

    <p><strong>Return:</strong></p>

    <ul>
      <li>the extension of the file in lowercase as a <code class="highlighter-rouge">String</code></li>
    </ul>

    <p><strong>Description:</strong></p>

    <p>Extracts the extension of a file name and normalizes it to lowercase. You can assume that everything after the last dot in a fil name is the extension. If there is no dot, then the extension is empty string. Hint: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split">split</a> or <a href="https://nodejs.org/api/path.html#path_path_extname_path">path.extname</a> may help implement this function.</p>

    <p>Example usage:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const ext1 = getExtension('foo.jpg'); // ext1 --&gt; jpg
const ext2 = getExtension('FOO.JPG'); // ext2 --&gt; jpg
const ext3 = getExtension('foo.bar.jpg'); // ext3 --&gt; jpg
const ext4 = getExtension('foo'); // ext4 --&gt; empty string
</code></pre></div>    </div>

    <h3 id="sendtextfilefilename-sock"><code class="highlighter-rouge">sendTextFile(fileName, sock)</code>:</h3>

    <p><strong>Parameters:</strong></p>

    <ul>
      <li><code class="highlighter-rouge">fileName</code> - a string representing the name of the file (relative to a directory called <code class="highlighter-rouge">public</code> within the root of your project directory)
        <ul>
          <li>example <code class="highlighter-rouge">/css/base.css</code> would read the file <code class="highlighter-rouge">PROJECT_ROOT/public/css/base.css</code>`</li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">sock</code> - a socket object to write data to</li>
    </ul>

    <p><strong>Return:</strong></p>

    <ul>
      <li>no return value</li>
    </ul>

    <p><strong>Description:</strong></p>

    <p>Sends back an http response with the data from the text file specified as the response body (along with appropriate headers and status line). The <code class="highlighter-rouge">sock</code> object will be used to write the http response back to the client.</p>

    <p>Use <code class="highlighter-rouge">fs.readFile</code> to read the data from the file from the path passed in:</p>

    <ol>
      <li>the path, <code class="highlighter-rouge">fileName</code> will be relative to a folder called <code class="highlighter-rouge">public</code> in your project&#39;s root directory
        <ul>
          <li>the built-in variable, <code class="highlighter-rouge">__dirname</code> contains the directory that your program is running from</li>
          <li>for example, if you&#39;re running your project from <code class="highlighter-rouge">/Users/foo/abc123-homework03/src</code>, then <code class="highlighter-rouge">__dirname</code> will contain that path</li>
          <li>you can assume that your program, <code class="highlighter-rouge">intro.js</code> will be run directly from the <code class="highlighter-rouge">src</code> folder in your project&#39;s root</li>
          <li>consequently, to read <code class="highlighter-rouge">fileName</code> from <code class="highlighter-rouge">public</code>, you&#39;ll have to use a combination of <code class="highlighter-rouge">__dirname</code> and <code class="highlighter-rouge">..</code> to go up one directory to your project root</li>
          <li>for example, to construct the absolute path to the file, concatenate or use <a href="https://nodejs.org/api/path.html#path_path_join_paths">path.join</a> from the <code class="highlighter-rouge">path</code> module to put together: <code class="highlighter-rouge">__dirname</code>, <code class="highlighter-rouge">..</code>, <code class="highlighter-rouge">public</code>, and <code class="highlighter-rouge">fileName</code></li>
        </ul>
      </li>
      <li>you can assume that the file you are reading is <code class="highlighter-rouge">utf8</code>, so use that as the 2nd argument to <code class="highlighter-rouge">fs.readFile</code></li>
      <li>in the callback to <code class="highlighter-rouge">fs.readFile</code> use the <code class="highlighter-rouge">socket</code> object that was provided as an argument to the original function to write out a response.</li>
    </ol>

    <p>The response should be a valid http response:</p>

    <ol>
      <li>start with the status line (using the appropriate status code)</li>
      <li>include any headers
        <ul>
          <li>hint: <code class="highlighter-rouge">Content-Type</code> may be useful</li>
          <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">see the mdn page on MIME types for possible values</a> for <code class="highlighter-rouge">Content-Type</code></li>
          <li>use the appropriate value for the extension of the text file being sent</li>
          <li>you can assume that we will only be serving stylesheets, html and plain text</li>
          <li>creating a mapping from extension to <code class="highlighter-rouge">MIME</code> type may be helpful</li>
        </ul>
      </li>
      <li>make sure that there&#39;s an empty line between the headers and the body of the response (remember <code class="highlighter-rouge">\r\n\r\n</code> separates the body from the status line and headers)</li>
      <li>use the text from the file as the response body</li>
      <li>write all of this out to the client using the <code class="highlighter-rouge">socket</code> object passed in</li>
      <li>and finally, use the <code class="highlighter-rouge">socket</code> object to end the connection</li>
    </ol>

    <p>If any error occurs while reading the file, don&#39;t send back the contents of the file. Instead&#8230; send back a response that:</p>

    <ol>
      <li>let&#39;s the client know there was an error</li>
      <li>use an appropriate status code and description in the status line of your response</li>
      <li>include a plain text body that describes the status code</li>
    </ol>

    <p>Example usage:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sendTextFile('/css/base.css', sock); 

// reads /path/to/project/public/css/base.css
// the resulting response should be something like (with new lines as \r\n\r\n):
// HTTP/1.1 200 OK
// Content-Type: text/css
// 
// h1 {color: red;}
</code></pre></div>    </div>

    <h3 id="sendimagefilename-sock"><code class="highlighter-rouge">sendImage(fileName, sock)</code>:</h3>

    <p><strong>Parameters:</strong></p>

    <ul>
      <li><code class="highlighter-rouge">fileName</code> - a string representing the name of the file</li>
      <li><code class="highlighter-rouge">sock</code> - a socket object to write data to</li>
    </ul>

    <p><strong>Return:</strong></p>

    <ul>
      <li>no return value</li>
    </ul>

    <p><strong>Description:</strong></p>

    <p>This function is similar to <code class="highlighter-rouge">sendTextFile</code> described above, but instead of reading a plain text file, it will read image data and send it as the response body. The requirements and specifications for <code class="highlighter-rouge">sendImage</code> differ from <code class="highlighter-rouge">sendTextFile</code> in the following ways:</p>

    <ul>
      <li>because an image is being read, omit the second argument, encoding, or set it to an empty object for <code class="highlighter-rouge">fs.readFile</code> so that the raw buffer is given instead of an encoded string:
        <ul>
          <li><code class="highlighter-rouge">fs.readFile('/img/foo.jpg', (err, data) =&gt; {});</code></li>
          <li><code class="highlighter-rouge">fs.readFile('/img/foo.jpg', {}, (err, data) =&gt; {});</code></li>
        </ul>
      </li>
      <li>just like <code class="highlighter-rouge">sendTextFile</code>, you&#39;ll have to send back the appropriate http response status line and headers&#8230; so that means you have to send the right <code class="highlighter-rouge">Content-Type</code></li>
      <li>this function should support: <code class="highlighter-rouge">jpg</code>, <code class="highlighter-rouge">jpeg</code>, <code class="highlighter-rouge">gif</code>, and <code class="highlighter-rouge">png</code> (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">again, check out the mdn article on MIME Types</a></li>
      <li><strong>IMPORTANT</strong>: when sending a response, <strong>you must <code class="highlighter-rouge">write</code> the response status line, headers and empty line to the <code class="highlighter-rouge">socket</code> object first</strong>, and then, <strong>only afterwards, <code class="highlighter-rouge">write</code> out the raw buffer image data</strong> (essentially, you&#39;ll be calling <code class="highlighter-rouge">write</code> twice)&#8230; <strong>DO NOT CONVERT THE IMAGE DATA TO A STRING</strong>
        <ul>
          <li>also check out the <a href="http://localhost:4000/examples/class06/notes.js">class notes for additional examples</a></li>
        </ul>
      </li>
    </ul>

    <h3 id="testing-functions">Testing Functions</h3>

    <p>Once your finished with your implementation above, you can export, test and try using your new functions.</p>

    <p>Export the functions using <code class="highlighter-rouge">module.exports</code>, and try running the tests in test/webutils-test.js</p>

    <ul>
      <li>make sure that <code class="highlighter-rouge">mocha</code> is installed as in previous assignments</li>
      <li>install dev dependencies to run tests: npm install --save-dev chai sinon mocha-sinon (you can ignore any unmet peer dependency warnings)</li>
      <li><code class="highlighter-rouge">mocha test/webutils-test.js</code></li>
    </ul>

    <h3 id="create-pages">Create Pages</h3>

    <p>Now that you have some helper functions, you can create a web server and put together a few pages! Open up <code class="highlighter-rouge">src/intro.js</code> to:</p>

    <ol>
      <li>create a simple web server
        <ul>
          <li>check out the <a href="../examples/net/echoServer.js">echo server example</a></li>
          <li><strong>make sure your server is running on port 8080</strong></li>
        </ul>
      </li>
      <li>the web server should respond to http requests (see the pages / requests that your server should support after this set of instructions)
        <ul>
          <li>review the <a href="http://jvers.com/csci-ua.0480-spring2018-008/examples/net/webServer.js">sample web server</a> code from the course site</li>
          <li>also check out the <a href="http://localhost:4000/examples/class06/notes.js">class notes for additional examples</a></li>
          <li>of course, bring in your <code class="highlighter-rouge">webutils.js</code> to help with this (again, you can create more helper functions in addition to the ones required from the instructions above)</li>
          <li>if you are using <code class="highlighter-rouge">sendTextFile</code> or <code class="highlighter-rouge">sendImage</code>, then make sure to drop your files in the <code class="highlighter-rouge">public</code> folder of your project root</li>
        </ul>
      </li>
      <li>to run your server, change to the <code class="highlighter-rouge">src</code> directory in your project root and run <code class="highlighter-rouge">node intro.js</code> (note that your terminal will look like its &quot;frozen&quot;, but it&#39;s really just waiting for requests).</li>
      <li>use the following to test your server
        <ul>
          <li><code class="highlighter-rouge">curl -i localhost:8080/path/to/page</code> to test your server.</li>
          <li>enter the url in your browser</li>
        </ul>
      </li>
      <li>To shutdown your server, CTRL + c in your terminal&#8230;</li>
    </ol>

    <p>The pages / requests that your web server should handle include:</p>

    <p><strong>A Homepage With Links</strong></p>

    <ul>
      <li>modify your server so that it responds to <code class="highlighter-rouge">GET /</code></li>
      <li>it should give back an html document</li>
      <li>the document should contain links to the following pahts
        <ol>
          <li><code class="highlighter-rouge">/such/stylish</code></li>
          <li><code class="highlighter-rouge">/picsplz</code></li>
          <li><code class="highlighter-rouge">/showanimage</code></li>
        </ol>
      </li>
      <li>it should also contain this form (which will be used later to create a POST request):
        <pre><code data-trim="" contenteditable="">&lt;form method="POST" action=""&gt;
&nbsp;&nbsp;&nbsp;&nbsp;Name: &lt;input type='text' name='name'&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="submit"&gt;	
&lt;/form&gt;</code></pre>
      </li>
      <li>you can use one of your helper functions from <code class="highlighter-rouge">webutils.js</code> to implement this, or manually <code class="highlighter-rouge">write</code> out an http response with html as the body</li>
      <li>if you&#39;re not getting the response you expect (your browser doesn&#39;t show the page, only shows plain text, etc.), check out the <a href="#troubleshoot-part1">troubleshooting section below</a></li>
      <li>example (your text does not have to match exactly, but there should be three links and a form):
  <img src="../resources/img/hw03-web4u-01-home.png" /></li>
    </ul>

    <p><strong>A Styled Page</strong></p>

    <ul>
      <li>modify your server so that it responds to:
        <ol>
          <li><code class="highlighter-rouge">GET /such/stylish</code></li>
          <li><code class="highlighter-rouge">GET /css/base.css</code></li>
        </ol>
      </li>
      <li><code class="highlighter-rouge">/such/stylish</code> should respond with an html document that includes a <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#Examples">link tag</a> that includes a css file</li>
      <li>the css file that it should include is <code class="highlighter-rouge">/css/base.css</code></li>
      <li><code class="highlighter-rouge">/css/base.css</code> should respond with a stylesheet
        <ul>
          <li>add styles to <code class="highlighter-rouge">/css/base.css</code></li>
          <li>minimally, you stylesheet should change the colors of the text so that it&#39;s not the default color, black</li>
          <li>you can add any other styles that you like</li>
        </ul>
      </li>
      <li>you can use one of your helper functions from <code class="highlighter-rouge">webutils.js</code> to implement this, or manually <code class="highlighter-rouge">write</code> out an http response with the appropriate body (html and css respectively)</li>
      <li>example (note that the styles are from <code class="highlighter-rouge">/css/base.css</code>, but the page is <code class="highlighter-rouge">/such/stylish</code>)&#8230; you can style this page any way you like, but minimally, change the colors of the text (you don&#39;t <em>have</em> to add borders or a background):
  <img src="../resources/img/hw03-web4u-02-style.png" /></li>
    </ul>

    <p><strong>A Page with an Image</strong></p>

    <ul>
      <li>modify your server so that it responds to:
        <ol>
          <li><code class="highlighter-rouge">GET /picsplz</code></li>
          <li><code class="highlighter-rouge">GET /img/animal.jpg</code></li>
        </ol>
      </li>
      <li><code class="highlighter-rouge">/picsplz</code> should respond with an html document that includes an <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#Examples">img tag</a></li>
      <li>includes some text describing the image</li>
      <li>the image that it should bring in is <code class="highlighter-rouge">/img/animal.jpg</code></li>
      <li><code class="highlighter-rouge">/img/animal.jpg</code> responds with an image (jpg) of your favorite animal</li>
      <li>you can use one of your helper functions from <code class="highlighter-rouge">webutils.js</code> to implement this, or manually <code class="highlighter-rouge">write</code> out an http response with the appropriate body (html and an image, jpg, respectively)</li>
      <li>if your image doesn&#39;t work, check out the <a href="#troubleshoot-part1">troubleshooting section below</a></li>
      <li>example:
  <img src="../resources/img/hw03-web4u-03-image.png" /></li>
    </ul>

    <p><strong>A Redirect</strong></p>

    <ul>
      <li>modify your server so that it responds to: <code class="highlighter-rouge">GET /showanimage</code></li>
      <li>this will result in a permanent redirect to <code class="highlighter-rouge">/picsplz</code></li>
      <li>make sure to use the correct status code and headers</li>
      <li>the body can just be plain text with a message specifying that a permanent redirect is in place</li>
      <li>to test:
        <ul>
          <li>go to <code class="highlighter-rouge">/showanimage</code> with curl</li>
          <li>the response should have the appropriate status code and headers</li>
          <li>use your browser to go to <code class="highlighter-rouge">/showanimage</code></li>
          <li>the url bar should go to <code class="highlighter-rouge">/picsplz</code></li>
          <li>use incognito mode or clear your cache to make sure that the redirect is not cached when testing</li>
        </ul>
      </li>
      <li>you&#39;ll have to manually <code class="highlighter-rouge">write</code> out an http response and <code class="highlighter-rouge">end</code> the connection to implement a redirect as response&#8230; or add a helper function to <code class="highlighter-rouge">webutils.js</code> that does this</li>
      <li>example (note that the initial response should be a 301, at which point your browser is redirected to <code class="highlighter-rouge">picsplz</code>, which is what will appear in the url bar):
  <img src="../resources/img/hw03-web4u-05-redirect-02.png" /></li>
    </ul>

    <p><strong>Handling a POST Request</strong></p>

    <ul>
      <li>modify your server so that it responds to: <code class="highlighter-rouge">POST /</code></li>
      <li>it should respond with a plain text document that shows the <em>body</em> of the original POST request (which means that you should parse out the body of the request that you received)
        <ul>
          <li>of course, make sure you send back the appropriate status code for a successful response</li>
          <li>along with any necessary headers</li>
        </ul>
      </li>
      <li>to test:
        <ul>
          <li>submit the form from <code class="highlighter-rouge">/</code> by filling in the text field and clicking the submit button</li>
          <li>this should result in a <code class="highlighter-rouge">POST</code> request from your browser</li>
          <li>you should see a plain text result that containts name=whatever_you_typed</li>
          <li>alternatively, use <code class="highlighter-rouge">curl -i localhost:8080 -d name=whatever_you_typed</code> to initiate a POST request from curl</li>
        </ul>
      </li>
      <li>you&#39;ll have to manually <code class="highlighter-rouge">write</code> out an http response and <code class="highlighter-rouge">end</code> the connection to implement this&#8230; make sure to include the body that was parsed out of the request as part of the response!
example (entering data in the form in <code class="highlighter-rouge">/</code> should display the form data that was entered):
  <img src="../resources/img/hw03-web4u-07-post.png" /></li>
    </ul>

    <p><strong>Handling Bad Requests</strong></p>

    <p>Finally, handle the following error conditions:</p>

    <ul>
      <li>if a request has a method that&#39;s other than <code class="highlighter-rouge">GET</code> or <code class="highlighter-rouge">POST</code>, send back a <code class="highlighter-rouge">405</code> with a plain text body saying that the method is not allowed</li>
      <li>if a request is a <code class="highlighter-rouge">GET</code> or <code class="highlighter-rouge">POST</code>,  but it does not have a matching path, send back a <code class="highlighter-rouge">404</code>  with a plain text body saying that the page was not found</li>
      <li>both of these can be implemented by manually using <code class="highlighter-rouge">write</code> and <code class="highlighter-rouge">end</code> on the socket object to write back the appropriate response&#8230; or you can write a method that does this in your helper functions module</li>
      <li>an example of a 405 using <code class="highlighter-rouge">nc</code> to send a request that&#39;s not <code class="highlighter-rouge">GET</code> or <code class="highlighter-rouge">POST</code>:
  <img src="../resources/img/hw03-web4u-09-405.gif" /></li>
      <li>an example of a 404 using curl:
  <img src="../resources/img/hw03-web4u-10-404.gif" /></li>
    </ul>

    <p><strong>Everything Together</strong></p>

    <p>Once you&#39;ve finished up all of the paths specified, an example interaction may look like this:</p>

    <p><img src="../resources/img/hw03-web4u-08-all.gif" /></p>

    <p><span id="troubleshoot-part1" name="troubleshoot-part1"></span></p>

    <h3 id="troubleshooting">Troubleshooting</h3>

    <ol>
      <li>If your browser doesn&#39;t show anything, and it looks like it&#39;s waiting for a response, make sure you&#39;re calling <code class="highlighter-rouge">sock.end</code>.</li>
      <li>If html is showing up as text (that is, you see the tags / mark-up in the page itself), double check that you&#39;ve set the content type correctly.</li>
      <li>If you see an error in the terminal window that runs your server that says: <code class="highlighter-rouge">Error: This socket has been ended by the other party</code>, it likely means that <code class="highlighter-rouge">sock.end</code> was called more than once (you can only end a connection once! &#8230;so calling <code class="highlighter-rouge">sock.end</code> multiple times on the same socket will result in an error)</li>
      <li>If your browser does not display the resource and instead shows an error that says empty or invalid response, then that means that a valid http response is not being sent back or no data was sent back (check the format of your response by printing it out, check for calls to <code class="highlighter-rouge">write</code> and <code class="highlighter-rouge">end</code> where appropriate)</li>
      <li>if an image is broken:
        <ul>
          <li>it&#39;s likely an issue with content type or reading the image as binary data - make sure that the head is written first, then the data of the body sent afterwards</li>
          <li>or perhaps not having two \r\n&#39;s between the headers and the body</li>
          <li>or it could be inadvertently converting the body into a string by writing the headers and the body all at once</li>
          <li>or inadvertently adding extra data into the body</li>
        </ul>
      </li>
    </ol>

    <h2 id="part-2---request-response-and-app-classes-and-a-small-site">Part 2 - <code class="highlighter-rouge">Request</code>, <code class="highlighter-rouge">Response</code>, and <code class="highlighter-rouge">App</code> Classes&#8230; and a Small Site!</h2>

    <p>Although we abstracted out some of common tasks into function in part 1 of this assignment, there was still a lot of manual work that needed to be done, and it felt like an <em>incomplete</em> API for creating web applications.</p>

    <p>Let&#39;s use some JavaScript language features to create a nicer library for creating web applications. We&#39;ll create this framework in <code class="highlighter-rouge">src/webframework.js</code></p>

    <h3 id="about-the-framework">About the Framework</h3>

    <p>Your framework (<code class="highlighter-rouge">webframework.js</code>), will be built off of node&#39;s <code class="highlighter-rouge">net</code> module. It&#39;ll use the <code class="highlighter-rouge">net</code> module to create a TCP server that will allow connections from clients. The code that you&#39;ll write will handle an incoming http request from a client by parsing the http request, determining what do based on the request, and finally sending back an http response. You&#39;ll do this by creating these objects (you can create more objects, but these 3 must be present):</p>

    <ol>
      <li><code class="highlighter-rouge">Request</code> - an object that represents an http request</li>
      <li><code class="highlighter-rouge">Response</code> - an object that represents an http response&#8230; and has the ability to actually send back a response to the client</li>
      <li><code class="highlighter-rouge">App</code> - represents your web application; takes incoming requests and determines what to do based on path, method, etc. &#8230;</li>
    </ol>

    <p>You can use the objects that you create to write simple web applications. Here are some example of how you might use <code class="highlighter-rouge">webframework.js</code>. Again, <strong>you are making the library / objects / module</strong> that makes the following possible:</p>

    <ul>
      <li>Create a new web application
        <pre><code data-trim="" contenteditable="">const App = require('./miniWeb.js').App;
const app = new App();
</code></pre>
      </li>
      <li>Serve the contents of the file in <code class="highlighter-rouge">$PROJECT_ROOT/html/index.html</code> when a request for <code class="highlighter-rouge">/</code> is received
        <ul>
          <li>here&#39;s the code that you would use:
            <pre><code data-trim="" contenteditable="">app.get('/', function(req, res) {
  res.sendFile('/html/index.html');
});
</code></pre>
          </li>
        </ul>
      </li>
      <li>Serve the string <code class="highlighter-rouge">"just some text"</code> as plain text (<code class="highlighter-rouge">text/plain</code>)by manually setting a <code class="highlighter-rouge">Content-Type</code> header, status code, and response body &#8230;when a request for the path, <code class="highlighter-rouge">/just/text</code>, is received
        <pre><code data-trim="" contenteditable="">app.get('/just/text', function(req, res) {
  // set header
  res.setHeader('Content-Type', 'text/plain');

  // return a 200 with body, "just some text"
  res.send(200, 'just some text!');
});
</code></pre>
      </li>
      <li>Send back a temporary redirect when a client requests the path, <code class="highlighter-rouge">/gone</code>
        <pre><code data-trim="" contenteditable="">app.get('/gone', function(req, res) {

  // set the status code and location of a redirect
  res.redirect(301, '/just/text');
});
</code></pre>
      </li>
      <li>Bind your application / web server to port 8080 on localhost
        <pre><code data-trim="" contenteditable="">app.listen(8080, '127.0.0.1');
</code></pre>
      </li>
    </ul>

    <h3 id="building-the-framework">Building the Framework</h3>

    <p>In <code class="highlighter-rouge">webframework.js</code>&#8230;</p>

    <ol>
      <li>create a <code class="highlighter-rouge">Request</code> object to encapsulate http requests</li>
      <li>create a <code class="highlighter-rouge">Response</code> object to encapsulate http responses; this object will be able to:
        <ul>
          <li>send http responses back using a socket object</li>
          <li>read files from the file system to send back</li>
        </ul>
      </li>
      <li>create an app object that encapsulates your server&#8230;
        <ul>
          <li>add application level functionality, such as routing</li>
        </ul>
      </li>
      <li>use your objects to create a simple site!</li>
    </ol>

    <p>You&#39;ll build off of your experience from part 1 by refactoring your code and encapsulating the functionality that you previously created in classes and methods.</p>

    <h3 id="create-a-request-class">Create a <code class="highlighter-rouge">Request</code> Class</h3>

    <p>In this section, you&#39;ll fully implement a <code class="highlighter-rouge">Request</code> object. You&#39;ll then conditionally serve up different content based on the <code class="highlighter-rouge">path</code> specified by the request.  The <code class="highlighter-rouge">Request</code> object <strong>represents an http request</strong>. It can take an http request as a string, parse out information about that request and expose that information as properties (such as <code class="highlighter-rouge">method</code>, <code class="highlighter-rouge">path</code>, and <code class="highlighter-rouge">headers</code>). It assumes HTTP/1.1</p>

    <p>Create the <code class="highlighter-rouge">Request</code> <em>class</em>  by implementing the following in <code class="highlighter-rouge">webframework.js</code>:</p>

    <hr />

    <h4 id="constructor">Constructor</h4>

    <p><code class="highlighter-rouge">Request(httpRequest)</code> - creates a new request object based on the string passed in.</p>

    <pre><code data-trim="" contenteditable="">let s = ''
s += 'GET /foo.html HTTP/1.1\r\n';   // request line
s += 'Host: localhost:8080\r\n';     // headers
s += '\r\n\r\n';                     // empty line to mark the boundary between the header and body

const req = new Request(s);
</code></pre>

    <p>The string passed in will be parsed into the properties shown below. <strong>You can assume that you will always receive a valid http request</strong></p>

    <hr />

    <h4 id="properties">Properties</h4>

    <ol>
      <li><code class="highlighter-rouge">path</code> - the path requested (for example, <code class="highlighter-rouge">/foo/bar/baz.html</code>)</li>
      <li><code class="highlighter-rouge">method</code> - the http verb (for example, <code class="highlighter-rouge">GET</code> or <code class="highlighter-rouge">POST</code>)</li>
      <li><code class="highlighter-rouge">headers</code> - an object that has header names as property names and header values as property values (for example, <code class="highlighter-rouge">{"Host": "localhost:8080", "User-Agent": "Mozilla/5.0 ..."}</code>)</li>
      <li><code class="highlighter-rouge">body</code> - the body of the request (for example, <code class="highlighter-rouge">username=foo</code>)</li>
    </ol>

    <p>Note that our <code class="highlighter-rouge">Request</code> object will assume HTTP/1.1, so it&#39;s not required to keep version as a property (though you can if you want!).</p>

    <hr />

    <h4 id="methods">Methods</h4>

    <ol>
      <li><code class="highlighter-rouge">toString</code> - returns a string representation of the request object as a valid http request (essentially taking its properties and creating a request - or another way of looking at it is recreating the original string passed in to the constructor)</li>
    </ol>

    <p>You can add additional properties and methods as needed.</p>
    <hr />

    <h4 id="example-usage">Example Usage</h4>

    <pre><code data-trim="" contenteditable="">let s = ''
s += 'GET /foo.html HTTP/1.1\r\n';   // request line
s += 'Host: localhost:8080\r\n'; // headers
s += '\r\n\r\n';                     /

const req = new Request(s);

console.log(req.path);
// --&gt; /foo.html

console.log(req.method);
// --&gt; GET

console.log(req.headers);
// --&gt; {'Host': 'localhost:8080' }

console.log(req.body);
// --&gt; ''
// the body is empty in this case ^^^
</code></pre>

    <hr />

    <h3 id="testing--using-the-request-object">Testing / Using the <code class="highlighter-rouge">Request</code> Object</h3>

    <p>Once your finished with your implementation above, you can export, test and try using your new <code class="highlighter-rouge">Request</code> object.</p>

    <ol>
      <li>Export the object using <code class="highlighter-rouge">module.exports</code>, and try running the tests in test/webframework-test.js (comment out the other tests) &#8230; run from within <code class="highlighter-rouge">test</code> folder
        <ul>
          <li>make sure that <code class="highlighter-rouge">mocha</code> is installed as in the previous part</li>
          <li>install dev dependencies to run tests: npm install --save-dev chai sinon mocha-sinon (you can ignore any unmet peer dependency warnings)</li>
          <li><code class="highlighter-rouge">mocha test/webframework-test.js</code></li>
        </ul>
      </li>
      <li>This request object can be used to parse the binary data that is passeed in to the callback function <code class="highlighter-rouge">someCallback</code> in <code class="highlighter-rouge">sock.on('data', someCallback)</code></li>
      <li>Now you can use the resulting <code class="highlighter-rouge">Request</code> object&#39;s <code class="highlighter-rouge">method</code> and <code class="highlighter-rouge">path</code> properties  to conditionally execute code
        <ul>
          <li><code class="highlighter-rouge">const req = new Request(binaryData.toString());</code></li>
          <li><code class="highlighter-rouge">if(req.method === 'GET' &amp;&amp; req.path === '/foo') { }</code></li>
        </ul>
      </li>
    </ol>

    <h3 id="create-a-response-class">Create a <code class="highlighter-rouge">Response</code> Class</h3>

    <p>Instead of directly calling  <code class="highlighter-rouge">write</code> on the<code class="highlighter-rouge">socket</code> object, wrap the <code class="highlighter-rouge">socket</code> up in a <code class="highlighter-rouge">Response</code> object and use that to send data to the client. Notice that all of the <code class="highlighter-rouge">methods</code> called on socket are being being called by equivalent methods on your <code class="highlighter-rouge">Response</code> object.</p>

    <p>The <code class="highlighter-rouge">Response</code> object represents an http response, and it allows direct manipulation of the underlying socket that represents the current connection for the http request/response. It can hold data about an http response, turn that data into a valid http response&#8230; and send that data back to the client (as well as close the connection between the server and the client).</p>

    <p>Create a <code class="highlighter-rouge">Response</code> <em>class</em> based on the <a href="#response">specifications below</a>.</p>

    <ul>
      <li>Note that it may be useful to keep an object that maps status codes to short descriptions ({&quot;200&quot;: &quot;OK&quot;, &quot;404&quot;: &quot;Not Found&quot;})</li>
      <li>You can run unit tests as you work, as usual, by adding the object to <code class="highlighter-rouge">module.exports</code>, and running the tests in test/webframework-test.js
        <ul>
          <li>again &#8230; <code class="highlighter-rouge">mocha test/webframework-test.js</code></li>
          <li><strong>not all methods are tested</strong> by the unit tests ⚠️️⚠️️⚠️️</li>
        </ul>
      </li>
    </ul>

    <p><a name="response"></a></p>

    <hr />

    <h4 id="constructor-1">Constructor</h4>

    <p><code class="highlighter-rouge">Response(socket)</code> - creates a new response object using the socket passed in as an argument to send data to the client.</p>

    <pre><code data-trim="" contenteditable=""> // when a socket, named sock, receives data...
// where sock is an object that represents connection a client
const res = new Response(sock);
</code></pre>

    <p>The constructor will set the socket instance passed in as a property on the resulting <code class="highlighter-rouge">Response</code> object. The socket will then be used to send data back to the client.</p>

    <hr />

    <h4 id="properties-1">Properties</h4>

    <ol>
      <li><code class="highlighter-rouge">sock</code> - the socket associated with the http response</li>
      <li><code class="highlighter-rouge">headers</code> - an object that has response header names as property names and response header values as property values (for example, <code class="highlighter-rouge">{"Content-Type": "text/html", "Cache-Control": "max-age=3600"}</code>)</li>
      <li><code class="highlighter-rouge">body</code> - the body of the response (such as an html document or an image)</li>
      <li><code class="highlighter-rouge">statusCode</code> - the status code of the http response as a <code class="highlighter-rouge">Number</code> (for example: <code class="highlighter-rouge">200</code>)</li>
    </ol>

    <hr />

    <h4 id="methods-1">Methods</h4>

    <p>Most of the methods in the <code class="highlighter-rouge">Response</code> either act as a proxy for <code class="highlighter-rouge">socket</code> methods (that is, you can call <code class="highlighter-rouge">end</code> on <code class="highlighter-rouge">Response</code>, which internally just calls <code class="highlighter-rouge">end</code> on its <code class="highlighter-rouge">sock</code> property) or are convenience methods for combining other <code class="highlighter-rouge">Response</code> object methods. Consequently, it would be useful to check out the <a href="../slides/06/sockets.html">slides on networking and sockets</a> before starting. Alternatively, you can also look over the <a href="https://nodejs.org/api/net.html">official node documentation on the <code class="highlighter-rouge">net</code> module</a>.</p>

    <ol>
      <li><code class="highlighter-rouge">setHeader(name, value)</code> - adds a new header name and header value pair to this <code class="highlighter-rouge">Response</code> object&#39;s internal <code class="highlighter-rouge">headers</code> property
        <ul>
          <li><code class="highlighter-rouge">name</code> - the name of the response header</li>
          <li><code class="highlighter-rouge">value</code> - the value of the response header</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.setHeader('Content-Type', 'text/html'); </code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">write(data)</code> - sends data to the client by calling the <code class="highlighter-rouge">write</code> method on this <code class="highlighter-rouge">Response</code> object&#39;s internal socket object (essentially a pass-through / proxy method to call the same method on <code class="highlighter-rouge">this.sock</code>)
        <ul>
          <li><code class="highlighter-rouge">data</code> - a <code class="highlighter-rouge">String</code> or <code class="highlighter-rouge">Buffer</code> (binary data) to be sent to the client</li>
          <li>no return value</li>
          <li>note that <em>all it does</em> is write <code class="highlighter-rouge">data</code> to the socket, nothing else (it doesn&#39;t close the connection or add additional data to <code class="highlighter-rouge">data</code> )</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.write("&lt;h2&gt;A bit o' HTML&lt;/h2&gt;"); </code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">end(s)</code> - sends data and ends the connection by callings the <code class="highlighter-rouge">end</code> method on this <code class="highlighter-rouge">Response</code> object&#39;s internal socket object (essentially a pass-through / proxy method to call the same method on <code class="highlighter-rouge">this.sock</code>)
        <ul>
          <li>note that you will not be able to send any more data on a closed socket (this also implies that you cannot call end more than once for a single request/response cycle)</li>
          <li>also note that you should not call <code class="highlighter-rouge">sock.write</code> at all in this method; again, just make the same call to <code class="highlighter-rouge">sock.end</code> (which can take an argument if you want it to write data to the socket <em>and</em> end the connection)</li>
          <li><code class="highlighter-rouge">s</code> - a <code class="highlighter-rouge">String</code> or <code class="highlighter-rouge">Buffer</code> (binary data) to be sent to the client</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.write("some stuff"); 
res.end('some more stuff'); // closes connection!
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">send(statusCode, body)</code> - sets the statusCode and the body of this <code class="highlighter-rouge">Request</code> object, sends the valid http response to the client, and closes the connection. Essentially, it sets response properties, converts the <code class="highlighter-rouge">Response</code> to a string uses the <code class="highlighter-rouge">Response</code> object&#39;s <code class="highlighter-rouge">end</code> method to send the response and close the connection&#8230; all in one method call.
        <ul>
          <li><code class="highlighter-rouge">statusCode</code> - the status code of the http response</li>
          <li><code class="highlighter-rouge">body</code> - the body of the http response</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.setHeader('Content-Type', 'text/html');
res.send(200, 'Hi there!');
// sends back the following http response (newlines are \r\n):
// HTTP/1.1 200 OK
// Content-Type: text/html
//
// Hi there!
// (then closes the connection)
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">writeHead(statusCode)</code> - sets the statusCode, and writes everything but the body, and leaves the connection open; this is simply a combination of setting the <code class="highlighter-rouge">statusCode</code> property and calling <code class="highlighter-rouge">this.write</code>
        <ul>
          <li>another way to think about it is that: it writes out all of the headers (including the status line), and after you call writeHead, you can continue writing more data, such as the body of the response with something like <code class="highlighter-rouge">write</code></li>
          <li><code class="highlighter-rouge">statusCode</code> - the status code of the http response</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.setHeader('Content-Type', 'text/html');
res.writeHead(200);
// connection isn't closed yet! we can still write more
res.write('More stuff');
res.end('');
// sends back the following http response (newlines are \r\n):
// HTTP/1.1 200 OK
// Content-Type: text/html
//
// More stuff
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">redirect(statusCode, url)</code> - redirects to the supplied <code class="highlighter-rouge">url</code> using the supplied <code class="highlighter-rouge">statusCode</code>&#8230; if <code class="highlighter-rouge">statusCode</code> is no given, then default to permanent redirect, <code class="highlighter-rouge">301</code> (for the redirect to work, the appropriate header must be set to the url provided!). Lastly, immediately sends response and closes connection.
        <ul>
          <li><code class="highlighter-rouge">statusCode</code> - (optional) the status code of the http response redirect</li>
          <li><code class="highlighter-rouge">url</code> - the url to redirect to</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.redirect(302, 'http://another.site/here');
// response is immediately sent and connection is closed
// (essentially ... set statusCode and header, then this.write and this.end or just this.end)
</code></pre>
          </li>
          <li>troubleshooting:
            <ul>
              <li>some browsers, such as Chrome, will cache redirects &#8230; so you&#39;ll have to&#8230;</li>
              <li>check with curl first to see that you&#39;re getting the right status code and headers</li>
              <li>check with your browser next, making sure to clear your browser cache before trying again (and perhaps use &quot;incognito&quot; mode)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">toString()</code> - returns a string representation of this response object that can serve as a valid http response
        <ul>
          <li>no arguments</li>
          <li>returns a string, a valid http response</li>
          <li>when adding a short description for status codes, use these descriptions:
            <ul>
              <li><code class="highlighter-rouge">200</code> - <code class="highlighter-rouge">OK</code></li>
              <li><code class="highlighter-rouge">301</code> - <code class="highlighter-rouge">Moved Permanently</code></li>
              <li><code class="highlighter-rouge">302</code> - <code class="highlighter-rouge">Found</code></li>
              <li><code class="highlighter-rouge">303</code> - <code class="highlighter-rouge">See Other</code></li>
              <li><code class="highlighter-rouge">400</code> - <code class="highlighter-rouge">Bad Request</code></li>
              <li><code class="highlighter-rouge">404</code> - <code class="highlighter-rouge">Not Found</code></li>
              <li><code class="highlighter-rouge">405</code> - <code class="highlighter-rouge">Method Not Allowed</code></li>
              <li><code class="highlighter-rouge">500</code> - <code class="highlighter-rouge">Internal Server Error</code></li>
            </ul>
          </li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.setHeader('Content-Type': 'text/plain');
res.statusCode = 404;
res.body = "Uh oh! No page here!"
console.log(res.toString());
// HTTP/1.1 404 Not Found
// Content-Type: 'text/plain'
//
// Uh oh! No page here!
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">sendFile(fileName)</code> and <code class="highlighter-rouge">handleRead(contentType, err, data) - </code>sendFile<code class="highlighter-rouge"> will use the logic in </code>handleRead<code class="highlighter-rouge"> as part of its callback to send the file specified by </code>fileName<code class="highlighter-rouge"> (which will be searched for in </code>$PROJECT_ROOT/public`) to the client by setting the appropriate content type, writing the data from the file&#8230; and immediately closing the connection after the data is sent
        <ul>
          <li><strong>this is essentially just the <code class="highlighter-rouge">sendTextFile</code> and <code class="highlighter-rouge">sendImage</code> functions from part 1 combined into a single method!</strong></li>
          <li>implementation details for both these functions are below:</li>
        </ul>
      </li>
    </ol>

    <h4 id="implementing-sendfile-and-handleread">Implementing <code class="highlighter-rouge">sendFile</code> and <code class="highlighter-rouge">handleRead</code></h4>

    <p>These two methods will be used to send back a file in an http response:</p>

    <ul>
      <li><code class="highlighter-rouge">sendFile(fileName)</code> - determines the types of file and then attempts to read a file (this function does not return a value)</li>
      <li><code class="highlighter-rouge">handleFileRead(contentType, err, data)</code> - used to handle the result of attempting to read a file; it&#39;ll send back an appropriate response: either a successful response with the file contents as part of the response body or a response the specifies a server error if the file was not successfully read (this function does not return a value)</li>
    </ul>

    <p>To implement these methods:</p>

    <ol>
      <li>In <code class="highlighter-rouge">sendFile</code>,  search for the <code class="highlighter-rouge">fileName</code> passed in as an argument within the <code class="highlighter-rouge">public</code> folder in the root of your project directory: determine the absolute path to the file name that&#39;s passed in by using <code class="highlighter-rouge">__dirname</code> to find the directory of the running application&#8230; and go up one so that <code class="highlighter-rouge">public</code> can be accessed
        <ul>
          <li>you can pass everything to <code class="highlighter-rouge">path.join</code> (as in the previous part)
 	&lt;pre&gt;<code data-trim="" contenteditable="">const filePath = path.join(__dirname, '..', 'public', '/html/foo.html');
// assuming OSX file system, with projects/homework03 in home directory
// the above code yields:
// /Users/username/projects/homework03/public/html/foo.html
</code>&lt;/pre&gt;</li>
        </ul>
      </li>
      <li>Use the extension of the file to determine:
        <ul>
          <li>if it&#39;s an image</li>
          <li>&#8230; and to figure out what the correct <code class="highlighter-rouge">Content-Type</code> should be
            <ol>
              <li><code class="highlighter-rouge">jpeg</code> or <code class="highlighter-rouge">jpg</code>: <code class="highlighter-rouge">image/jpeg</code></li>
              <li><code class="highlighter-rouge">png</code>: <code class="highlighter-rouge">image/png</code></li>
              <li><code class="highlighter-rouge">gif</code>: <code class="highlighter-rouge">image/gif</code></li>
              <li><code class="highlighter-rouge">html</code>: <code class="highlighter-rouge">text/html</code></li>
              <li><code class="highlighter-rouge">css</code>: <code class="highlighter-rouge">text/css</code></li>
              <li><code class="highlighter-rouge">txt</code>: <code class="highlighter-rouge">text/plain</code></li>
            </ol>
          </li>
        </ul>
      </li>
      <li>Call <code class="highlighter-rouge">fs.readFile</code> with:
        <ul>
          <li>the absolute path that you created</li>
          <li>if the file is text, then pass in an encoding (assume <code class="highlighter-rouge">utf8</code>) as the second argument, otherwise&#8230; if the file is an image, then don&#39;t specify an encoding by omitting this argument (it&#39;s ok to rely solely on extension to determine a text file or an image file)</li>
          <li>the last argument to <code class="highlighter-rouge">fs.readFile</code> should be a callback function
            <ul>
              <li>note that this callback should <em>make use of the</em> <code class="highlighter-rouge">handleRead</code> method defined in the same <code class="highlighter-rouge">Response</code> class as <code class="highlighter-rouge">sendFile</code></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">handleRead</code>, (again, a method in the <code class="highlighter-rouge">Response</code> object) should take a <code class="highlighter-rouge">contentType</code>, <code class="highlighter-rouge">err</code> and <code class="highlighter-rouge">data</code> as its arguments&#8230;
        <ul>
          <li>note that the callback for <code class="highlighter-rouge">fs.readFile</code> usually accepts two arguments&#8230; and within your callback, you may want to access the instance (<code class="highlighter-rouge">this</code>) that <code class="highlighter-rouge">sendFile</code> was originally called on (for example, you may want to call other instance methods, such as <code class="highlighter-rouge">writeHead</code>, <code class="highlighter-rouge">end</code>, etc.)</li>
          <li>to solve this, <strong>you must wrap a call to <code class="highlighter-rouge">handleRead</code> in an arrow function</strong> when passing it in as a callback to <code class="highlighter-rouge">fs.readFile</code></li>
          <li>using an arrow function as the callback (that calls <code class="highlighter-rouge">handleRead</code>) will set <code class="highlighter-rouge">this</code> appropriately and deal with the mismatch of number of arguments between the callback needed for <code class="highlighter-rouge">fs.readFile</code> and <code class="highlighter-rouge">handleRead</code></li>
          <li>⚠️⚠️⚠️<a href="03-sendfile-background.html">READ THIS BACKGROUND MATERIAL</a>⚠️⚠️⚠️ on using methods as callbacks and changing the number of parameters to a function/method before using the example code below
            <ul>
              <li>this background material also covers bind as part of a potential solution</li>
              <li>however, <strong>use arrow functions instead, as shown below</strong></li>
            </ul>
          </li>
          <li>here&#39;s the code you&#39;ll need within the context of <code class="highlighter-rouge">sendFile</code> and <code class="highlighter-rouge">handleRead</code> method definitions:
            <pre><code data-trim="" contenteditable="">sendFile(fileName) {
  // determine contentType
  const contentType = 'code to determine content type goes here';<br />
  // handle read has three arguments, but readFile's callback only sends 
  // two arguments... so wrap in an arrow function and call handleRead 
  // with the contentType that's in scope this also has the side effect 
  // of using the this that was within scope when the arrow function was 
  // created (which is the correct this - the instance that sendFile was 
  // called on)
  fs.readFile(filePath, readFileOptions, (err, data) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;this.handleRead(contentType, err, data)
  }<br />
  // ...rest of method implementation
}<br />
handleRead(contentType, err, data) {
  // use Response instance methods like:
  // this.writeHead, this.setHeader, this.end, etc.
  // to send back the file as the body of an http response
  // or send back an 500 server error if an error occurs while reading the
  // file
}
</code></pre>
          </li>
        </ul>
      </li>
      <li>Call the appropriate <code class="highlighter-rouge">Response</code> object methods from within <code class="highlighter-rouge">handleRead</code> to send back a response; note that the methods must be called <strong>in this order</strong> &#8594;
        <ol>
          <li>set the <code class="highlighter-rouge">Content-Type</code> header</li>
          <li>send everything but the body by calling <code class="highlighter-rouge">this.writeHead(200)</code></li>
          <li>write the data that was passed in as an argument to the callback to the socket (that is, write the data from the file)</li>
          <li>close the connection</li>
          <li>why write the headers and the body separately? This avoids any issues where the binary data of the image is inadvertently converted to a string.</li>
          <li>(again, this mimics what you implemented in part 1, but with both functions, <code class="highlighter-rouge">sendTextFile</code> and <code class="highlighter-rouge">sendImage</code> merged into a single method that handles both types of tiles)</li>
        </ol>
      </li>
      <li>Example Usage for <code class="highlighter-rouge">sendFile</code>:
        <pre><code data-trim="" contenteditable="">// assuming there's a directory called public/css in your project's root...
res.sendFile('/css/base.css');
//
// note that the url does not have to match the name/path of the file being read!
</code></pre>
      </li>
    </ol>

    <p><br /></p>

    <h3 id="testing--using-the-response-object">Testing / Using the <code class="highlighter-rouge">Response</code> Object</h3>

    <p>Once your finished with your implementation above, you can export, test and try using your new <code class="highlighter-rouge">Response</code> object.</p>

    <ol>
      <li>Export the object using <code class="highlighter-rouge">module.exports</code>, and try running the tests in test/webframework-test.js (comment out the other tests&#8230; and run <code class="highlighter-rouge">mocha</code> from within <code class="highlighter-rouge">test</code> folder)</li>
      <li>This <code class="highlighter-rouge">Response</code> object can be used replace manual calls to <code class="highlighter-rouge">write</code> and <code class="highlighter-rouge">end</code> on the socket object (since it wraps the socket object itself!)</li>
      <li>For example: <code class="highlighter-rouge">const res = new Response(sock); // pass in a socket object</code> &#8230;
        <ul>
          <li>Call to your <code class="highlighter-rouge">Response</code> object&#39;s <code class="highlighter-rouge">setHeader</code> method to set the content type: <code class="highlighter-rouge">res.setHeader(...)</code></li>
          <li>Call to your <code class="highlighter-rouge">Response</code> object&#39;s <code class="highlighter-rouge">send</code> method to send the response back with the appropriate body: <code class="highlighter-rouge">res.send(200, ...);</code></li>
          <li>Call to your <code class="highlighter-rouge">Response</code> object&#39;s <code class="highlighter-rouge">end</code> method to close the connection</li>
          <li>etc.</li>
        </ul>
      </li>
    </ol>

    <p><br /></p>

    <h3 id="app-object"><code class="highlighter-rouge">App</code> Object</h3>

    <p>The app object represents a web application. It&#39;s responsible for:</p>

    <ol>
      <li>accepting incoming http requests</li>
      <li>holding &quot;routes&quot; or url/path combinations (right now our framework will only support GETs)</li>
      <li>determining what to do based on the incoming request</li>
      <li>sending back a response</li>
    </ol>

    <p>Number 2 and 3 are determined by the user that is writing a web application with this framework. That is, they specify what routes are present &#8230; and what to do when that route is matched by writing code. For example, a hello world application could be written as follows (this is what someone using your web framework would write):</p>

    <pre><code data-trim="" contenteditable="">const App = require('./miniWeb.js').App;
const app = new App();

app.get('/hello', function(req, res) {
    res.send(200, 'HELLO WORLD');
});

app.post('/hello', function(req, res) {
    res.send(200, 'Got a POST request');
});

app.listen(8080, '127.0.0.1');
</code></pre>

    <hr />

    <h4 id="constructor-2">Constructor</h4>

    <p><code class="highlighter-rouge">App()</code> - creates a new App object and sets the connection callback function to <code class="highlighter-rouge">this.handleConnection</code> which you&#39;ll implement below &#8230; additionally, initializes its routes to empty object (see Properties section). Example usage of constructor:</p>

    <pre><code data-trim="" contenteditable="">const App = require('./miniWeb.js').App;
const app = new App();
</code></pre>

    <p>Note that when you import the module, you can set a variable directly to an exported object by using dot notation. In the example above, pull out the <code class="highlighter-rouge">App</code> constructor.</p>

    <p>The <code class="highlighter-rouge">App</code> object itself represents both a web server and the web application running on that server. Consequently, it&#39;ll hold an instance of a <code class="highlighter-rouge">Server</code> object from node&#39;s <code class="highlighter-rouge">net</code> module. See <a href="../slides/06/sockets.html#/2">the slides</a> or the <a href="https://nodejs.org/api/net.html#net_class_net_server">node documentation</a>.</p>

    <p>When you create a server using <code class="highlighter-rouge">net.createServer</code>, it expects a callback function to be specified when a client connects to the server. That callback will be a method that you define, <code class="highlighter-rouge">handleConnection</code>. However, to have a method be passed as a callback <strong>and</strong> retain its original access to the object that it belongs to, you&#39;ll have to use bind (otherwise, <code class="highlighter-rouge">this</code> will refer to the global object). In the constructor, it&#39;ll look something like this:</p>

    <pre><code data-trim="" contenteditable="">// within your constructor
this.server = net.createServer(this.handleConnection.bind(this));

// the above ensures that handleConnection will have a this that refers to the
// object created by the constructor without having to call handleConnection
// as a method on the object
</code></pre>

    <hr />

    <h4 id="properties-2">Properties</h4>

    <ol>
      <li><code class="highlighter-rouge">server</code> - an instance of the <code class="highlighter-rouge">net</code> module&#39;s <code class="highlighter-rouge">Server</code> object</li>
      <li><code class="highlighter-rouge">routes</code> - an object that maps methods and paths to callback functions
        <ul>
          <li>you can set this up any way you like</li>
          <li>for example, you can concatenate method and path to use as a property</li>
          <li>or you can have nested objects, where method is a top level property&#8230; and then paths properties of a nested object under the method property</li>
        </ul>
      </li>
    </ol>

    <hr />

    <h4 id="methods-2">Methods</h4>

    <ol>
      <li><code class="highlighter-rouge">get(path, cb)</code> - adds <code class="highlighter-rouge">GET</code> and <code class="highlighter-rouge">path</code> to &quot;key&quot; into <code class="highlighter-rouge">routes</code>&#8230; the value of which is the callback function, <code class="highlighter-rouge">cb</code>
        <ul>
          <li><code class="highlighter-rouge">path</code> - the path to respond to (that is, a valid path for the web application)</li>
          <li><code class="highlighter-rouge">callback</code> - the function called when a <code class="highlighter-rouge">GET</code> to this <code class="highlighter-rouge">path</code> is requested (essentially&#8230; what to do when a specific path is asked for)
            <ul>
              <li>the callback function will take two arguments</li>
              <li>a <code class="highlighter-rouge">Request</code> object</li>
              <li>a <code class="highlighter-rouge">Response</code> object</li>
              <li><code class="highlighter-rouge">cb(req, res) ...</code></li>
            </ul>
          </li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">app.get('/hello', function(req, res) {
 res.send(200, 'HELLO WORLD');
});
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">post(path, cb)</code> - adds <code class="highlighter-rouge">POST</code> and <code class="highlighter-rouge">path</code> to &quot;key&quot; into <code class="highlighter-rouge">routes</code>&#8230; the value of which is the callback function, <code class="highlighter-rouge">cb</code>
        <ul>
          <li><code class="highlighter-rouge">path</code> - the path to respond to (that is, a valid path for the web application)</li>
          <li><code class="highlighter-rouge">callback</code> - the function called when a <code class="highlighter-rouge">POST</code> to this <code class="highlighter-rouge">path</code> is requested (essentially&#8230; what to do when a specific path is asked for)
            <ul>
              <li>the callback function will take two arguments</li>
              <li>a <code class="highlighter-rouge">Request</code> object</li>
              <li>a <code class="highlighter-rouge">Response</code> object</li>
              <li><code class="highlighter-rouge">cb(req, res) ...</code></li>
            </ul>
          </li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">app.post('/hello', function(req, res) {
 res.send(200, 'Got a POST');
});
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">listen(port, host)</code> - binds the server to the given <code class="highlighter-rouge">port</code> and <code class="highlighter-rouge">host</code> (&quot;listens&quot; on <code class="highlighter-rouge">host</code>:<code class="highlighter-rouge">port</code>)
        <ul>
          <li><code class="highlighter-rouge">port</code> - the port number to bind to</li>
          <li><code class="highlighter-rouge">host</code> - the host that the server will be running on (for example, &#39;127.0.0.1&#39;)</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">app.listen(8080, '127.0.0.1');
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">handleConnection(sock)</code> - the function called when a client connects to the server&#8230; this will simply set the callback for the socket&#39;s <code class="highlighter-rouge">on</code> method: <code class="highlighter-rouge">sock.on('data', ...)</code> to the function below, <code class="highlighter-rouge">handleRequestData</code>
        <ul>
          <li><code class="highlighter-rouge">sock</code> - the socket representing the connection to the client (this will be supplied by the caller because this will be used as a callback function for <code class="highlighter-rouge">net.createServer</code>)</li>
          <li>no return value</li>
          <li>example usage (as a callback function for <code class="highlighter-rouge">net.createServer</code>):</li>
        </ul>
        <pre><code data-trim="" contenteditable="">this.server = net.createServer(this.handleConnection.bind(this));</code></pre>
      </li>
      <li><code class="highlighter-rouge">handleRequestData(sock, binaryData)</code> - the function called when the socket receives data from the client (our framework will not have a timeout, it&#39;ll just assume that once it receives data, that the data received is the entire request)&#8230;  this is where most of the logic of our framework will go; it processes a request and sends back a response!
        <ul>
          <li><code class="highlighter-rouge">sock</code> - the socket representing the connection to the client</li>
          <li><code class="highlighter-rouge">binaryData</code> - the data sent by the client</li>
          <li>no return value</li>
          <li>this callback is essentially responsible for processing a request and sending back a response&#8230; it will:
            <ol>
              <li>convert the incoming data to a string</li>
              <li>create a new <code class="highlighter-rouge">Request</code> object based on that string</li>
              <li>create a new <code class="highlighter-rouge">Response</code></li>
              <li>sets a callback for when the connection is closed (the callback will be to log the response using <code class="highlighter-rouge">logResponse</code> below)</li>
              <li>determine if the request is valid by checking for a <code class="highlighter-rouge">Host</code> header (it&#39;ll return a <code class="highlighter-rouge">400</code> if the request isn&#39;t valid)</li>
              <li>look up the function to call in <code class="highlighter-rouge">this.routes</code> by using the <code class="highlighter-rouge">path</code> property from the incoming <code class="highlighter-rouge">Request</code> object &#8230; <strong>make sure that urls with and without a trailing slash (/) map to the same function</strong></li>
              <li>call that function, passing in the <code class="highlighter-rouge">Request</code> and <code class="highlighter-rouge">Response</code> objects created above as arguments</li>
              <li>if the <code class="highlighter-rouge">path</code> doesn&#39;t exist in <code class="highlighter-rouge">this.routes</code>, then send back a <code class="highlighter-rouge">404</code></li>
            </ol>
          </li>
          <li>hints:
            <ul>
              <li>note that the callback for <code class="highlighter-rouge">sock.on(data, ...)</code> typically only takes a single argument</li>
              <li>however, we want access to a socket object so that we can create our <code class="highlighter-rouge">Response</code> object using that socket</li>
              <li>so&#8230; to fix the arguments, when we set <code class="highlighter-rouge">handleRequestData</code> as a callback in <code class="highlighter-rouge">handleConnection</code>, we&#39;ll have to use bind again (or arrow functions):</li>
            </ul>
          </li>
          <li>example usage:
      &lt;pre&gt;<code data-trim="" contenteditable="">// within handleConnection...
sock.on('data', this.handleRequestData.bind(this, sock));
// once again, sets this... and also sets sock so that the returned function
// only takes a single argument, binaryData</code></li>
          <li>example usage (as a callback function for <code class="highlighter-rouge">sock.on('data', ...)</code>):</li>
        </ul>
        <pre><code data-trim="" contenteditable=""> sock.on('data', this.handleRequestData.bind(this, sock)); </code></pre>
      </li>
      <li><code class="highlighter-rouge">logResponse(req, res)</code> - logs out the http request method and path&#8230; as well as the response status code and short message
        <ul>
          <li>example usage:</li>
          <li><code class="highlighter-rouge">req</code> - the incoming http request</li>
          <li><code class="highlighter-rouge">res</code> - the resulting http response</li>
          <li>no return value</li>
          <li>example usage (as a callback function for <code class="highlighter-rouge">sock.on('close', ...)</code>:
            <pre><code data-trim="" contenteditable="">// when a request / response cycle is finished, then log out some info
// note that we'll need to bind req and res assuming that they're available (which they should be...
// ...since this goes in handleRequestData, which creates both objects)
// (arrow functions will also work)
sock.on('close', this.logResponse.bind(this, req, res));
</code></pre>
          </li>
        </ul>
      </li>
    </ol>

    <h3 id="using-your-request-response-and-app-classes">Using Your <code class="highlighter-rouge">Request</code>, <code class="highlighter-rouge">Response</code>, and <code class="highlighter-rouge">App</code> Classes</h3>

    <p>Create a small site using your framework. <strong>The site should be a fan site about one of your favorite characters from a book, movie, or television show</strong>. It must adhere to the technical specifications below, but <em>actual content</em> is your discretion).</p>

    <p>In a file called <code class="highlighter-rouge">better.js</code>, create a site that responds to the following requests:</p>

    <ul>
      <li><code class="highlighter-rouge">GET /</code> - a homepage that contains links to <code class="highlighter-rouge">/form, </code>/random<code class="highlighter-rouge">, and </code>/rando`</li>
      <li><code class="highlighter-rouge">GET /css/base.css</code> - a css file linked to by every document on your site (style any way that you like, as long as it&#39;s obvious that the page is styled)</li>
      <li><code class="highlighter-rouge">GET /image1.jpg</code> - a jpg (the path must be as specified) of your favorite character</li>
      <li><code class="highlighter-rouge">GET /image2.gif</code> - a gif (the path must be as specified) of your favorite character</li>
      <li><code class="highlighter-rouge">GET /image3</code> - an image&#8230;format does not matter, gif, jpg or png, but make sure there&#39;s no extension in the url path (the file on the file system may have an extension, though)</li>
      <li><code class="highlighter-rouge">GET /random</code> - a page that displays a random image using an <code class="highlighter-rouge">img</code> tag; this must be an html page with no client side JavaScript&#8230; the server will generate a random image url to be displayed
        <ul>
          <li>this might be tricky to do by using <code class="highlighter-rouge">sendFile</code></li>
          <li>so&#8230; in this case, it may be best to put together a string containing the html&#8230; and changing the image <code class="highlighter-rouge">src</code> with a conditional</li>
          <li>alternatively, you can attempt to implement templating (perhaps create a separate <code class="highlighter-rouge">Response</code> method that will read the contents of a file and substitute portions of it)</li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">GET /rando</code> - a permanent redirect (a 301) back to <code class="highlighter-rouge">random</code></li>
      <li><code class="highlighter-rouge">GET /form</code> - a page with the following form markup (note that pressing the submit button will cause a <code class="highlighter-rouge">POST</code> request to be submitted to <code class="highlighter-rouge">/form</code>:
        <pre><code data-trim="" contenteditable="">&lt;form method="POST" action=""&gt;
  &lt;div&gt;
      Character: &lt;input type="text" name="character" value=""&gt;	
  &lt;/div&gt;
  &lt;div&gt;
      Quote: &lt;input type="text" name="quote" value=""&gt;	
  &lt;/div&gt;
  &lt;div&gt;
      &lt;input type="submit"&gt;	
  &lt;/div&gt;
&lt;/form&gt;</code></pre>
      </li>
      <li><code class="highlighter-rouge">POST /form</code> - parse the body of the incoming <code class="highlighter-rouge">POST</code> request (the body should contain the form input element names and their values) and display <strong>only the values</strong> in plain text
        <ul>
          <li>the form above contains a couple of text inputs, <code class="highlighter-rouge">character</code> and <code class="highlighter-rouge">quote</code></li>
          <li>when the form is submitted, it will take the values of the text inputs and combine them with the names of the inputs in the following format (assuming that <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">bar</code> are entered):</li>
          <li><code class="highlighter-rouge">character=foo&amp;quote=bar</code> - note that the form input elements names and their values are joined with an equal sign, <code class="highlighter-rouge">=</code></li>
          <li>name and value pairs are joined with an ampersand: <code class="highlighter-rouge">&amp;amp;</code></li>
          <li><strong>only display the values (not the names)</strong> &#8230; in the case above, only <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">bar</code> would be displayed in plain text</li>
        </ul>
      </li>
    </ul>

    <p>To create your site:</p>

    <ol>
      <li>Bring in your module and create a new <code class="highlighter-rouge">App</code> object:
        <pre><code data-trim="" contenteditable="">const App = require('./webframework.js').App;
const app = new App();
</code></pre>
      </li>
      <li>Add routes as necessary&#8230;
        <pre><code data-trim="" contenteditable="">app.get('/', function(req, res) {
  // ... do stuff here when a GET request to / is received
});
app.post('/form', function(req, res) {
  // ... do stuff here when a POST request to /form is received
});</code></pre>
      </li>
      <li>Use any mechanism you&#39;d like to send back a response (you can use <code class="highlighter-rouge">sendFile</code> and read files from <code class="highlighter-rouge">public</code>, you can just use <code class="highlighter-rouge">send</code> to send back strings of html, etc.) &#8230; obviously, for some, like images, you&#39;ll have to use specific methods</li>
      <li>Bind to a port and host with <code class="highlighter-rouge">listen</code>:
        <pre><code data-trim="" contenteditable="">app.listen(8080, '127.0.0.1');
</code></pre>
      </li>
    </ol>

    <p>Check your work</p>

    <ol>
      <li>use curl to check status codes and headers&#8230;</li>
      <li>check the pages in your browser, make sure everything renders fine with/without leading and trailing slashes</li>
      <li>make sure your redirect actually causes your browser to redirect the right way (that is, it should coerce the browser into making another request)</li>
      <li>remember to check 404&#39;s</li>
      <li>make sure that your application is logging request/response info to the console</li>
    </ol>

    <p>Here&#39;s an example of how it might all work:</p>

    <p><img src="../resources/img/hw03-web4u-11-all.gif" /></p>

  </div>

</div>
:ET