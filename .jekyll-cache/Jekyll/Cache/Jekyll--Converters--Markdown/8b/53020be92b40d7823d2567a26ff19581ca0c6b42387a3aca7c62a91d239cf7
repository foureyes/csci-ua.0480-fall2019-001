I"º.<div class="panel panel-default">
	<div class="panel-heading">Background Material on fs.readFile</div>
	<div class="panel-body">

    <h2 id="working-with-fsreadfile">Working with <code class="highlighter-rouge">fs.readFile</code></h2>

    <p>IO in node can be tricky because of its async nature and callback based API. That is, if you want to make something happen <strong>after</strong> an IO operation, such as reading a file, reading from  a network resource, writing to a database, etc. &#8230; you have to put that code in the callback function of the IO operation. A good example of this is using <a href="https://nodejs.org/api/fs.html#fs_fs_readfile_file_options_callback">fs.readFile</a>, an async function for - as the name implies - reading data from a file (note that there&#39;s an synchronous version too, but we&#39;re avoiding using that for now).</p>

    <h3 id="background">Background</h3>

    <p>The trickiest parts of <code class="highlighter-rouge">fs.readFile</code> are:</p>

    <ol>
      <li>dealing with callbacks</li>
      <li>using the right <code class="highlighter-rouge">this</code> if the callback is a method</li>
      <li>reconciling the number of arguments expected for a callback versus the actual number of arguments in the function you&#39;ll use as a callback</li>
    </ol>

    <p>This guide will cover:</p>

    <ol>
      <li>Using <code class="highlighter-rouge">fs.readFile</code></li>
      <li>Using a method as a callback for <code class="highlighter-rouge">fs.readFile</code></li>
      <li>Passing parameters to a callback</li>
    </ol>

    <p><br /></p>

    <h3 id="using-fsreadfile">Using <code class="highlighter-rouge">fs.readFile</code></h3>

    <p>We&#39;re using <code class="highlighter-rouge">fs.readFile</code> so that we can read binary data. It&#39;ll read the entire contents of a file into memory. It works like this:</p>

    <pre><code data-trim="" contenteditable="">const fs = require('fs');
fs.readFile('/tmp/foo.txt', {encoding:'utf8'}, function(err, data) {
    console.log(data);
}); 
</code></pre>

    <ul>
      <li>Note that <code class="highlighter-rouge">readFile</code>&#39;s second argument is a callback function.
        <ul>
          <li>The callback function is executed when an error occurs or the file.</li>
          <li>The callback receives an error object (which contains the error if an error occurred) and the data read from the file.</li>
          <li>If encoding was specified in the original call to <code class="highlighter-rouge">readFile</code>, then the data that&#39;s passed to the callback is a string</li>
          <li>If there is no encoding, then the raw buffer is passed as the data to the callback</li>
          <li>This is useful for reading binary data, like images:
            <pre><code data-trim="" contenteditable="">// leave encoding out of 2nd argument
fs.readFile('/tmp/myImage.gif', {}, function(err, data) {
  // we have the raw buffer!
  console.log(data);
}); 
</code></pre>
          </li>
        </ul>
      </li>
      <li>Of course, the callback doesn&#39;t have to be an anonymous function, it can be a named function as well:
        <pre><code data-trim="" contenteditable="">// in this case, we're passing in handleRead as the callback rather
// than using an anonymous function
fs.readFile('/tmp/myImage.gif', {}, handlRead); 
function handleRead(err, data) {
  console.log(data);
}
</code></pre>
      </li>
    </ul>

    <p><br /></p>

    <h3 id="using-a-method-as-a-callback">Using a method as a callback</h3>

    <p>It turns out that the callback to <code class="highlighter-rouge">readFile</code> (or any function that requires a callback) can be a method plucked from an object. However, if the callback needs to access the <code class="highlighter-rouge">this</code> property of the original object, <code class="highlighter-rouge">this</code> has to bound explicitly. Let&#39;s see the problem:</p>

    <ul>
      <li>Imagine you have the following object that represents a redacted file&#8230;</li>
      <li>It takes a <code class="highlighter-rouge">fileName</code> and a <code class="highlighter-rouge">word</code> as arguments to the constructor</li>
      <li>Calling <code class="highlighter-rouge">printFile</code> will print out the contents of the file with all occurrences of <code class="highlighter-rouge">word</code> redacted (in this case, it&#39;s replaced with the string, <code class="highlighter-rouge">SECRET</code>)</li>
      <li>Here&#39;s a possible implementation:
        <pre><code data-trim="" contenteditable="">const fs = require('fs');
class RedactedFile {
constructor(fileName, word) {
  this.fileName = fileName;
  this.word = word;
}<br />
printFile() {
 fs.readFile(this.fileName, this.handleRead); 
}<br />
handleRead(err, data) {
  // convert to string
  let s = data + '';
  // let's try to replace every occurrence of this.word!
  const replacementPattern = new RegExp(this.word, "g");
  s = s.replace(replacementPattern, 'SECRET');
  // print out the result
  console.log(s);
}
}
</code></pre>
      </li>
      <li>Now let&#39;s try running this on a file <code class="highlighter-rouge">/tmp/sensitiveData.txt</code>, which contains the following lines:
        <pre><code data-trim="" contenteditable="">I went to the pizza place next door...
and I ordered 1,000 slices of pineapple pizza.
</code></pre>
      </li>
      <li>Here&#39;s the code that we write to print out a redacted version of <code class="highlighter-rouge">/tmp/sensitiveData.txt</code>:
        <pre><code data-trim="" contenteditable="">const redacted = new RedactedFile('/tmp/sensitiveData.txt', 'pizza');
redacted.printFile();
</code></pre>
      </li>
      <li>However, when we run it, we don&#39;t get the result we expected!</li>
      <li>Instead, we get an error saying that that JavaScript cannot read the property <code class="highlighter-rouge">word</code> on <code class="highlighter-rouge">undefined</code> which implies that the <code class="highlighter-rouge">this</code> in <code class="highlighter-rouge">this.word</code> is <code class="highlighter-rouge">undefined</code></li>
      <li>How did this happen?
        <ul>
          <li><code class="highlighter-rouge">this.handleRead</code> was passed in to <code class="highlighter-rouge">fs.readFile</code> as a callback&#8230;</li>
          <li>but when the callback actually gets executed, <code class="highlighter-rouge">this</code> within the callback function isn&#39;t actually bound to the original object (because when the callback is invoked, it&#39;s not invoked as a method, but as a regular function call!)</li>
          <li>additionally, <strong>ES6 classes</strong> are in strict mode, so <code class="highlighter-rouge">this</code> in regular function calls are actually undefined (when not in strict mode, <code class="highlighter-rouge">this</code> in regular function calls is the global object or <code class="highlighter-rouge">window</code>)</li>
          <li>consequently <code class="highlighter-rouge">this.word</code> will cause an error because <code class="highlighter-rouge">this</code> is <code class="highlighter-rouge">undefined</code></li>
        </ul>
      </li>
      <li>As a result, we have to explicitly set the <code class="highlighter-rouge">this</code> value of the callback</li>
      <li>There are a few ways to do this&#8230; we&#39;ll use the way that we learned in class, which is to use arrow functions or <code class="highlighter-rouge">bind</code></li>
      <li>To use an arrow function, wrap the call to method in an arrow function so that <code class="highlighter-rouge">this</code> remains the same as the <code class="highlighter-rouge">this</code> in <code class="highlighter-rouge">printFile</code></li>
      <li>Replace <code class="highlighter-rouge">this.handleRead</code> with  (err, data) =&gt; { this.handleRead(err, data); } <code class="highlighter-rouge">this.handleRead.bind(this)</code>
        <pre><code data-trim="" contenteditable="">// fs.readFile(this.fileName, this.handleRead);
fs.readFile(this.fileName, (err, data) =&gt; { this.handleRead(err, data); });
// or with bind:
//  fs.readFile(this.fileName, this.handleRead.bind(this));`
</code></pre>
      </li>
      <li>What does that do?
        <ul>
          <li>with arrow functions - it preserves <code class="highlighter-rouge">this</code>!</li>
          <li>with bind:
            <ul>
              <li>Remember that bind gives back function.</li>
              <li>With a specified <code class="highlighter-rouge">this</code> (as given by the caller).</li>
              <li>So, it explicitly sets the <code class="highlighter-rouge">this</code> of the <code class="highlighter-rouge">handleRead</code> function to the current <code class="highlighter-rouge">this</code>, which refers to the <code class="highlighter-rouge">RedactedFile</code> object</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="http://stackoverflow.com/questions/20279484/how-to-access-the-correct-this-context-inside-a-callback/20279485#20279485">Here&#39;s an SO article to read more about it!</a> This shows a few ways to use a method as a callback by  <em>somehow</em> correctly setting <code class="highlighter-rouge">this</code>.</li>
    </ul>

    <p><br /></p>

    <h3 id="passing-arguments-to-a-callback">Passing arguments to a callback</h3>

    <p>Imagine if our <code class="highlighter-rouge">handleRead</code> function took an extra argument, a disclaimer.</p>

    <pre><code data-trim="" contenteditable="">handleRead(disclaimer, err, data) {
    let s = data + '';
    const replacementPattern = new RegExp(this.word, "g")
    s = s.replace(replacementPattern, 'SECRET');
    console.log(disclaimer);
    console.log(s);
};
</code></pre>

    <p>Now&#8230; we have an issue, because the callback that should be supplied to <code class="highlighter-rouge">readFile</code> should only have <code class="highlighter-rouge">err</code> and <code class="highlighter-rouge">data</code> as its two arguments (but now our callback has 3!). How can we transform our callback so that it only takes 2 arguments like it did before? Once again, we&#39;ll rely on arrow functions or <code class="highlighter-rouge">bind</code>!</p>

    <ol>
      <li>our arrow function can have only 2 arguments, but pass in disclaimer as the 1st argument when calling the original method
        <pre><code data-trim="" contenteditable="">printFile() {
 const disclaimer = 'This file has been redacted';
 // bind disclaimer as the first parameter
 fs.readFile(this.fileName, (err, data) =&gt; { this.handleRead(disclaimer, err, data); }); 
};
</code></pre>
      </li>
      <li><code class="highlighter-rouge">bind</code> allows us to &quot;fix&quot; a parameter or parameters of a function to specific values
        <ul>
          <li>(so we can create a new function with less parameters)</li>
          <li>for example: <code class="highlighter-rouge">const parseInt100 = parseInt.bind(null, "100")</code> &#8230;</li>
          <li>binds &quot;100&quot; to the first argument of <code class="highlighter-rouge">parseInt</code>, and returns a function that takes only one argument, the <code class="highlighter-rouge">radix</code></li>
          <li><code class="highlighter-rouge">parseInt100(2)</code> &#8230; gives us 4 (because the only argument is the radix)</li>
          <li>Consequently, the fix for a callback that requires a parameter is to use bind to fix the initial parameters:
            <pre><code data-trim="" contenteditable="">RedactedFile.prototype.printFile = function() {
 const disclaimer = 'This file has been redacted';&lt;/br&gt;
 // bind disclaimer as the first parameter
 fs.readFile(this.fileName, this.handleRead.bind(this, disclaimer)); 
};
</code></pre>
          </li>
        </ul>
      </li>
    </ol>

    <p><br /></p>

  </div>

</div>
:ET