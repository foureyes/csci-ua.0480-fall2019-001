I"ñ:<section class="intro-slide">
  <h1 id="validation-error-handling-forms">Validation, Error Handling, Forms</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="topics">Topics</h2>

  <ul>
    <li>where to implement validation</li>
    <li>validation in our schema</li>
    <li>sending errors back</li>
    <li>express-validate</li>
  </ul>

  <!--
* checking the err object
* an aside on exceptions
* throwing an exception
* use flash messages
* mongoose validation
-->

</section>

<section>
  <h2 id="mongodb-and-creating-documents">MongoDB and Creating Documents</h2>

  <p><strong>Does mongo impose any constraints on the documents that you create? Does it care if certain keys and values exist?</strong> &#8594;</p>

  <ul class="fragment">
    <li>mongo doesn&#39;t care at all!</li>
    <li>you can insert whatever document you want, with whatever key/value pairs</li>
    <li>it doesn&#39;t even matter if there&#39;s no database yet or no collection yet, it&#39;ll create those for you (<strong>remember?</strong> &#8594;)</li>
  </ul>

  <p><br /></p>

</section>

<section>
  <h2 id="mongodb-is-pretty-laid-back">MongoDB is Pretty Laid Back</h2>

  <p>Maybe too laid back. <strong>Sooo&#8230; do we just let users enter in whatever data they want?</strong> &#8594;</p>

  <p class="fragment">We <em>probably</em> shouldn&#39;t do that, of course.  <strong>So if our database doesn&#39;t deal with constraints and validations, who&#39;s going to be responsible for doing that?</strong></p>

  <p class="fragment">The application layer! <strong>But where in our application layer - client-side (in our form, through constrained form fields) or server-side (in our express app)? Why?</strong></p>

  <ul class="fragment">
    <li>at the very least, server side (you can always bypass the frontend by sending a request directly with something like the request module for node, curl, etc.)</li>
    <li>ideally, however, you&#39;d want validation on both the client and the server side (the sooner the user can get feedback, the better)</li>
    <li><strong>which poses an interesting problem&#8230;</strong> &#8594;</li>
    <li class="fragment">syncing validation</li>
  </ul>
</section>

<section>
  <h2 id="server-side-validation">Server Side Validation</h2>

  <p>Ok, so we know that we need to validate on the server side. <strong>Where in our application can we place this validation logic?</strong></p>

  <ol class="fragment">
    <li>in our database abstraction layer (our Mongoose schema)</li>
    <li>in our <em>controller</em> (our Express router)</li>
    <li>some other intermediary object / layer (maybe we&#39;ll create a form object responsible for mediating between Mongoose and our frontend)</li>
  </ol>

  <p class="fragment"><br />
We&#39;ll be looking at numbers 1 and 2. A good candidate to start with is our Schema&#8230;</p>

</section>

<section>
  <h2 id="rejected-by-mongoose">Rejected by Mongoose!</h2>

  <p>Mongoose has facilities for validation, and we&#39;re already sort of using them.  <strong>Let&#39;s see this in action by setting up a quick schema and form.</strong> &#8594;</p>

  <ul>
    <li>let&#39;s go back to our cat schema&#8230;
      <ul>
        <li>cat name</li>
        <li>cat age</li>
      </ul>
    </li>
    <li>make sure one of the fields is a Number</li>
  </ul>

  <p class="fragment"><br />
In db.js&#8230;.</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const mongoose = require('mongoose');

// back to cats!
const CatSchema = new mongoose.Schema({
  name: {type:String},
  age: Number
});

const Cat = mongoose.model('Cat', CatSchema);
mongoose.connect('mongodb://localhost/catdb'); 
</code></pre>

</section>

<section>
  <h2 id="and-the-remainder-of-the-setup-on-the-server">And the Remainder of the Setup on the Server</h2>

  <p>And, of course, <strong>require in app.js</strong>:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
require('./db');
</code></pre>

  <p class="fragment"><strong>Set up your route and handlers in index.js</strong>:</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
const mongoose = require('mongoose');
const Cat = mongoose.model('Cat');
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
router.get('/', function(req, res) {
  res.render('index');
});
</code></pre>

</section>
<section>
  <h2 id="and-the-post">And the Post</h2>

  <pre><code data-trim="" contenteditable="">
router.post('/', function(req, res) {
  console.log(req.body);
  const cat = new Cat({
    name: req.body.name, 
    age: req.body.age,
  });
  cat.save(function(err, cat, count) {
    console.log("Saved!");
  });
});
</code></pre>

</section>

<section>
  <h2 id="lastly-our-form">Lastly, Our Form</h2>

  <p>In <strong>views/index.hbs</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
&lt;form method="POST" action=""&gt;
&lt;div&gt;&lt;label&gt;Name&lt;/label&gt; &lt;input type="text" name="name"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label&gt;Age&lt;/label&gt; &lt;input type="text" name="age"&gt;&lt;/div&gt;
&lt;input type="submit"&gt;&lt;/div&gt;
&lt;/form&gt;
</code></pre>
</section>

<section>
  <h2 id="whew">Whew!</h2>

  <p>Let&#39;s try inserting&#8230; and checking our database:</p>

  <ul>
    <li><code>katy purry</code> and <code>3</code></li>
    <li><code>bill furry</code> and <code>idk!</code>
<br />
<strong>What happened to the second one? How can we find out?</strong> &#8594;</li>
    <li>insert didn&#39;t work for <code>bill furry</code></li>
    <li>log the error in our save callback</li>
    <li>looks like there was a cast error, and an error object</li>
  </ul>
</section>

<section>
  <h2 id="mongoose-validators-types">Mongoose Validators, Types</h2>

  <p>In Mongoose, Validation is defined in the SchemaType.</p>

  <ul>
    <li>it occurs when a document attempts to be saved, after defaults have been applied</li>
    <li>embedded document validation occurs as well</li>
  </ul>

  <p><br />
Remember that <code>err</code> object in our save callback? Mongoose will populate the error object if:</p>

  <ul>
    <li>the document doesn&#39;t pass built-in Mongoose schema validations</li>
    <li>the document doesn&#39;t pass custom Mongoose validations</li>
    <li>the document doesn&#39;t adhere to the types declared in the schema</li>
  </ul>

  <p><br />
Let&#39;s look at some built-in Mongoose schema validations first, since they&#39;re a bit nicer to deal with.</p>
</section>

<section>
  <h2 id="built-in-validators">Built-In Validators</h2>

  <p>Mongoose has the following built-in validators:</p>

  <ul>
    <li>all schema types can be <em>required</em></li>
    <li>Numbers can have a <em>min</em> and <em>max</em></li>
    <li>Strings can be constrained to a specific set of strings (an <em>enum</em>) or to a specific <em>match</em></li>
    <li>these all involve setting the property/field in your schema to an object</li>
  </ul>
</section>

<section>
  <h2 id="required">Required</h2>

  <pre><code data-trim="" contenteditable="">
// required
name: {type:String, required:true}

// required with a nice error message
name: {type:String, required:[true, '{PATH} is required']}
</code></pre>

  <ul>
    <li>use the required property with a boolean</li>
    <li>optionally set the value to an array, with the first element a boolean, and the second a custom error message
      <ul>
        <li>{PATH} can optionally be used a placeholder for the field/property name</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="min-and-max">Min and Max</h2>

  <p>For numbers, we have min and max&#8230;</p>

  <pre><code data-trim="" contenteditable="">
// min
age: {type:Number, min:[0, '{PATH} must be greater than {MIN}']}

// max
age: {type:Number, max:[0, '{PATH} must be less than {MAX}']}
</code></pre>

  <ul>
    <li>can gave just number or number and custom message</li>
    <li>additional placeholders include {MIN} and {MAX}</li>
    <li>you can have a min and max on the same field</li>
  </ul>
</section>

<section>
  <h2 id="enum">Enum</h2>

  <p>For strings, we have enum and match:</p>

  <pre><code data-trim="" contenteditable="">
// enum
temperament: { type: String, required: true, enum: ['annoying', 'playful'] }

//enum with message
const enumOptions = {values:['annoying', 'playful'], message:'{VALUE} is not a valid temperament'} ;

temperament: { type: String, required: true, enum: enumOptions}

// match
nickname: { type: String, match: /^\w\w\w$/ }}
</code></pre>

  <ul>
    <li>enum has an array of possible values</li>
    <li>note that to include a custom message, you must use an object with a values and message property</li>
    <li>match has regex for validation</li>
  </ul>
</section>

<section>
  <h2 id="summary-of-placeholders">Summary of Placeholders</h2>

  <ul>
    <li>{PATH} - the property name</li>
    <li>{VALUE} - the property&#39;s value</li>
    <li>{TYPE} - the validator type (&quot;regexp&quot;, &quot;min&quot;, or &quot;user defined&quot;)</li>
    <li>{MIN} - the specified minimum</li>
    <li>{MAX} - the specified maximum</li>
  </ul>
</section>

<section>
  <h2 id="need-more">Need More?</h2>

  <p><a href="http://mongoosejs.com/docs/validation.html">Custom validation also exists</a>. From the docs:</p>

  <pre><code data-trim="" contenteditable="">
// make sure every value is equal to "something"
function validator (val) {
	return val == 'something';
}
new Schema({ name: { type: String, validate: validator }});

// with a custom error message
const custom = [validator, 'Uh oh, {PATH} does not equal "something".']
new Schema({ name: { type: String, validate: custom }});
</code></pre>

  <ul>
    <li>create a function that returns true or false</li>
    <li>set that has the value of the validate property in your schema</li>
  </ul>
</section>

<section>
  <h2 id="errors">Errors</h2>

  <p>When we log out the error object for validation errors, we get:</p>

  <pre><code data-trim="" contenteditable="">
{ [ValidationError: Validation failed]
	message: 'Validation failed',
	name: 'ValidationError',
	errors:
		{ temperament:
			{ [ValidatorError: Path `temperament` is required.]
				message: 'Path `temperament` is required.',
				name: 'ValidatorError',
				path: 'temperament',
				type: 'required',
				value: '' },
		name:
			{ [ValidatorError: Path `name` is required.]
				message: 'Path `name` is required.',
</code></pre>

</section>
<section>
  <h2 id="handling-errors">Handling Errors</h2>

  <p>Now that we have errors <strong>what should we do with them? Keep them to ourselves?</strong> &#8594;</p>

  <p class="fragment">We should probably show the user if there&#39;s an issue with their input</p>

  <p class="fragment">How do you think we can show errors on the frontend?</p>

  <ul class="fragment">
    <li>check if there&#39;s an error in the router</li>
    <li>use the error object to send error messages to our view through the context</li>
    <li>display the errors
      <ul>
        <li>look at everything in errors</li>
        <li>use specific errors.propertyname</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="in-our-router">In Our Router&#8230;</h2>

  <p>Do we have an error? Check the <strong>err</strong> object in our callback. If we do, render form again with errors passed in.</p>

  <pre><code data-trim="" contenteditable="">
  const cat = new Cat({
    name: req.body.name, 
    temperament: req.body.temperament, 
    age: req.body.age
  });
  cat.save(function(err, cat, count) {
    console.log(err, cat, count);
    if (err) { 
      res.render('index', { cat:cat, err: err });
    } else {
      res.redirect('/'); 
    }
  });

</code></pre>
</section>

<section>
  <h2 id="in-our-view">In Our View</h2>

  <p>We can loop through all errors and display them above the form&#8230;</p>

  <pre><code data-trim="" contenteditable="">
{{#if err}}
&lt;ul&gt;
{{#each err.errors}}
&lt;li&gt;{{message}}&lt;/li&gt;
{{/each}}
&lt;/ul&gt;
{{/if}}
&lt;/form&gt;

</code></pre>
</section>

<section>
  <h2 id="another-way">Another Way</h2>

  <p>Or we can go field by field. Above each form element, check if there&#39;s an error for that element.</p>

  <pre><code data-trim="" contenteditable="">
{{#if err.errors.name}} 
&lt;div class="error"&gt;
{{err.errors.name.message}}
&lt;/div&gt;
{{/if}}
</code></pre>
</section>

<section>
  <h2 id="form-fields">Form Fields</h2>

  <p><strong>If you&#39;re sending errors back, should the form elements be prefilled?</strong> &#8594;</p>

  <p class="fragment">It&#39;d be courteous to fill them in with what the user had originally submitted:</p>

  <p class="fragment">You can access the value of the field in the error object&#8230;</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
&lt;div&gt;
&lt;label&gt;Name&lt;/label&gt; 
&lt;input type="text" name="name" value="{{err.errors.name.value}}"&gt;
&lt;/div&gt;
</code></pre>
</section>

<section>
  <h2 id="great">Great!</h2>

  <p><strong>But let&#39;s try a type error. Let&#39;s put in a string for a number. What do we get back?</strong> &#8594;</p>

  <p class="fragment">That&#39;s not the same error object!</p>

  <pre class="fragment"><code data-trim="" contenteditable="">
{ [CastError: Cast to number failed for value "one" at path "age"]
message: 'Cast to number failed for value "one" at path "age"',
name: 'CastError',
type: 'number',
value: 'one',
path: 'age' 
}
</code></pre>

  <p class="fragment">Unfortunately, we&#39;d have to handle that through custom validation. (!?)</p>
</section>

<section>
  <h2 id="another-option---express-validator">Another Option - Express Validator</h2>

  <p>Validation elsewhere in your app with <strong>express-validator</strong>.</p>

  <ul>
    <li>it&#39;s just middleware</li>
    <li>you can replicate and augment your Schema validation using built-in validators
      <ul>
        <li>isInt</li>
        <li>notEmpty</li>
        <li>etc.</li>
      </ul>
    </li>
  </ul>

  <pre><code data-trim="" contenteditable="">
npm install --save express-validator
</code></pre>

  <p>In your app.js:</p>
  <pre><code data-trim="" contenteditable="">
const validator = require('express-validator');

// after app.use(bodyParser...)
app.use(validator());
</code></pre>
</section>

<section>
  <h2 id="express-validator-continued">Express Validator Continued</h2>

  <p>One place you can put it is in your route handler for create. For example&#8230; add validators and collect the errors in an error object.</p>

  <pre><code data-trim="" contenteditable="">
req.checkBody('age').notEmpty().isInt();
errors = req.validationErrors(true);
</code></pre>

  <p>Aaaand&#8230; use the error object to send back go your form.</p>

  <ul>
    <li><a href="https://github.com/ctavan/express-validator">docs for express-validator</a></li>
    <li>&#8230;and <a href="https://github.com/chriso/validator.js">node-validator</a> (contains docs on built-in validators)</li>
  </ul>
</section>
:ET