I"™<style>
hr {
    color: #ccc;
    border-color: #ccc;
}
.sample-site img {
    display: block;
    width: 70%;
    height: 70%;

}

</style>

<div class="panel panel-default">
	<div class="panel-heading">Homework #3</div>
	<div class="panel-body">

    <h1 id="a-site-about-an-animal--due-friday-march-1st-at-11pm">A Site About An Animal üê∂ü¶éü¶âüê¨üê∑, Due Friday, March 1st at 11PM</h1>

    <div class="img">
      <p><img src="../resources/img/hw03-gecko-00-animation-resized.gif" alt="gecko web site" /></p>
    </div>

    <h2 id="homework-policy">Homework Policy</h2>

    <style>
strong.highlight {
	background-color: yellow;
	font-weight: bold;
	color: red;
}

</style>

    <ol>
      <li><strong class="highlight">If you need help, please contact me (office hours or set up a time to meet) or work with the tutor</strong>
        <ul>
          <li>helping or receiving help from other students is fine as long as it&#39;s <strong>limited to</strong>:
            <ul>
              <li><strong>high level discussions</strong> of algorithms / concepts / etc.</li>
              <li>help debugging</li>
            </ul>
          </li>
          <li>if you feel like there may be an issue:
            <ul>
              <li>ask me!</li>
              <li>comment your code explaining who you discussed your code with to prevent false positives for instances of cheating</li>
            </ul>
          </li>
          <li>of course, do not copy someone else&#39;s work, which leads to&#8230;</li>
        </ul>
      </li>
      <li><strong class="highlight">You must submit your own code (do not copy or distribute solutions)</strong>
        <ul>
          <li>(there have already been instances of Academic Integrity violations this semester!)</li>
          <li>distribution includes, but is not limited to:
            <ul>
              <li>emailing code</li>
              <li>pushing code to a public repository</li>
              <li>sending screenshots of your code</li>
              <li>etc.</li>
            </ul>
          </li>
          <li>copying includes, but is not limited to:
            <ul>
              <li>making digital copies of someone else&#39;s code</li>
              <li>cloning code from a repository that isn&#39;t yours</li>
              <li>using solutions found online</li>
              <li>looking at someone else&#39;s work and copying from what is displayed on their screen</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong class="highlight">Homework is checked against prior semesters, so do not copy code found online</strong>
        <ul>
          <li>do not use solutions found online</li>
          <li>homeworks submitted are checked against previous semesters&#39; homeworks</li>
        </ul>
      </li>
    </ol>

    <h2 id="overview">Overview</h2>

    <h3 id="description">Description</h3>

    <p>There are two parts to this assignment:</p>

    <ol>
      <li>using the sample code from class, refactor the code into classes, functions and objects</li>
      <li>use this code to create a website about an animal</li>
    </ol>

    <p>At the end, you&#39;ll have a reusable <em>toy</em> web framework that you can use to write simple web applications, as well as a demo site.</p>

    <p>Again, both parts will be built off of and run from node&#39;s built-in TCP server (from the <code class="highlighter-rouge">net</code> module).</p>

    <p><strong>You can only use the following two modules for this assignment</strong> &#8594;</p>

    <ol>
      <li><code class="highlighter-rouge">net</code> - a module for creating TCP servers and clients</li>
      <li><code class="highlighter-rouge">fs</code> - a module for file system related tasks, such as reading and writing files</li>
      <li><code class="highlighter-rouge">path</code> - a module for file name and path related manipulation (such as extracting an extension from a file name and joining path names)</li>
    </ol>

    <p><strong>‚ö†Ô∏èYou can&#39;t use the <code class="highlighter-rouge">http</code> module&#8230; or install additional frameworks, such as <code class="highlighter-rouge">express</code></strong></p>

    <h3 id="submission-process">Submission Process</h3>

    <p>You will be given access to a private repository on GitHub. It will contain:</p>

    <ol>
      <li>stub source files in the <code class="highlighter-rouge">src</code> directory (<code class="highlighter-rouge">app.js</code> and <code class="highlighter-rouge">webby.js</code>)</li>
      <li>some images you can use for testing in the <code class="highlighter-rouge">public/img</code> folder</li>
      <li>unit tests in <code class="highlighter-rouge">test</code></li>
      <li><strong>you&#39;ll have to create your own <code class="highlighter-rouge">package.json</code>, <code class="highlighter-rouge">package-lock.json</code>, <code class="highlighter-rouge">.gitignore</code></strong>
        <ul>
          <li>(these are required and part of grading)</li>
          <li>use <code class="highlighter-rouge">npm init</code> to create <code class="highlighter-rouge">package.json</code> (you can just press enter all the way through)</li>
          <li>remember to put <code class="highlighter-rouge">node_modules</code> in your <code class="highlighter-rouge">.gitignore</code></li>
        </ul>
      </li>
      <li>if <code class="highlighter-rouge">.eslintrc.js</code> isn&#39;t present, you can copy over your linting configuration <code class="highlighter-rouge">.eslintrc.js</code> from homework 02</li>
    </ol>

    <p><strong>Push</strong> your code to the homework repository on GitHub. Repositories will close, so make sure you push your changes before the deadline.</p>

    <h3 id="points-make-at-least-4-commits">(4 points) Make at Least 4 Commits</h3>

    <ul>
      <li>Commit multiple times throughout your development process.</li>
      <li>Make at least 4 separate commits - (for example, one option may be to make one commit per part in the homework).</li>
    </ul>

    <h2 id="part-1---getting-classy">Part 1 - Getting Classy</h2>

    <p>In this part, you&#39;ll use the <a href="../#class7">sample code</a> from our in-class demos on the <code class="highlighter-rouge">net</code> module to implement classes that mimic the <code class="highlighter-rouge">Express</code> framework (of course, you can&#39;t use <code class="highlighter-rouge">Express</code> for this). Your framework (<code class="highlighter-rouge">webby.js</code>), will be built off of node&#39;s <code class="highlighter-rouge">net</code> module. It will use the <code class="highlighter-rouge">net</code> module to create a TCP server that will allow connections from clients. It will handle an incoming http request from a client by parsing the http request, determining what do based on the request, and finally sending back an http response.</p>

    <p>This will differ from the sample code in several significant ways:</p>

    <ul>
      <li>instead of relying on functions and a single script, you&#39;ll create a module that contains classes, funtions and objects that can be brought in (using <code class="highlighter-rouge">require</code>) by another script:
        <ol>
          <li><code class="highlighter-rouge">HTTP_STATUS_CODES</code> - an object that contains mappings from status codes to descriptions</li>
          <li><code class="highlighter-rouge">MIME_TYPES</code> - an object that contains mappings from extension to MIME type</li>
          <li><code class="highlighter-rouge">getExtension</code> - a function that returns an extension based on file name</li>
          <li><code class="highlighter-rouge">getMIMEType</code> - a function that gives back MIME type based on file name</li>
          <li><code class="highlighter-rouge">Request</code> - a class that represents an http request</li>
          <li><code class="highlighter-rouge">Response</code> - a class that represents an http response&#8230; of which instances can send back a response to the client</li>
          <li><code class="highlighter-rouge">App</code> - a class that represents a web application; takes incoming requests and determines what to do based on existing middlesware, path, method, etc. &#8230;</li>
          <li><code class="highlighter-rouge">serveStatic</code> (exported as <code class="highlighter-rouge">static</code>) - a function that returns a <em>middleware</em> function that serves a file if it exists on the file stystem</li>
        </ol>
      </li>
      <li>the classes and objects provided by the framework will have several features that we did not implement in class:
        <ul>
          <li>it can add routes without needing to have knowledge about the routing implementation (that is, without having to add to a large conditional)</li>
          <li>it can add middleware that gets called before routes</li>
          <li>it should be able to handle paths with different casing, fragments, query strings, etc.</li>
          <li>it can send files from the file system without defining explicit route</li>
        </ul>
      </li>
    </ul>

    <p>Before starting, <strong>make sure to review the course materials on the net module and creating tcp/ip servers</strong>:</p>

    <ol>
      <li>üëÄ<strong>you can use the code from class samples to start your project</strong> üëÄ:
        <ul>
          <li>see <a href="../#class7">class 7 for in-class demo code on the net module</a></li>
          <li>the <em>actual</em> in class demo was <a href="../examples/sp19-class07/demo.js">demo.js</a></li>
          <li>additionally, check out this example of reading a file and serving the content of the file (which came up when a student asked about serving up facicon.ico): <a href="../examples/class07b/webServer.js">webServer.js</a>)</li>
        </ul>
      </li>
      <li>check out the <a href="../slides/06/sockets.html#/2">slides on the <code class="highlighter-rouge">net</code> module</a>, paying close attention to the <a href="../slides/06/sockets.html#/10">the last slide</a>.</li>
      <li>lastly, make sure that you can write back a valid http response by reviewing::
        <ul>
          <li><a href="../slides/05/web.html#/16">the slides on http</a></li>
          <li><a href="../slides/05/web.html#/24">and an example response</a></li>
        </ul>
      </li>
    </ol>

    <p><strong>No type checking or error handling has to be done unless specified by the description below / the unit tests provided</strong>. You&#39;ll export some of these for use in <code class="highlighter-rouge">src/app.js</code>. Minimally, implement the following (of course, you can create more functions/objects, as the ones listed below will only help with a subset of the part 1&#39;s requirements):</p>

    <h3 id="about-the-framework">About the Framework</h3>

    <p><code class="highlighter-rouge">webby.js</code> will mimic a subset of <code class="highlighter-rouge">Express</code> functionality. Consequently, your goal is to create the classes and objects specified&#8230; so that those classes and objects can in turn be sued write simple web applications.  <strong>You are making the library / objects / classes / module</strong> that makes the following <em>possible</em> ü§ì (this shows just some of the functionality of your module, not all of it):</p>

    <pre><code data-trim="" contenteditable="">// require your module
const webby = require('./webby.js');

// create a web application
const app = webby.App();

app.get('/foo', (req, res) =&gt; {
    // show the method and path of the http request on the server console;
    console.log(req.method, req.path);

    // set a custom header on the response
    res.set('X-Foo', 'bar');

    // explicitly set the status and send back a response with some html
    res.status(200).send('&lt;h1&gt;Foo&lt;/h1&gt;');
});
</code></pre>

    <h3 id="building-the-framework">Building the Framework</h3>

    <p>In <code class="highlighter-rouge">webby.js</code>&#8230;</p>

    <ol>
      <li>create some utility objects and helper functions to deal with file extension and content type</li>
      <li>create a <code class="highlighter-rouge">Request</code> object to encapsulate http requests</li>
      <li>create an <code class="highlighter-rouge">App</code> object that encapsulates your server&#8230;
        <ul>
          <li>add application level functionality, such as routing</li>
        </ul>
      </li>
      <li>create a <code class="highlighter-rouge">Response</code> object to encapsulate http responses; this object will be able to:
        <ul>
          <li>send http responses back using a socket object</li>
        </ul>
      </li>
    </ol>

    <p>You&#39;ll build off of your experience with the sample code from class by refactoring it, encapsulating the functionality that was already there, and adding more features - all with new classes and functions</p>

    <h3 id="create-some-classes-and-objects-try-the-tests">Create Some Classes and Objects, Try the Tests</h3>

    <p>In your module, <code class="highlighter-rouge">src/webby.js</code>, create the classes and objects specified below. You can periodically run the tests in <code class="highlighter-rouge">test/webby-test.js</code> to ensure that your implementations are correct. (You&#39;ll have to remember to export them with <code class="highlighter-rouge">module.exports</code>)</p>

    <p>üëÄ The test output is a bit intimidating, so - if you want - you can limit your tests by modifying them with <code class="highlighter-rouge">only</code> to <a href="https://mochajs.org/#exclusive-tests">run specific tests exclusively</a>. üëÄ</p>

    <h3 id="httpstatuscodes"><code class="highlighter-rouge">HTTP_STATUS_CODES</code></h3>

    <p>Create a module-level (<em>global</em>) object called <code class="highlighter-rouge">HTTP_STATUS_CODES</code> that maps status codes (as <code class="highlighter-rouge">Number</code>s) to descriptions. For example, <code class="highlighter-rouge">200</code> should map to <code class="highlighter-rouge">OK</code>. Minimally, this should contain <code class="highlighter-rouge">200</code>, <code class="highlighter-rouge">404</code>, and <code class="highlighter-rouge">500</code>.</p>

    <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">See MDN&#39;s listing of status codes for descriptions</a></p>

    <hr />

    <h3 id="mimetypes"><code class="highlighter-rouge">MIME_TYPES</code></h3>

    <p>Create a module-level (<em>global</em>) object called <code class="highlighter-rouge">MIME_TYPES</code> that maps file name extensions to <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME Type</a>. This is essentially the value that will be used in the <code class="highlighter-rouge">Content-Type</code> request header. For example, if a file ends with <code class="highlighter-rouge">jpg</code>, its MIME Type is <code class="highlighter-rouge">image/jpeg</code>. Minimally, this mapping should contain <code class="highlighter-rouge">jpg</code>, <code class="highlighter-rouge">jpeg</code>, <code class="highlighter-rouge">png</code>, <code class="highlighter-rouge">html</code>, <code class="highlighter-rouge">css</code>, and <code class="highlighter-rouge">txt</code> (both <code class="highlighter-rouge">jpg</code> and <code class="highlighter-rouge">jpeg</code> map to the same MIME Type).</p>

    <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">See MDN&#39;s documentation of MIME Types to see the mappings between extension and MIME Type</a></p>

    <hr />

    <h3 id="getextensionfilename"><code class="highlighter-rouge">getExtension(fileName)</code></h3>

    <p><strong>Parameters:</strong></p>

    <ul>
      <li><code class="highlighter-rouge">fileName</code> - a string representing the name of the file</li>
    </ul>

    <p><strong>Return:</strong></p>

    <ul>
      <li>the extension of the file in lowercase as a <code class="highlighter-rouge">String</code></li>
    </ul>

    <p><strong>Description:</strong></p>

    <p>Extracts the extension of a file name and normalizes it to lowercase. You can assume that everything after the last dot in a fil name is the extension. If there is no dot, then the extension is empty string. Hint: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split">split</a> or <a href="https://nodejs.org/api/path.html#path_path_extname_path">path.extname</a> may help implement this function.</p>

    <p>Example usage:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const ext1 = getExtension('foo.jpg'); // ext1 --&gt; jpg
const ext2 = getExtension('FOO.JPG'); // ext2 --&gt; jpg
const ext3 = getExtension('foo.bar.jpg'); // ext3 --&gt; jpg
const ext4 = getExtension('foo'); // ext4 --&gt; '' (empty string)
</code></pre></div>    </div>
    <hr />

    <h3 id="getmimetypefilename"><code class="highlighter-rouge">getMIMEType(fileName)</code></h3>

    <p><strong>Parameters:</strong></p>

    <ul>
      <li><code class="highlighter-rouge">fileName</code> - a string representing the name of the file</li>
    </ul>

    <p><strong>Return:</strong></p>

    <ul>
      <li>the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a> of a file based on its extension
        <ul>
          <li>minimally, support <code class="highlighter-rouge">jpg</code>/<code class="highlighter-rouge">jpeg</code>, <code class="highlighter-rouge">png</code>, <code class="highlighter-rouge">html</code>, <code class="highlighter-rouge">css</code>, <code class="highlighter-rouge">txt</code></li>
          <li>(see article above for appropriate MIME type for file name extension)</li>
          <li>empty string if MIME type can&#39;t be determined from file name</li>
        </ul>
      </li>
    </ul>

    <p><strong>Description:</strong></p>

    <p>Based on the extension of the file, give back the associated MIME Type.</p>

    <p>Hints: Use your <code class="highlighter-rouge">getExtension</code> above.</p>

    <p>Example usage:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const t1 = getMIMEType('foo.jpg'); // t1 --&gt; img/jpeg
const t2 = getMIMEType('foo'); // t2 --&gt; '' (empty string)
</code></pre></div>    </div>

    <hr />

    <h3 id="create-a-request-class">Create a <code class="highlighter-rouge">Request</code> Class</h3>

    <p>In this section, you&#39;ll implement a <code class="highlighter-rouge">Request</code> class. You&#39;ll eventually use instances of this class to conditionally serve up different content based on the <code class="highlighter-rouge">path</code> specified by the request.  The <code class="highlighter-rouge">Request</code> object <strong>represents an http request</strong>. It can take an http request as a string, parse out information about that request and expose that information as properties (such as <code class="highlighter-rouge">method</code> and <code class="highlighter-rouge">path</code>).</p>

    <p>Create the <code class="highlighter-rouge">Request</code> <em>class</em>  by implementing the following in <code class="highlighter-rouge">src/webby.js</code>:</p>

    <hr />

    <h4 id="constructor">Constructor</h4>

    <p><code class="highlighter-rouge">Request(httpRequest)</code> - creates a new request object based on the string passed in.</p>

    <pre><code data-trim="" contenteditable="">let s = ''
s += 'GET /foo.html HTTP/1.1\r\n';   // request line
s += 'Host: localhost:3000\r\n';     // headers
s += '\r\n\r\n';                     // empty line to mark the boundary between the header and body

const req = new Request(s);
</code></pre>

    <p>The string passed in will be parsed into the properties shown below. <strong>You can assume that you will always receive a valid http request</strong></p>

    <hr />

    <h4 id="properties">Properties</h4>

    <ol>
      <li><code class="highlighter-rouge">path</code> - the path requested (for example, <code class="highlighter-rouge">/foo/bar/baz.html</code>)</li>
      <li><code class="highlighter-rouge">method</code> - the http verb (for example, <code class="highlighter-rouge">GET</code> or <code class="highlighter-rouge">POST</code>)</li>
    </ol>

    <p>You don&#39;t have to worry about version, headers, etc. &#8230; This can be copied without annotation directly from the sample code if you want naive implementation (of course, feel free to parse it any way you like!):</p>

    <p><a href="../#class7">Sample code from class 7</a></p>

    <hr />

    <h3 id="testing--using-httpstatuscodes-mimetypes-getextension-getmimetype-and-the-request-class">Testing / Using <code class="highlighter-rouge">HTTP_STATUS_CODES</code>, <code class="highlighter-rouge">MIME_TYPES</code>, <code class="highlighter-rouge">getExtension</code>, <code class="highlighter-rouge">getMIMEType</code>, and the <code class="highlighter-rouge">Request</code> Class</h3>

    <p>Once you are finished with your implementation above, you can export, test and try using your new objects, functions, and <code class="highlighter-rouge">Request</code> class.</p>

    <ol>
      <li>Export the object using <code class="highlighter-rouge">module.exports</code>, and try running the tests in <code class="highlighter-rouge">test/webby-test.js</code> (use <a href="https://mochajs.org/#exclusive-tests"><code class="highlighter-rouge">.only</code></a> for each object you want to test or simply comment out the other tests)
        <ul>
          <li>install dev dependencies to run tests: npm install --save-dev mocha chai chai-match sinon mocha-sinon</li>
          <li><code class="highlighter-rouge">npx mocha test/webby-test.js</code></li>
          <li>üëÄ run the tests from within your <code class="highlighter-rouge">root</code> folder</li>
        </ul>
      </li>
      <li>Eventually, you&#39;ll be able to use this request object to parse the binary data that is passed in to the callback function <code class="highlighter-rouge">someCallback</code> in <code class="highlighter-rouge">sock.on('data', someCallback)</code></li>
      <li>As a consequence, you&#39;ll be able to use a <code class="highlighter-rouge">Request</code> instance&#39;s <code class="highlighter-rouge">method</code> and <code class="highlighter-rouge">path</code> properties  to conditionally execute code
        <ul>
          <li><code class="highlighter-rouge">const req = new Request(binaryData.toString());</code></li>
          <li><code class="highlighter-rouge">if(req.method === 'GET' &amp;&amp; req.path === '/foo') { }</code></li>
        </ul>
      </li>
    </ol>

    <h2 id="work-on-the-app-and-response-classes-in-tandem">‚ö†Ô∏èWork on the <code class="highlighter-rouge">App</code> and <code class="highlighter-rouge">Response</code> Classes in Tandem</h2>

    <p>Skim through the specs for both classes before writing code.</p>

    <p><code class="highlighter-rouge">App</code> depends on <code class="highlighter-rouge">Response</code>, so you may have to jump around a bit during implementation (for example, wait on implementing <code class="highlighter-rouge">handleRequest</code> and <code class="highlighter-rouge">processRoutes</code>)</p>

    <h3 id="create-an-app-class">Create an <code class="highlighter-rouge">App</code> Class</h3>

    <p>An instance of an <code class="highlighter-rouge">App</code> represents a web application. It&#39;s responsible for:</p>

    <ol>
      <li>accepting and parsing incoming http requests (using the <code class="highlighter-rouge">Request</code> class)</li>
      <li>holding &quot;routes&quot; (http method and path combinations) in a property called (of course) <code class="highlighter-rouge">routes</code></li>
      <li>optionally calling a middleware function if it exists on an <code class="highlighter-rouge">App</code> instance as <code class="highlighter-rouge">middleware</code> (only one middleware function can be set, which is different from how Express works)</li>
      <li>or simply determining what to do based on the incoming request path (if no middleware is present, or if middleware passes processing on to the route handlers)</li>
      <li>&#8230; and finally sending back a valid http response</li>
    </ol>

    <p>Number 2 and 3 and 5 are determined by the user that is writing a web application with this framework. That is, they specify middleware and routes &#8230; and what to do when that route is matched by writing code. For example, a hello world application could be written as follows (this is what someone using your web framework would write&#8230; where the comments are what&#39;s determined by the user of this module):</p>

    <pre><code data-trim="" contenteditable="">const webby = require('./webby.js');
const app = new webby.App();

// add me some middlware!
app.use((req, res, next) =&gt; {
    console.log(req, res);
    next();
});

// add a route
app.get('/hello', function(req, res) {
    // send back a response if route matches
    res.send('HELLO WORLD');
});

app.listen(8080, '127.0.0.1');
</code></pre>

    <hr />

    <h4 id="constructor-1">Constructor</h4>

    <p><code class="highlighter-rouge">App()</code> - creates a new App object and sets the connection callback function to <code class="highlighter-rouge">this.handleConnection</code> which you&#39;ll implement below &#8230; additionally, initializes its <code class="highlighter-rouge">routes</code> property to an empty object and its <code class="highlighter-rouge">middleware</code> property to <code class="highlighter-rouge">null</code> (see Properties section). Example usage of constructor:</p>

    <pre><code data-trim="" contenteditable="">const App = require('./webby.js');
const app = new webby.App();
</code></pre>

    <p>The <code class="highlighter-rouge">App</code> object itself represents both a web server and the web application running on that server. Consequently, it&#39;ll hold an instance of a <code class="highlighter-rouge">Server</code> object from node&#39;s <code class="highlighter-rouge">net</code> module. See <a href="../slides/06/sockets.html#/2">the slides</a> or the <a href="https://nodejs.org/api/net.html#net_class_net_server">node documentation</a>.</p>

    <p>When you create a server using <code class="highlighter-rouge">net.createServer</code>, it expects a callback function to be specified when a client connects to the server. That callback will be a method that you define, <code class="highlighter-rouge">handleConnection</code>. However, to have a method be passed as a callback <strong>and</strong> retain its original access to the object that it belongs to, you&#39;ll have to use an arrow function (preferred) or <code class="highlighter-rouge">bind</code> (otherwise, <code class="highlighter-rouge">this</code> will refer to the global object). In the constructor, it&#39;ll look something like this:</p>

    <pre><code data-trim="" contenteditable="">// within your constructor
this.server = net.createServer(sock =&gt; this.handleConnection(sock));

// alternatively, you can bind this using the bind method:
// this.server = net.createServer(this.handleConnection.bind(this));

// the above ensures that handleConnection will have a this that refers to the
// object created by the constructor without having to call handleConnection
// as a method on the object
</code></pre>

    <p>Note that many of the methods in <code class="highlighter-rouge">App</code> will be used as callbacks to other methods in <code class="highlighter-rouge">App</code>. Starting from the method that will likely be called first:</p>

    <ol>
      <li>the <code class="highlighter-rouge">constuctor</code> for this <code class="highlighter-rouge">App</code> object will use <strong><code class="highlighter-rouge">handleConnection</code></strong> as the argument to the <code class="highlighter-rouge">net</code> module&#39;s <code class="highlighter-rouge">createServer</code> so that it&#39;s called when a client connects</li>
      <li><code class="highlighter-rouge">handleConnect</code> will use <strong><code class="highlighter-rouge">handleRequest</code></strong> as a callback to a socket object <code class="highlighter-rouge">on</code> method (<code class="highlighter-rouge">sock.on</code>) so that <code class="highlighter-rouge">handleRequest</code> is called when a client sends data</li>
      <li><code class="highlighter-rouge">handleRequest</code> will use <strong><code class="highlighter-rouge">processRoutes</code></strong> as a  callback to a middleware function if it&#39;s specified or <code class="highlighter-rouge">processRoutes</code> will be invoked directly from the <code class="highlighter-rouge">App</code> instance (<code class="highlighter-rouge">this.processRoutes(...)</code>) if no middleware is set</li>
    </ol>

    <p>‚ö†Ô∏èCare must be taken in all of these methods when dealing with number of arguments and the setting of <code class="highlighter-rouge">this</code>. Use arrow functions and bind as potential solutions.</p>

    <hr />

    <h4 id="properties-1">Properties</h4>

    <ol>
      <li><code class="highlighter-rouge">server</code> - an instance of the <code class="highlighter-rouge">net</code> module&#39;s <code class="highlighter-rouge">Server</code> object; this is the object returned from the <code class="highlighter-rouge">net</code> module&#39;s <code class="highlighter-rouge">createServer</code>, and it&#39;s what will be used for accepting connections and listening for data</li>
      <li><code class="highlighter-rouge">routes</code> - an object that maps methods and paths to callback functions</li>
      <li><code class="highlighter-rouge">middlware</code> - a function that gets called before the functions in <code class="highlighter-rouge">routes</code>&#8230; which enables the user to add features that will be executed before a function from <code class="highlighter-rouge">routes</code> is called;  it&#39;ll be useful for:
        <ul>
          <li>adding logging</li>
          <li>serving static files (see <code class="highlighter-rouge">serveStatic</code> later on in these specifications)</li>
        </ul>
      </li>
    </ol>

    <p>(see constructor for initial values)</p>

    <hr />

    <h4 id="methods">Methods</h4>

    <ol>
      <li><code class="highlighter-rouge">normalizePath(path)</code> - takes a path and normalizes casing and trailing slash. Additionally, removes the fragment or querystring if present (does not have to handle both query string and fragment in same path, though).
        <ul>
          <li><code class="highlighter-rouge">path</code> - the path part of a url (for example the path for <code class="highlighter-rouge">http://foo.bar/baz/qux</code> is <code class="highlighter-rouge">/baz/qux</code>)</li>
          <li>returns a <code class="highlighter-rouge">String</code>, the normalized path</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">let p;
// in all cases, p is /foo
p = app.normalizePath('/FOO'); 
p = app.normalizePath('/foo#bar');
p = app.normalizePath('/foo?bar=baz');
p = app.normalizePath('/foo/');
p = app.normalizePath('/foo/?bar=baz');
p = app.normalizePath('/foo/#bar');
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">createRouteKey(method, path)</code> - takes a an http method and path, normalizes both, and concatenates them in order to create a key that uniquely identifies a route in the <code class="highlighter-rouge">routes</code> object (this will essentially be the property name)
        <ul>
          <li><code class="highlighter-rouge">method</code> - an http method such as <code class="highlighter-rouge">GET</code> or <code class="highlighter-rouge">POST</code></li>
          <li><code class="highlighter-rouge">path</code> - the path part of a url (for example the path for <code class="highlighter-rouge">http://foo.bar/baz/qux</code> is <code class="highlighter-rouge">/baz/qux</code>)</li>
          <li>returns a <code class="highlighter-rouge">String</code>, a property name suitable to uniquely identify a route in the <code class="highlighter-rouge">routes</code> property of an <code class="highlighter-rouge">App</code> object</li>
          <li>to create the property name, uppercase method and use the <code class="highlighter-rouge">normalizePath</code> method defined earlier for the path. Concatenate the two values, with a space between.</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">const k = app.createRouteKey('GET', '/FOO/?bar=baz') // p is GET /foo
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">get(path, cb)</code> - adds <code class="highlighter-rouge">GET</code> and <code class="highlighter-rouge">path</code> together to create a &quot;key&quot;, which will be used to map to a value - the callback function, <code class="highlighter-rouge">cb</code> (the function to be called when a request matching its key&#39;s method and path comes in)
        <ul>
          <li><code class="highlighter-rouge">path</code> - the path to respond to (that is, a valid path for the web application)</li>
          <li><code class="highlighter-rouge">cb</code> - the function called when a <code class="highlighter-rouge">GET</code> to this <code class="highlighter-rouge">path</code> is requested (essentially&#8230; what to do when a specific path is asked for)
            <ul>
              <li>the callback function will take two arguments</li>
              <li>a <code class="highlighter-rouge">Request</code> object</li>
              <li>a <code class="highlighter-rouge">Response</code> object</li>
              <li><code class="highlighter-rouge">cb(req, res) ...</code></li>
            </ul>
          </li>
          <li>no return value</li>
          <li>Hint: use one of the other methods specified earlier to make sure that the key added to <code class="highlighter-rouge">routes</code> can deal with casing, trailing slash, etc.</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">app.get('/hello', function(req, res) {
 res.send('HELLO WORLD');
});
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">use(cb)</code> - sets the <code class="highlighter-rouge">middleware</code> property for this instance of <code class="highlighter-rouge">App</code>
        <ul>
          <li><code class="highlighter-rouge">cb</code> - the function called before every route handler in <code class="highlighter-rouge">routes</code>
            <ul>
              <li>the callback function will take three arguments</li>
              <li>a <code class="highlighter-rouge">Request</code> object</li>
              <li>a <code class="highlighter-rouge">Response</code> object</li>
              <li>a <code class="highlighter-rouge">next</code> function - representing the next function to call after the middeware is done processing the <code class="highlighter-rouge">Request</code> (which basically allows the processing af a <code class="highlighter-rouge">Request</code> to optionally continue through the route handling functions in <code class="highlighter-rouge">routes</code>)</li>
            </ul>
          </li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">app.use((req, res, next) =&gt; {
 // log out the path for EVERY incoming request
 console.log(req.path);
 // allow the processing to continue to route handlers
 next();
});
</code></pre>
            <pre><code data-trim="" contenteditable="">// OR...
app.use((req, res, next) =&gt; {
 // send back the response right away and ignore any route handliers in routes
 res.send('HELLO WORLD');
});
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">listen(port, host)</code> - binds the server to the given <code class="highlighter-rouge">port</code> and <code class="highlighter-rouge">host</code> (&quot;listens&quot; on <code class="highlighter-rouge">host</code>:<code class="highlighter-rouge">port</code>)
        <ul>
          <li><code class="highlighter-rouge">port</code> - the port number to bind to</li>
          <li><code class="highlighter-rouge">host</code> - the host that the server will be running on (for example, &#39;127.0.0.1&#39;)</li>
          <li>no return value</li>
          <li>this essentially will just call the same method name on the internal tcp/ip server (<code class="highlighter-rouge">.server</code> property)</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">app.listen(8080, '127.0.0.1');
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">handleConnection(sock)</code> - the function called when a client connects to the server; it will, in turn, specify which function to call when this <code class="highlighter-rouge">App</code> instance receives data from the connected client (that is, it will set the callback for the socket&#39;s <code class="highlighter-rouge">on</code> method: <code class="highlighter-rouge">sock.on('data', ...)</code> to the function specified below, <code class="highlighter-rouge">handleRequest</code>)
        <ul>
          <li><code class="highlighter-rouge">sock</code> - the socket representing the connection to the client (this will be supplied by the caller because this will be used as a callback function for <code class="highlighter-rouge">net.createServer</code>)</li>
          <li>no return value</li>
          <li>‚ö†Ô∏èwhen you set the callback function of <code class="highlighter-rouge">sock.on</code> to <code class="highlighter-rouge">handleRequest</code> within this function, you&#39;ll have to find a way to turn <code class="highlighter-rouge">handleRequest</code> (see below) into a function that takes one argument instead of two (<a href="https://nodejs.org/api/net.html#net_event_data">the callback to <code class="highlighter-rouge">sock.on('data', ...)</code> is only passed a <code class="highlighter-rouge">String</code> or <code class="highlighter-rouge">Buffer</code>, not a <code class="highlighter-rouge">Socket</code></a>!)</li>
          <li>example usage (as a callback function for <code class="highlighter-rouge">net.createServer</code>):
            <pre><code data-trim="" contenteditable="">this.server = net.createServer(sock =&gt; this.handleConnection(sock));</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">handleRequest(sock, binaryData)</code> - the function called when the socket receives data from the client (our framework will not have a timeout, it&#39;ll just assume that once it receives data, that the data received is the entire request)&#8230;  this is where your app will create <code class="highlighter-rouge">Request</code> and <code class="highlighter-rouge">Response</code> objects and determine whether or not it should call the <code class="highlighter-rouge">middleware</code> function
        <ul>
          <li><code class="highlighter-rouge">sock</code> - the socket representing the connection to the client</li>
          <li><code class="highlighter-rouge">binaryData</code> - the data sent by the client</li>
          <li>no return value</li>
          <li>this function is responsible for:
            <ol>
              <li>creating a new <code class="highlighter-rouge">Request</code> object (built from <code class="highlighter-rouge">binaryData</code>) that represents the incoming request and a new <code class="highlighter-rouge">Response</code> object that represents the potential response,</li>
              <li>calling the <code class="highlighter-rouge">middleware</code> function if it&#39;s been set (not <code class="highlighter-rouge">null</code>)
                <ol>
                  <li>if it exists, call the middlware function with the <code class="highlighter-rouge">Request</code> and <code class="highlighter-rouge">Response</code> object&#8230; and a <code class="highlighter-rouge">next</code> function that causes the processing of the defined <code class="highlighter-rouge">routes</code>, <code class="highlighter-rouge">processRoutes</code> (specified below)&#8230;</li>
                  <li>the call should look like <code class="highlighter-rouge">this.middleware(yourRequestObj, yourResponseObj, theNextFuncion)</code>, where <code class="highlighter-rouge">theNextFunction</code> is <code class="highlighter-rouge">processRoutes</code> (again, defined below)</li>
                  <li>this will essentially cause the <code class="highlighter-rouge">middleware</code> function to be invoked, and <code class="highlighter-rouge">next</code> function will give the <code class="highlighter-rouge">middleware</code> function to potentially continue processing routes (like normal)</li>
                  <li>for example&#8230; your middleware may log every request&#8230; and call <code class="highlighter-rouge">next</code> so that the proper function is called from <code class="highlighter-rouge">routes</code></li>
                  <li>‚ö†Ô∏è note that in this case, care must be taken with the way that <code class="highlighter-rouge">processRoutes</code> is passed in as the <code class="highlighter-rouge">next</code> function so that its <code class="highlighter-rouge">this</code> value is the <code class="highlighter-rouge">App</code> instance</li>
                </ol>
              </li>
              <li>if there&#39;s no <code class="highlighter-rouge">middleware</code> function, check if the <code class="highlighter-rouge">Request</code> object&#39;s <code class="highlighter-rouge">method</code> and <code class="highlighter-rouge">path</code> matches any of the defined routes in the <code class="highlighter-rouge">App</code> object&#39;s <code class="highlighter-rouge">routes</code> property by calling <code class="highlighter-rouge">processRoutes</code> (specified below) with the <code class="highlighter-rouge">Request</code> and <code class="highlighter-rouge">Response</code> objects created earlier in this method</li>
            </ol>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">processRoutes(req, res)</code> - calls the appropriate function stored in <code class="highlighter-rouge">routes</code> to handle the incoming request based on <code class="highlighter-rouge">method</code> and <code class="highlighter-rouge">path</code>
        <ul>
          <li><code class="highlighter-rouge">req</code> - the incoming http request</li>
          <li><code class="highlighter-rouge">res</code> - the resulting (potential) http response</li>
          <li>no return value</li>
          <li>this is responsible for determining if the incoming request is supported (based on <code class="highlighter-rouge">method</code> and <code class="highlighter-rouge">path</code>) and sending back a response&#8230; it will:
            <ol>
              <li>look up the function to call in <code class="highlighter-rouge">this.routes</code> by using the <code class="highlighter-rouge">method</code> and <code class="highlighter-rouge">path</code> property from the incoming <code class="highlighter-rouge">Request</code> object
                <ul>
                  <li>Hint: <strong>use a method defined earlier to help deal with casing, traling paths, etc.</strong></li>
                </ul>
              </li>
              <li>call the function if it&#39;s found in <code class="highlighter-rouge">routes</code> by passing in the <code class="highlighter-rouge">Request</code> and <code class="highlighter-rouge">Response</code> objects that were previously passed in to this function as arguments</li>
              <li>if the <code class="highlighter-rouge">path</code> and <code class="highlighter-rouge">method</code> combination doesn&#39;t exist in <code class="highlighter-rouge">this.routes</code>, then send back a <code class="highlighter-rouge">404</code> and a plain text response saying <code class="highlighter-rouge">Page not found.</code> (note - this does not mean <code class="highlighter-rouge">return</code> from the function, but instead, create an http response and &quot;send&quot; it to the client)</li>
            </ol>
          </li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">// assuming that req and res are available:
this.processRoutes(req, res);
</code></pre>
          </li>
        </ul>
      </li>
    </ol>

    <hr />

    <h3 id="create-a-response-class">Create a <code class="highlighter-rouge">Response</code> Class</h3>

    <p>Instead of directly calling  <code class="highlighter-rouge">write</code> on the<code class="highlighter-rouge">socket</code> object, wrap the <code class="highlighter-rouge">socket</code> up in a <code class="highlighter-rouge">Response</code> object and use that to send data to the client. Notice that all of the <code class="highlighter-rouge">methods</code> called on socket are being being called by equivalent methods on your <code class="highlighter-rouge">Response</code> object.</p>

    <p>The <code class="highlighter-rouge">Response</code> object represents an http response, and it allows direct manipulation of the underlying socket that represents the current connection for the http request/response. It can hold data about an http response, turn that data into a valid http response&#8230; and send that data back to the client (as well as close the connection between the server and the client).</p>

    <p>Create a <code class="highlighter-rouge">Response</code> <em>class</em> based on the <a href="#response">specifications below</a>.</p>

    <p>Again, you can run unit tests as you work, by adding the object to <code class="highlighter-rouge">module.exports</code>, and running the tests in <code class="highlighter-rouge">test/webby-test.js</code>. Remember to use <code class="highlighter-rouge">.only</code> or comment out other tests if you&#39;re only interested in a specific test.</p>

    <p><a name="response"></a></p>

    <hr />

    <h4 id="constructor-2">Constructor</h4>

    <p><code class="highlighter-rouge">Response(socket, statusCode, version)</code> - creates a new response object using the socket passed in as the internal socket for interfacing (<code class="highlighter-rouge">write</code>, <code class="highlighter-rouge">end</code>, etc.) with the connected client</p>

    <ul>
      <li><code class="highlighter-rouge">version</code> and <code class="highlighter-rouge">statusCode</code> can be used to initialize the <code class="highlighter-rouge">version</code> and <code class="highlighter-rouge">statusCode</code> properties (specified below)</li>
      <li>If <code class="highlighter-rouge">version</code> and <code class="highlighter-rouge">statusCode</code> are not passed in, the default value for <code class="highlighter-rouge">version</code> should be <code class="highlighter-rouge">"HTTP/1.1"</code> and <code class="highlighter-rouge">200</code> for <code class="highlighter-rouge">statusCode</code>.</li>
    </ul>

    <pre><code data-trim="" contenteditable="">// assuming a socket, sock, exists
const res = new Response(sock);

// or...
const res = new Response(sock, 301);

// or...
const res = new Response(sock, 301, "HTTP/1.1");
</code></pre>

    <p>The constructor will set the socket instance passed in as a property on the resulting <code class="highlighter-rouge">Response</code> object. The socket will then be used to send data back to the client. The other properties, <code class="highlighter-rouge">statusCode</code> and <code class="highlighter-rouge">version</code>, will be set to either the arguments passed in or or default values.</p>

    <hr />

    <h4 id="properties-2">Properties</h4>

    <ol>
      <li><code class="highlighter-rouge">sock</code> - the socket associated with the http response</li>
      <li><code class="highlighter-rouge">headers</code> - an object that has response header names as property names and response header values as property values (for example, <code class="highlighter-rouge">{"Content-Type": "text/html", "Cache-Control": "max-age=3600"}</code>)</li>
      <li><code class="highlighter-rouge">body</code> - the body of the response (such as an html document or an image)</li>
      <li><code class="highlighter-rouge">statusCode</code> - the status code of the http response as a <code class="highlighter-rouge">Number</code> (for example: <code class="highlighter-rouge">200</code>)</li>
      <li><code class="highlighter-rouge">version</code> - the version of the http response as a <code class="highlighter-rouge">String</code> (for example: <code class="highlighter-rouge">HTTP/1.1</code>)</li>
    </ol>

    <hr />

    <h4 id="methods-1">Methods</h4>

    <p>Most of the methods in the <code class="highlighter-rouge">Response</code> either act as a proxy for <code class="highlighter-rouge">socket</code> methods (that is, you can call <code class="highlighter-rouge">end</code> on <code class="highlighter-rouge">Response</code>, which internally just calls <code class="highlighter-rouge">end</code> on its <code class="highlighter-rouge">sock</code> property) or are convenience methods for combining other <code class="highlighter-rouge">Response</code> object methods. Consequently, it would be useful to check out the <a href="../slides/06/sockets.html">slides on networking and sockets</a> before starting. Alternatively, you can also look over the <a href="https://nodejs.org/api/net.html">official node documentation on the <code class="highlighter-rouge">net</code> module</a>.</p>

    <ol>
      <li><code class="highlighter-rouge">set(name, value)</code> - adds a new header name and header value pair to this <code class="highlighter-rouge">Response</code> object&#39;s internal <code class="highlighter-rouge">headers</code> property
        <ul>
          <li><code class="highlighter-rouge">name</code> - the name of the response header</li>
          <li><code class="highlighter-rouge">value</code> - the value of the response header</li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.set('Content-Type', 'text/html'); </code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">end()</code> - ends the connection by callings the <code class="highlighter-rouge">end</code> method on this <code class="highlighter-rouge">Response</code> object&#39;s internal socket object (essentially a pass-through / proxy method to call the same method on <code class="highlighter-rouge">this.sock</code>)
        <ul>
          <li>note that you will not be able to send any more data on a closed socket (this also implies that you cannot call end more than once for a single request/response cycle)</li>
          <li>also note that you should not call <code class="highlighter-rouge">sock.write</code> at all in this method; just call <code class="highlighter-rouge">sock.end</code></li>
          <li>no return value</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.end(); // closes connection!
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">statusLineToString()</code> - returns the the first line of an http response based on the properties defined in this <code class="highlighter-rouge">Response</code> instance (including the trailing newline)
        <ul>
          <li>no parameters</li>
          <li>returns a <code class="highlighter-rouge">String</code> representing the first line in an http response (the <em>status</em> line): if <code class="highlighter-rouge">statusCode</code> is set to <code class="highlighter-rouge">200</code> and <code class="highlighter-rouge">version</code> is set to <code class="highlighter-rouge">HTTP/1.1</code>, then the resulting <code class="highlighter-rouge">String</code> should be <code class="highlighter-rouge">"HTTP/1.1 200 OK\r\n"</code></li>
          <li>HINT: use one of the function you&#39;ve already defined to add the description of the status code</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">// assuming 200 and HTTP/1.1
this.statusLineToString() // --&gt; HTTP/1.1 200 OK with \r\n at the end
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">headersToString()</code>
        <ul>
          <li>no parameters</li>
          <li>returns a <code class="highlighter-rouge">String</code> representing the headers of this http response (both the name and the value), with each header name/value pair ending with <code class="highlighter-rouge">"\r\n"</code></li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">// assuming headers are {'X-Foo': 'bar', 'X-Baz': 'qux'}
this.headersToString(); 
// X-Foo: bar
// X-Baz: qux
// with \r\n after each name/value pair
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">send(body)</code> - sets the <code class="highlighter-rouge">body</code> property of this <code class="highlighter-rouge">Response</code> object. Sends a valid http response to the client based on this <code class="highlighter-rouge">Response</code> object&#39;s properties (<code class="highlighter-rouge">statusCode</code>, <code class="highlighter-rouge">version</code>, and <code class="highlighter-rouge">headers</code>) and the <code class="highlighter-rouge">body</code> argument, and closes the connection.
        <ul>
          <li><code class="highlighter-rouge">body</code> - the body of the http response</li>
          <li>no return value</li>
          <li>It will set the <code class="highlighter-rouge">Content-Type</code> header to <code class="highlighter-rouge">text/html</code> if the header doesn&#39;t exist in <code class="highlighter-rouge">headers</code>. * ‚ö†Ô∏èIt should write the status line and headers to the socket first&#8230; and then write the body (note that there an extra <code class="highlighter-rouge">"\r\n"</code> should be sent out before the body to separate the body from what was written out before.</li>
          <li>HINT: ‚ö†Ô∏èagain, write out the status line (first line), headers, and extra new line before writing out the body (use this <code class="highlighter-rouge">Response</code> object&#39;s <code class="highlighter-rouge">sock</code> property to do this with <code class="highlighter-rouge">sock.write</code>)</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">res.setHeader('Content-Type', 'text/html');
res.send('Hi there!');
// sends back the following http response (newlines are \r\n):
// HTTP/1.1 200 OK
// Content-Type: text/html
//
// Hi there!
// (then closes the connection)
</code></pre>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">status(statusCode)</code> - sets the <code class="highlighter-rouge">statusCode</code>, and returns the <code class="highlighter-rouge">Response</code> object that it was called on (essentially <code class="highlighter-rouge">return this</code>) to support method chaining
        <ul>
          <li><code class="highlighter-rouge">statusCode</code> - the status code of the http response</li>
          <li>returns a <code class="highlighter-rouge">Response</code> object (the same one that it was called on)</li>
          <li>example usage:
            <pre><code data-trim="" contenteditable="">// set the statusCode property and chain a send off the return value
res.status(301).send('...');
</code></pre>
          </li>
        </ul>
      </li>
    </ol>

    <hr />

    <h3 id="testing--using-the-app-and-response-classes">Testing / Using the <code class="highlighter-rouge">App</code> and <code class="highlighter-rouge">Response</code> Classes</h3>

    <p>Once your finished with your implementation above, you can export, test and try using your new <code class="highlighter-rouge">App</code> and <code class="highlighter-rouge">Response</code> classes.</p>

    <ol>
      <li>Export all of the functions and classes that you&#39;ve created using <code class="highlighter-rouge">module.exports</code>, and try running the tests in <code class="highlighter-rouge">test/webby-test.js</code>
        <ul>
          <li>(again, you can use <code class="highlighter-rouge">.only</code> to run certain tests one-by-one or comment out other tests)</li>
          <li>some methods don&#39;t have tests (for example, <code class="highlighter-rouge">listen</code> is not covered)</li>
        </ul>
      </li>
      <li>If everything the tests for <code class="highlighter-rouge">App</code>, <code class="highlighter-rouge">Response</code> (and the other previously defined functions and class), you can modify <code class="highlighter-rouge">src/app.js</code> to create a simple web application (which you&#39;ll replace later):
        <pre><code data-trim="" contenteditable="">const webby = require('./webby.js');
const app = new webby.App();</code></pre>
        <pre><code data-trim="" contenteditable="">// add me some middlware!
app.use((req, res, next) =&gt; {
 console.log(req.method, req.path);
 next();
});
</code></pre>
        <pre><code data-trim="" contenteditable="">// add a route
app.get('/hello', function(req, res) {
 // send back a response if route matches
 res.send('&lt;h1&gt;HELLO WORLD&lt;/h1&gt;');
});</code></pre>
        <pre><code data-trim="" contenteditable="">app.listen(3000, '127.0.0.1');</code></pre>
        <ul>
          <li>if everything is running properly, then:
            <ul>
              <li>regardless of what url you use in your browser, your server (that is, the terminal where you started your server) will log out the request method and request path of every incoming request</li>
            </ul>
          </li>
          <li>going to <code class="highlighter-rouge">/hello</code> will give back HELLO WORLD in a header tag (the html should be rendered, and you <em>shouldn&#39;t</em> see angle brackets / <code class="highlighter-rouge">h1</code> tags)</li>
          <li>going to any other url should give back a <code class="highlighter-rouge">404</code> (send back a 404 http response to the client) and a plain text response in the browser saying <code class="highlighter-rouge">Page not found</code></li>
        </ul>
      </li>
    </ol>

    <hr />

    <h3 id="create-servestatic-middleware">Create <code class="highlighter-rouge">serveStatic</code> middleware</h3>

    <p>Whew! üòì &#8230; that&#39;s already <em>a lot</em> of functionality, but we don&#39;t have a way of serving up files form the file system. <strong>Let&#39;s write this up by creating a function that creates a middleware function&#8230; that will read a file based on a request path or call a <code class="highlighter-rouge">next</code> function to continue processing routes regularly</strong>.</p>

    <p>In your module, create a standalone function that returns a new middleware function.</p>

    <ul>
      <li>again, this new middleware function will attempt to read a file from disk based on the request path</li>
      <li>if it exists / there are no erros in reading, the file will be served by sending back an appropriate http response (and the <code class="highlighter-rouge">routes</code> defined in the <code class="highlighter-rouge">App</code> object will be skipped)</li>
      <li>if it doesn&#39;t exist, then the rest of the <code class="highlighter-rouge">routes</code> will checked to see if a there&#39;s a match for the incoming request <code class="highlighter-rouge">method</code> and <code class="highlighter-rouge">path</code></li>
    </ul>

    <p>Write the following in <code class="highlighter-rouge">src/webby.js</code>:</p>

    <hr />

    <p><code class="highlighter-rouge">serveStatic(basePath)</code></p>

    <ul>
      <li><code class="highlighter-rouge">basePath</code> is the location where your application should attempt to read files from</li>
      <li>it returns a new function
        <ul>
          <li>the new function will have 3 arguments:
            <ul>
              <li><code class="highlighter-rouge">req</code> - an instance of <code class="highlighter-rouge">Request</code> representing the incoming http request</li>
              <li><code class="highlighter-rouge">res</code> - an instance of <code class="highlighter-rouge">Response</code> representing the poential response</li>
              <li><code class="highlighter-rouge">next</code> - the next function to call</li>
            </ul>
          </li>
          <li>construct a path on the file system to attempt to read the file by using the <code class="highlighter-rouge">path</code> module and <code class="highlighter-rouge">path.join</code> (see the example code) on the <code class="highlighter-rouge">basePath</code> and the path from the <code class="highlighter-rouge">Request</code> object, <code class="highlighter-rouge">req.path</code>;
            <ul>
              <li>for example, if <code class="highlighter-rouge">serveStatic</code> were called with <code class="highlighter-rouge">/projects/myname-homework03/public</code> and the incoming http request contained <code class="highlighter-rouge">/css/styles.css</code>, the resulting middleware function returned from <code class="highlighter-rouge">serveStatic</code> will attempt to read:
                <ul>
                  <li><code class="highlighter-rouge">/projects/myname-homework03/public/css/styles.css</code></li>
                </ul>
              </li>
              <li>use the two argument version of <code class="highlighter-rouge">fs.readFile</code> to read from the file system (‚ö†Ô∏è only pass in the path and the the callback, don&#39;t specify options or encoding!)
                <ul>
                  <li>‚ö†Ô∏è check out the <a href="https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback">docs for fs.readFile first</a></li>
                  <li>‚ö†Ô∏è here&#39;s some <a href="../examples/class07b/webServer.js">sample code that combines the <code class="highlighter-rouge">net</code> module with <code class="highlighter-rouge">fs.readFile</code></a></li>
                  <li>‚ö†Ô∏è finally, read <a href="03-sendfile-background.html">some notes on fs.readFile and <code class="highlighter-rouge">this</code></a></li>
                </ul>
              </li>
              <li>if reading the file is successful, use the <code class="highlighter-rouge">Response</code> object passed in to send back the contents of the file that was read</li>
              <li>HINT: use one / some of the <code class="highlighter-rouge">Response</code> object&#39;s methods to do this</li>
              <li>you&#39;ll have to find a way to set the correct status and the right <code class="highlighter-rouge">Content-Type</code> in your response; it&#39;s adequate to use the extension of the file to determine a content type</li>
            </ul>
          </li>
          <li>if <em>any</em> error occurs (it&#39;s adequate to check the <code class="highlighter-rouge">err</code> argument passed into the <code class="highlighter-rouge">fs.readFile</code> callback), such as the file not being found, then call the <code class="highlighter-rouge">next</code> function passed in with the <code class="highlighter-rouge">Request</code> and <code class="highlighter-rouge">Response</code> objects as arguments
            <ul>
              <li>this <code class="highlighter-rouge">next</code> function is likely going to be <code class="highlighter-rouge">processRoutes</code> from the <code class="highlighter-rouge">App</code> object above</li>
              <li>the implementation of this detail should aready be done in your <code class="highlighter-rouge">App</code> object within its <code class="highlighter-rouge">handleRequest</code> method</li>
              <li>(remember, you have to be ‚ö†Ô∏è careful about making sure <code class="highlighter-rouge">this</code> is properly set)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>export <code class="highlighter-rouge">serveStatic</code> as <code class="highlighter-rouge">static</code> (this is the only function that you&#39;ll rename in your export&#8230;)</li>
      <li>example usage:
        <pre><code data-trim="" contenteditable="">// use the middleware function returned from calling 
// serveStatic (named static off of the module)
// note that the basePath is set by using path.join(__dirname, ...)
// this is to set the path where files are read from  to
// the public folder in the project root
app.use(webby.static(path.join(__dirname, '..', 'public')));
</code></pre>
      </li>
    </ul>

    <hr />

    <h3 id="testing-your-middleware">Testing your Middleware</h3>

    <p>At this point, all of the tests in <code class="highlighter-rouge">test/webby-test.js</code> should be passing&#8230; and you can use your new web framework!</p>

    <h2 id="part-2---your-animal-site-">Part 2 - Your Animal Site üê∂ü¶éü¶âüê¨üê∑</h2>

    <p>Choose an animal to create a site about. Go back to <code class="highlighter-rouge">src/app.js</code> and comment out your previous code. Write a new app (served from <code class="highlighter-rouge">localhost</code> on port <code class="highlighter-rouge">3000</code>) about an animal that responds to the following requests:</p>

    <ol>
      <li><code class="highlighter-rouge">GET /</code> - responds with a page that links to <code class="highlighter-rouge">/gallery</code>&#8230; this should be implemented using <code class="highlighter-rouge">app.get</code>
        <div class="img sample-site">
          <p><img src="../resources/img/hw03-gecko-03-home.png" alt="gecko web site home" /></p>
        </div>
      </li>
      <li><code class="highlighter-rouge">GET /gallery</code> - responds with a page that contains a random number of random images of an animal &#8230; this should be implemented using <code class="highlighter-rouge">app.get</code>
        <ul>
          <li>there should be 1 to 4 images displayed</li>
          <li>each image should be one of the following: <code class="highlighter-rouge">/img/animal1.jpg</code> through <code class="highlighter-rouge">/img/animal4.jpg</code></li>
          <li>they must all be <code class="highlighter-rouge">.jpg</code></li>
          <li>the same picture can show up twice</li>
        </ul>
        <div class="img sample-site">
          <p><img src="../resources/img/hw03-gecko-04-gallery-1.png" alt="gecko gallery 1" /></p>
        </div>
        <div class="img sample-site">
          <p><img src="../resources/img/hw03-gecko-04-gallery-2.png" alt="gecko gallery 1" /></p>
        </div>
      </li>
      <li><code class="highlighter-rouge">GET /pics</code> - redirects to <code class="highlighter-rouge">/gallery</code> &#8230; this should be implemented using <code class="highlighter-rouge">app.get</code> and with the callback setting the write status code and headers for a permanent redirect (check the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections">redirect article on mdn</a>)
        <ul>
          <li>note that after the redirect, the browser address bar <strong>will show the new address</strong></li>
          <li>(that is, the browser will be coerced into making another request to the url that it is being redirected to)</li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">GET /css/styles.css</code> - serves up a stylesheet based on a static file contained in <code class="highlighter-rouge">public/css/</code></li>
      <li><code class="highlighter-rouge">GET /img/animal1.jpg</code> &#8230; up through <code class="highlighter-rouge">/img/animal4.jpg</code> - serves up four images of an animal</li>
    </ol>

    <p>‚ö†Ô∏è serve your site on port <code class="highlighter-rouge">3000</code> using <code class="highlighter-rouge">127.0.0.1</code> or <code class="highlighter-rouge">localhost</code> as the port name</p>

    <p>Hints:</p>

    <ol>
      <li>first, test that your middleware is working correctly
        <ul>
          <li>activate your middleware using: `app.use(webby.static(path.join(__dirname, &#39;..&#39;, &#39;public&#39;)));</li>
          <li>drop some images in <code class="highlighter-rouge">public/img</code> and use your browser to go to <code class="highlighter-rouge">localhost:3000/img/animal1.jpg</code></li>
          <li>you should get your image back! (<em>nice</em>)</li>
        </ul>
      </li>
      <li>then, make sure regular routes work&#8230; so try implementing <code class="highlighter-rouge">/</code> (make sure that your middleware is bypassed, and your route handler is called instead)</li>
      <li>‚ö†Ô∏èfor the redirect, test your work in incognito mode
        <ul>
          <li>make sure you read up on <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections">redirects</a>)</li>
          <li>your browser should immediately go to <code class="highlighter-rouge">/gallery</code></li>
          <li>optionallly, use <code class="highlighter-rouge">curl</code> or <code class="highlighter-rouge">nc</code> to ensure that you&#39;re getting the right response back (check the status code and the headers) &#8230; in this case, <code class="highlighter-rouge">nc</code> and <code class="highlighter-rouge">curl</code> won&#39;t go to <code class="highlighter-rouge">/gallery</code> but it will show you the response that you should make next (which, of course, is <code class="highlighter-rouge">/gallery</code>)</li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">/gallery</code> will be a bit tricky:
        <ul>
          <li>when defining your route for <code class="highlighter-rouge">/gallery</code> with <code class="highlighter-rouge">app.get</code>, the callback function should contain logic to generate html</li>
          <li>the html will be conditionally generated based on random number generation with <code class="highlighter-rouge">Math.random</code> to determine both the number of images, and which images to show</li>
        </ul>
      </li>
    </ol>

    <h3 id="troubleshooting">Troubleshooting</h3>

    <ol>
      <li>If your browser doesn&#39;t show anything, and it looks like it&#39;s waiting for a response, make sure that <code class="highlighter-rouge">sock.end</code> is called somewhere.</li>
      <li>If html is showing up as text (that is, you see the tags / mark-up in the page itself), double check that you&#39;ve set the content type correctly.</li>
      <li>If you see an error in the terminal window that runs your server that says: <code class="highlighter-rouge">Error: This socket has been ended by the other party</code>, it likely means that <code class="highlighter-rouge">sock.end</code> was called more than once (you can only end a connection once! &#8230;so calling <code class="highlighter-rouge">sock.end</code> multiple times on the same socket will result in an error)</li>
      <li>If your browser does not display the resource and instead shows an error that says empty or invalid response, then that means that a valid http response is not being sent back or no data was sent back (use <code class="highlighter-rouge">curl</code>, <code class="highlighter-rouge">nc</code> or your browser&#39;s network tab to check the response)</li>
      <li>if an image is broken:
        <ul>
          <li>it&#39;s likely an issue with content type or reading the image as binary data - make sure that the status line and headers are written first, then the data of the body written afterwards</li>
          <li>or perhaps not having the newline written between the headers and the body</li>
          <li>or it could be inadvertently converting the body into a string by writing the headers and the body all at once</li>
          <li>or inadvertently adding extra data into the body</li>
        </ul>
      </li>
    </ol>

  </div>

</div>

:ET