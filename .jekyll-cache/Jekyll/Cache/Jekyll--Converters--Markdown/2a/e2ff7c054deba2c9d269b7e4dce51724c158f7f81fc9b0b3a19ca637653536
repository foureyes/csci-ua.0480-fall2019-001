I"X5<section class="intro-slide">
  <h1 id="mongoose">Mongoose</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="nosql-database-odm">NoSQL Database, ODM</h2>

  <p><strong>What&#39;s a NoSQL database again?</strong>?</p>

  <ul class="fragment">
    <li>a database that doesn&#39;t model data using tables and relations between those tables</li>
    <li>instead, usually a key value store</li>
    <li>or a document store</li>
  </ul>

  <p class="fragment"><br />
<strong>And what&#39;s an ODM?</strong> &#8594;</p>

  <ul class="fragment">
    <li>object document mapper</li>
    <li>maps application objects (objects in your code) to documents in your database
      <ul>
        <li>allows CRUD operations on those documents</li>
      </ul>
    </li>
  </ul>

  <p class="fragment"><br />
<strong>We&#39;re using MongoDB as our database and Mongoose as our ODM</strong></p>

</section>
<section>
  <h2 id="mongoose-1">Mongoose</h2>

  <div class="img">
    <p><img src="../../resources/img/mongoose.jpg" alt="mongoose" /></p>
  </div>
</section>

<section>
  <h2 id="vocabulary">Vocabulary</h2>

  <p><strong>What&#39;s a document&#8230; and what&#39;s a collection?</strong> &#8594;</p>

  <p class="fragment">In MongoDB</p>

  <ul class="fragment">
    <li><strong>document</strong> - a single row or object in your database (like&#8230; an instance of a pizza or cat)</li>
    <li><strong>collection</strong> - a group of documents, similar to a table in a relational database</li>
  </ul>

  <p class="fragment"><strong>What&#39;s a schema, model&#8230; and object?</strong> &#8594;</p>

  <p><br /></p>

  <p class="fragment">In Mongoose&#8230;</p>

  <ul class="fragment">
    <li><strong>schema</strong> - describes a collection, provides properties and other constraints (think class)</li>
    <li><strong>model</strong> - built from a schema, a constructor that allows you to create objects (think constructor for class)</li>
    <li><strong>objects/model instances</strong> - represent a document</li>
  </ul>

</section>

<section>
  <h2 id="designing-a-data-model">Designing a Data Model</h2>

  <p>Let&#39;s try designing movies. <strong>What are some properties that a <code class="highlighter-rouge">Movie</code> should have?</strong> &#8594;</p>

  <ul>
    <li class="fragment">title</li>
    <li class="fragment">year</li>
    <li class="fragment">director
      <ul>
        <li class="fragment">maybe first name</li>
        <li class="fragment">maybe last name</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2 id="embedded-vs-reference">Embedded vs Reference</h2>

  <p>So the director can be:</p>

  <ul>
    <li>just a first name and last name in your movie document</li>
    <li>a separate document embedded in your movie document</li>
    <li>a separate document referenced by your movie document</li>
  </ul>

  <p><br /></p>

  <p>See <a href="https://docs.mongodb.com/manual/core/data-modeling-introduction/">mongodb&#39;s docs</a> on data modeling.</p>

  <p><br /></p>

  <p><strong>What are the advantages / disadvantages of each?</strong></p>

</section>

<section>
  <h2 id="back-to-mongoose---schemas">Back to Mongoose - Schemas</h2>

  <p>A schema is analogous to a collection. We create a schema with the <code>mongoose.Schema</code> constructor.</p>

  <ul>
    <li>the convention is that your schema&#39;s name will match a lowercase, plural collection in your database</li>
    <li>the Schema constructor takes an object with keys as names of keys that the documents created from this schema will have</li>
    <li>&#8230;and values that represent the configuration of these keys (for example, type)</li>
  </ul>
</section>

<section>
  <h2 id="models">Models</h2>

  <p>Once you have a schema, you can then register a model. A model is a constructor for creating objects that represent MongoDB Documents.</p>

  <p>Instance Methods</p>

  <ul>
    <li><code>save</code> (create a new document)</li>
  </ul>

  <p><br /></p>

  <p>Static Methods</p>

  <ul>
    <li><code>find</code></li>
    <li><code>findOne</code></li>
    <li><code>findOneAndUpdate</code></li>
  </ul>

</section>

<section>
  <h2 id="a-note-about-warnings">A Note About Warnings</h2>

  <p><strong>You may get some deprecation warnings</strong> &#8594;</p>

  <ol>
    <li><code class="highlighter-rouge">DeprecationWarning: Mongoose: mpromise (mongoose's default ...</code>
      <ul>
        <li>this basically means that you have to pick which promise library to use</li>
        <li>promises are a way of handling async operations without nexted callbacks</li>
        <li>to use ES6 native promises: <code class="highlighter-rouge">mongoose.Promise = global.Promise;</code></li>
      </ul>
    </li>
    <li><code class="highlighter-rouge">DeprecationWarning: open() is deprecated in mongoose...</code>
      <ul>
        <li>mongoose uses some deprecated calls for connecting to the database</li>
        <li>for now, add this second argument to <code class="highlighter-rouge">mongoose.connect</code></li>
        <li><code class="highlighter-rouge">{useMongoClient: true}</code></li>
      </ul>
    </li>
  </ol>

</section>

<section>
  <h2 id="plugins">Plugins</h2>

  <p><strong>Some Schema / model functionality is so common that they&#39;re implemented on multiple schemas</strong></p>

  <ul>
    <li class="fragment">to add functionality on the Schema level, you can use a plugin</li>
    <li class="fragment">from the mongoose docs:
      <ul>
        <li class="fragment">&quot;Schemas are pluggable, that is, they allow for applying pre-packaged capabilities to extend their functionality. This is a very powerful feature.&quot;</li>
      </ul>
    </li>
    <li class="fragment">for example, some useful <em>pluggable</em> functionality for a schema may be:
      <ol>
        <li>last modified</li>
        <li>access control</li>
        <li>&#8230;and slugs</li>
      </ol>
    </li>
  </ul>

</section>
<section>
  <h2 id="slugs-and-plugins-slug-ins">Slugs and Plugins (Slug-ins?)</h2>

  <p>So&#8230; <strong>one useful plug-in is mongoose-url-slugs</strong>  &#8594;</p>

  <ul>
    <li>can be used to generate a <strong>slug</strong> (human readable string that&#39;s unique for each document) for all of your objects</li>
    <li><strong>without having to manually specify slug in the schema!</strong></li>
  </ul>

  <p><br /></p>

  <p>To use:</p>

  <ol>
    <li>install via <code class="highlighter-rouge">npm install</code></li>
    <li><code class="highlighter-rouge">require</code></li>
    <li>call <code class="highlighter-rouge">SchemaName.plugin(...)</code> to activate the plugin for that schema</li>
  </ol>

</section>

<section>
  <h2 id="pizza">Pizza</h2>

  <p><strong>Let&#39;s try creating a schema for a pizza and toppings.</strong> &#8594;</p>

  <ul>
    <li>it should allow pizzas to have a size and crust</li>
    <li>it should associate pizzas with toppings</li>
    <li>the pizza should have a short-name (a slug)</li>
    <li>toppings should have a name, and some way of noting whether or not you&#39;d like &#39;extra&#39; toppings</li>
  </ul>

  <pre class="fragment"><code data-trim="" contenteditable="">
{
	size: 'medium',
	crust: 'thin',
	slug: 'medium-thin-2'
	toppings: [{name:'mushroom', extra:true}, {name:'peppers'}]
}
</code></pre>
</section>

<section>
  <h2 id="lets-start-with-some-setup">Let&#39;s Start With Some Setup</h2>

  <p>Make sure that you have the required modules for connecting to the database&#8230; and creating a slug!</p>

  <ul>
    <li>mongoose</li>
    <li>mongoose-url-slugs</li>
  </ul>

  <p><br /></p>
  <pre><code data-trim="" contenteditable="">
npm install --save mongoose mongoose-url-slugs
</code></pre>

  <p>Require and connect&#8230;</p>

  <pre><code data-trim="" contenteditable="">
const mongoose = require('mongoose'),
	URLSlugs = require('mongoose-url-slugs');

// more stuff goes here

mongoose.model('Pizza', Pizza);
mongoose.model('Topping', Topping);
mongoose.connect('mongodb://localhost/pizzadb');
</code></pre>
</section>

<section>
  <h2 id="types--embedded-documents">Types / Embedded Documents</h2>

  <p><strong>One way to define relationships is to embed one document in another&#8230;</strong> &#8594;</p>

  <ul>
    <li>for example, this specifies that field Foo contains an Array / list of Bar objects</li>
    <li><code class="highlighter-rouge">Foo: [Bar]</code></li>
  </ul>

  <p><br /></p>

  <p>Additionally, instead of specifying the type outright, you can use an object that defines some field specifications:</p>

  <ul>
    <li><code class="highlighter-rouge">type</code></li>
    <li><code class="highlighter-rouge">max</code></li>
    <li><code class="highlighter-rouge">min</code></li>
    <li><code class="highlighter-rouge">required</code></li>
    <li><code class="highlighter-rouge">default</code> (for default value)</li>
  </ul>
</section>
<section>
  <h2 id="your-schema">Your Schema</h2>

  <p>Schemas represent collections (tables). Notice the different ways of specifying the type of a field:</p>

  <pre><code data-trim="" contenteditable="">
const Topping = new mongoose.Schema({
	name: String,
	extra: {type: Boolean, default:false}
});

const Pizza = new mongoose.Schema({
	size: {type: String, enum: ['small', 'medium', 'large']},
	crust: String,
	toppings: [Topping]
});
</code></pre>

  <pre><code data-trim="" contenteditable="">
// note that we left out slug from the schema... 
// (the plugin will add it for you!)
// this should go before registering model!
Pizza.plugin(URLSlugs('size crust'));
</code></pre>
</section>

<section>
  <h2 id="models-1">Models</h2>

  <p>With mongoose, a model allows you to:</p>

  <ul>
    <li>create new instances and save them</li>
    <li>find saved instances (using a static method)</li>
    <li>update existing instances</li>
  </ul>

  <p><br /></p>
  <pre><code data-trim="" contenteditable="">
Pizza = mongoose.model('Pizza');
</code></pre>
</section>

<section>
  <h2 id="creating-and-saving">Creating and Saving</h2>

  <pre><code data-trim="" contenteditable="">
const pizza1 = new Pizza({
	size: 'small',
	crust: 'thin'
});

pizza1.save(function(err, pizza, count) {
	console.log('made me some pizza', pizza, count, err);
});

// call mongoose.disconnect() in callback function to close
// database connection;
</code></pre>
</section>

<section>
  <h2 id="finding--retrieving">Finding / Retrieving</h2>

  <p>Ok&#8230; just like the commandline client, we can use <strong>find</strong>:</p>

  <pre><code data-trim="" contenteditable="">
// find all (try with query/criteria)
Pizza.find(function(err, pizzas, count) {
	console.log(err, pizzas, count);
});
</code></pre>

  <p>Notice that we get back an Array!</p>
</section>
<section>
  <h2 id="finding-only-one">Finding Only One!</h2>

  <p><strong>But I only want one!</strong> Sometimes it&#39;s annoying to have to index into an Array if you only want one of something, so there&#39;s also <strong>findOne</strong> &#8594;</p>
  <pre><code data-trim="" contenteditable="">
// find only one (returns first)
Pizza.findOne({slug: 'small-2' }, function(err, pizza, count) {
	console.log(err, pizza, count);
});
</code></pre>
</section>

<section>
  <h2 id="finding-then-updating">Finding Then Updating</h2>

  <p>In Mongoose&#8230; instead of using the push operator (like in the commandline client), we have a method, <strong>push</strong>, that can be called on a property if it represents a list / Array of embedded values:</p>
  <pre><code data-trim="" contenteditable="">
// update one after finding (hello callbacks!)
Pizza.findOne({slug: 'small-2' }, function(err, pizza, count) {
    // we can call push on toppings!
	pizza.toppings.push({name: 'mushroom'});
	pizza.save(function(saveErr, savePizza, saveCount) {
		console.log(savePizza);	
	});
});
</code></pre>
</section>

<section>
  <h2 id="finding-then-updating-take-two">Finding Then Updating Take Two</h2>

  <p>But of course&#8230; we can <em>actually</em> use push in an update query. In this case, we&#39;re using <strong>findOneAndUpdate</strong> to do the find and update all at once!</p>

  <pre><code data-trim="" contenteditable="">
// find one and update it; maybe better than previous?
// ...notice $push?
Pizza.findOneAndUpdate({slug:'small-2'}, {$push: {toppings: {name:'peppers'}}}, function(err, pizza, count) {
	console.log(err, pizza, count);
});
</code></pre>
</section>
<section>
  <h2 id="finding-by-embedded-documents">Finding by Embedded Documents</h2>

  <p>We can also adjust our query to find by an embedded document. In this case, we use the property of the list of embedded documents&#8230; and use another object that describes the embedded document that we&#39;d like to match.</p>

  <pre><code data-trim="" contenteditable="">
Pizza.find({toppings: {name:'mushroom'}}, function(err, pizzas, count) {
	console.log(pizzas);
});
</code></pre>
</section>
<section>
  <h2 id="finding-and-updating-multiple-embedded-documents">Finding and Updating Multiple Embedded Documents</h2>

  <p>Notice that when we update an embedded document, before we save the parent, we have to let mongoose know that we made changes to embedded documents. (shrug)</p>

  <pre><code data-trim="" contenteditable="">
Pizza.findOne({slug:'small-2'}, function(err, pizza, count) {
	for (let i = 0; i &lt; pizza.toppings.length; i++) {
		pizza.toppings[i].extra = true;
	}
	pizza.markModified('toppings');
	pizza.save(function(err, modifiedPizza, count) {
		console.log(err, modifiedPizza);
	});
});
</code></pre>

  <p>(whew!)</p>
</section>
:ET