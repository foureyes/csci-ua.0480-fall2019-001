I""<section class="intro-slide">
  <h1 id="patterns-errors-use-strict">Patterns, Errors, Use Strict</h1>

  <h3 id="csci-ua0480-001">CSCI-UA.0480-001</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="patterns">Patterns</h2>

  <p><strong>Patterns</strong> are reusable strategies / solutions for frequently occurring problems in designing and writing software.</p>

  <p><strong>Have you encountered any design patterns in your previous classes (Java has a lot of &#39;em! &#8230; we also saw a JavaScript one earlier)?</strong> &#8594;</p>

  <ul>
    <li class="fragment">function decorator - modify how a function works without changing its internals</li>
    <li class="fragment">singleton - only have one instance of an object for the lifetime of your program&#8230; (for example, a configuration object or an object to manage database connections)</li>
    <li class="fragment">MVC - separate the responsibilities of an application to model, view and controller</li>
    <li class="fragment">facade - simplify an api or mask it to mitigate against api changes</li>
  </ul>
</section>

<section>
  <h2 id="javascript-patterns">JavaScript Patterns</h2>

  <p>Besides the decorator pattern, we&#39;ll take a look at</p>

  <ul>
    <li>IIFE - immediately invoked function expressions for constraining scope</li>
    <li>module / revealing module for encapsulation</li>
    <li>namespacing</li>
  </ul>

</section>

<section>
  <h2 id="iife">IIFE</h2>

  <p><strong>IIFE</strong> (proncounced iffy) stands for immediately invoked function expression.</p>

  <p>What&#39;s it used for? &#8230;Well, <strong>what is the only thing that creates scope in JavaScript (we&#39;re not using ES6 yet)?</strong> &#8594;</p>

  <p class="fragment">Functions!</p>

  <p class="fragment"><strong>IFFEs</strong> are created by wrapping your code in a function that&#39;s immediately called! <strong>Why would we do such a thing?</strong> &#8594;</p>

  <ul>
    <li class="fragment">all of your variables are now local to function (does not create global variables)</li>
    <li class="fragment">variables are only hoisted to top of current scope</li>
    <li class="fragment">an easy way of controlling access to your variables!</li>
  </ul>

</section>
<section>
  <h2 id="function-declarations-vs-expressions">Function Declarations vs Expressions</h2>

  <p>Let&#39;s talk about the <strong>function expression</strong> part of <em>Immediately Invoked Function Expressions</em> first&#8230;</p>

  <p>A <strong>function declaration</strong>:</p>

  <pre><code data-trim="" contenteditable="">
function myAwesomeFunction() {}
</code></pre>

  <p>A <strong>function expression</strong> (an anonymous function; an expression that produces a function):</p>

  <pre><code data-trim="" contenteditable="">
function() {}
</code></pre>

</section>

<section>
  <h2 id="the-immediately-invoked-part">The Immediately Invoked Part</h2>

  <p>You can immediately run an anonymous function by wrapping it in parentheses, and immediately calling it with parentheses at the end:</p>

  <pre><code data-trim="" contenteditable="">
(function(){
  console.log('stuff to do');
})(); 
</code></pre>

  <p><strong>Why wrap the function expression in parentheses?</strong> &#8594;</p>

  <p class="fragment">When the interpreter sees function as the first <em>token</em>, it assumes function declaration syntax&#8230; but there&#39;s no function name, sooooo&#8230; syntax error.</p>
</section>

<section>
  <h2 id="passing-arguments-to-an-iife">Passing Arguments to an IIFE</h2>

  <p>You can even pass in arguments to an IIFE. This effectively &quot;saves&quot; or &quot;locks in&quot; the values that are passed in as arguments, so that any functions created within the IIFE have access to that argument.</p>

  <pre><code data-trim="" contenteditable="">
(function(greeting){
  console.log(greeting + ' world');
})('hello'); 
</code></pre>

</section>

<section>
  <h2 id="application--for-loops-and-closures">Application / For Loops and Closures</h2>

  <p>This simulates a common problem when trying to add event handlers to multiple elements in an html document. We&#39;ll use an IIFE to fix it. <strong>What&#39;s the output of this code?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
var funcs = [];
// creating three functions, each should log 1
for (var i = 0; i &lt; 3; i++) {
  funcs[i] = function() {
    console.log("My value: " + i);
  };
}

// but what?
for (var j = 0; j &lt; 3; j++) {
  funcs[j]();
}
</code></pre>

</section>

<section>
  <h2 id="the-problem">The Problem</h2>

  <ul>
    <li>there&#39;s only one environment that every function &#39;captures&#39;!</li>
    <li>i ends up being 3 at the end for all of them</li>
  </ul>

</section>
<section>
  <h2 id="using-an-iffe-to-save-state">Using an IFFE to &quot;Save State&quot;</h2>

  <pre><code data-trim="" contenteditable="">
var funcs = [];
for (var i = 0; i &lt; 3; i++) {
  funcs[i] = (function(val) {
     return function() { console.log("My value: " + val);
    };
  })(i);
}

for (var j = 0; j &lt; 3; j++) {
  funcs[j]();
}
</code></pre>

  <p>On each iteration, the IIFE is a new function object, with its own scope and local variable val, which is unchanged, even after it returns. It will stay constant for the created closure!</p>

  <p>The next iteration does not change the environments of the previously created function objects.</p>
</section>

<section>
  <h2 id="module-pattern">Module Pattern</h2>

  <p>We can use an IIFE to simulate encapsulation (think <em>access modifier</em>, <strong>private</strong>). From <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">Ben Alman&#39;s article on IIFE&#39;s</a>:</p>

  <pre><code data-trim="" contenteditable="">

var counter = (function(){
  var i = 0;

  return {
    get: function(){
      return i;
    },
    set: function( val ){
      i = val;
    },
    increment: function() {
      return ++i;
    }
  };
}());

</code></pre>

</section>

<section>
  <h2 id="using-our-module">Using Our Module</h2>

  <p>i is private! The returned object specifies the public methods!</p>

  <pre><code data-trim="" contenteditable="">
counter.get(); // 0
counter.set( 3 );
counter.increment(); // 4
counter.increment(); // 5
</code></pre>
</section>

<section>
  <h2 id="namespaces">Namespaces</h2>

  <p>Another way to keep global variables under control, and to prevent naming collisions is to use <strong>namespaces</strong>. Simply drop all of your variables into a single object!</p>

  <pre><code data-trim="" contenteditable="">
var myNamespace = {};
myNamespace.var1 = 24;
myNamespace.var2 = 24;

// var1 and var2 do not pollute the global namespace
</code></pre>

  <p><a href="http://addyosmani.com/blog/essential-js-namespacing/">Check out some more sophisticated ways to deal with namespacing</a> (for example, dealing with cumbersome deep nesting)</p>
</section>

<section>
  <h2 id="use-strict">use strict</h2>

  <p>Place <code>"use strict"</code> at the top of a file or function to make JavaScript a little <em>less lenient</em>. <strong>Strict mode</strong>&#8230;</p>

  <ul>
    <li>throws an error when code inadvertently causes a global variable to be created by dropping var</li>
    <li>prevents methods / constructors from being called incorrectly (in such a way that <code>this</code> references the global object)</li>
  </ul>

</section>

<section>
  <h2 id="use-strict-example-1">use strict Example 1</h2>

  <p>From Speaking JavaScript:</p>

  <pre><code data-trim="" contenteditable="">
function canYouSpotTheProblem() {
  "use strict";
  for (counter = 0; counter &lt; 10; counter++) {
    console.log("Happy happy"); 
  }
}
canYouSpotTheProblem();

</code></pre>
</section>

<section>
  <h2 id="use-strict-example-2">use strict Example 2</h2>

  <p>From Speaking JavaScript:</p>

  <pre><code data-trim="" contenteditable="">
"use strict";
function Person(name) { this.name = name; }
// Oops , forgot 'new '
var ferdinand = Person("Ferdinand");

</code></pre>
</section>

<section>
  <h2 id="exception-handling">Exception Handling</h2>

  <p>Creating errors&#8230;</p>

  <pre><code data-trim="" contenteditable="">
throw new Error("some stuff");
</code></pre>

  <p>Handling errors&#8230;</p>
  <pre><code data-trim="" contenteditable="">
try {
  throw new Error("makin' some errors");
} catch(e) {
  console.log('caught it', e);
}
</code></pre>

</section>

<section>
  <h2 id="error-instances">Error Instances</h2>

  <p>To catch specific errors:</p>

  <ul>
    <li>create a new error object (using Error.prototype as prototype)</li>
    <li>use instanceof in catch</li>
  </ul>

</section>
:ET