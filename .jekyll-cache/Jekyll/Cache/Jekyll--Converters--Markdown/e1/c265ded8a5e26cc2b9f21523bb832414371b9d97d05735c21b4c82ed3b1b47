I"D=<section class="intro-slide">
  <h1 id="objects-revisited-prototypes">Objects Revisited, Prototypes</h1>

  <h3 id="csci-ua0480">CSCI-UA.0480</h3>

  <p><small></small></p>
</section>

<section>
  <h2 id="object-oriented-programming">Object-Oriented Programming</h2>

  <p><strong>Describe the following object oriented programming concepts</strong>: &#8594;</p>

  <ul>
    <li><strong>inheritance</strong> <span class="fragment">- basing a class off of another class so that it maintains the same behavior as its super class</span></li>
    <li><strong>polymorphism</strong> <span class="fragment">- having the same interface to instances of different types</span></li>
    <li><strong>encapsulation</strong> <span class="fragment">- information hiding, internals/implementation details not accessible publicly</span></li>
    <li><strong>abstraction</strong>  <span class="fragment">- (again) creating tools / interfaces that allow a programmer to address the actual problem they&#39;re solving rather than having to deal with necessary, but irrelevant (to the problem) details</span></li>
  </ul>

</section>

<section>
  <h2 id="object-oriented-programming-in-java">Object-Oriented Programming in Java</h2>

  <p>In Java, <strong>what language features / constructs allow inheritance, polymorphism, encapsulation, and abstraction?</strong> &#8594;</p>

  <ul class="fragment">
    <li><strong>inheritance</strong> - subclassing&#8230; using extend</li>
    <li><strong>polymorphism</strong> - instances of different classes that are subclasses of the same superclass</li>
    <li><strong>encapsulation</strong> - private methods and private members variables</li>
    <li><strong>abstraction</strong> - creating classes, interfaces, abstract classes, and methods</li>
  </ul>
</section>

<section>
  <h2 id="object-oriented-programming-in-javascript"><em>Object-Oriented Programming</em> in JavaScript</h2>

  <p>Although JavaScript <em>has</em> objects, its approach to <em>object-oriented programming</em> is a bit unconventional.</p>

  <ul>
    <li>it still supports <strong>encapsulation</strong>, <strong>inheritance</strong>, <strong>polymorphism</strong>, and <strong>abstraction</strong></li>
    <li>&#8230; but it does so <strong>differently</strong> than Java (and other languages that support <em>classical object-oriented</em> techniques) &#8594;</li>
  </ul>

  <p><br /></p>

  <ul class="fragment">
    <li>inheritance - prototypes and/or functions</li>
    <li>polymorphism - <em>duck typing</em></li>
    <li>encapsulation - closures</li>
    <li>abstraction - higher order functions, prototypes, etc.</li>
  </ul>
</section>

<section>
  <h2 id="an-aside-on-duck-typing">An Aside on Duck Typing</h2>

  <h3 id="if-it-looks-like-a-duck-and-it-quacks-like-a-duck-its-a-duck"><em>If it looks like a duck and it quacks like a duck&#8230; it&#39;s a duck</em></h3>

  <ul>
    <li>when an object&#39;s methods and properties determine valid semantics</li>
    <li>&#8230; rather than its class or the class that it inherits from</li>
  </ul>

  <div class="img">
    <p><img src="../../resources/img/duck.jpg" alt="duck" /></p>
  </div>

</section>

<section>
  <h1 id="lets-dive-into-objects">Let&#39;s dive into objects</h1>

  <h3 id="ouch">(ouch)</h3>
</section>

<section>
  <h2 id="globals">Globals</h2>

  <p>First off, in both Node and browser-based JavaScript implementations a <strong>global object</strong> exists:</p>

  <ul>
    <li><code>global</code> for node</li>
    <li><code>window</code> for browsers</li>
  </ul>

  <p><br />
<strong>Let&#39;s see what this looks like by</strong>: &#8594;</p>

  <ul>
    <li>checking out global in the interactive shell</li>
    <li>inadvertently creating a global variable within a function definition (dropping <code class="highlighter-rouge">const</code>, <code class="highlighter-rouge">let</code>, and <code class="highlighter-rouge">var</code>)</li>
  </ul>

  <pre class="fragment"><code data-trim="" contenteditable="">
console.log(global.mistake);
function oopsGlobal() {
	mistake = "yup";
}
oopsGlobal();
console.log(mistake);
console.log(global.mistake);
</code></pre>
</section>

<section>
  <h2 id="methods">Methods</h2>

  <p><strong>Methods</strong> are object properties that are functions (a function within the context of an object).</p>

  <pre><code data-trim="" contenteditable="">
const cat = {};
cat.speak = function() {
	console.log("meow"); 
};
cat.speak();
</code></pre>

  <p>Notice that you can attach methods to any arbitrary object instance! (???)</p>
</section>

<section>
  <h2 id="this">This</h2>

  <p>&quot;When a function is called as a method—looked up as a property and immediately called, as in object.method()—the special constiable <strong><code>this</code></strong> in its body will point to the object that it was called on&quot;. <strong>What will be printed out in the code below?.</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
function speak() {
	if(this.nationality == "Japanese") {
		console.log("nyan");
	} else if (this.nationality == "American") {
		console.log("meow");
	} else {
		console.log("default cat noise");
	}
}
</code></pre>
  <pre><code data-trim="" contenteditable="">
const japaneseCat = {nationality:"Japanese", speak:speak};
const americanCat = {nationality:"American", speak:speak};
</code></pre>
  <pre><code data-trim="" contenteditable="">
japaneseCat.speak();
americanCat.speak();
</code></pre>
  <pre class="fragment"><code data-trim="" contenteditable="">
nyan
meow
</code></pre>
</section>
<section data-background="#440000">
  <h2 id="in-methods-this-refers-to-the-object-that-the-method-was-called-on">In methods, <code>this</code> refers to the object that the method was called on</h2>

</section>

<section>
  <h2 id="hm-what-if-a-function-isnt-attached-to-an-object">Hm. What if a Function isn&#39;t Attached to an Object?</h2>

  <p>A standalone function&#39;s <strong><code>this</code></strong> refers to the global object. <strong>What will the following code print out?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
global.outside = 5;
const f = function() {
	console.log(this.outside);
}
f();
</code></pre>
  <pre class="fragment"><code data-trim="" contenteditable="">
5

// this is the global object!
</code></pre>
</section>

<section>
  <h2 id="standalone-functions-and-this">Standalone Functions and This</h2>

  <p><strong>Aaaand&#8230; what&#39;s the output of our speak function from the previous slide if we call it on its on (not within the context of an object)?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
function speak() {
	if(this.nationality == "Japanese") {
		console.log("nyan");
	} else if (this.nationality == "American") {
		console.log("meow");
	} else {
		console.log("default cat noise");
	}
}
speak();
</code></pre>
  <pre class="fragment"><code data-trim="" contenteditable="">
default cat noise
</code></pre>

  <ul class="fragment">
    <li>if we <code>console.log(this.nationality)</code> &#8230;  we&#39;ll see it&#39;s <code>undefined</code></li>
    <li>nationality was not yet defined on the global object, so we get <code>undefined</code></li>
  </ul>
</section>
<section>
  <h2 id="oh-also">Oh. Also&#8230;</h2>

  <p><a href="http://www.eleceng.adelaide.edu.au/personal/dabbott/animal.html">How to say meow in different languages</a></p>

</section>

<section data-background="#440000">
  <h2 id="in-standalone-functions-this-refers-to-the-global-object">In standalone functions, <code>this</code> refers to the global object</h2>
</section>
<section>
  <h2 id="another-ways">Another Way(s)</h2>

  <p>Besides <strong>method</strong> invocation and <strong>regular function invocation</strong>, <strong>what are two other ways of executing a function?</strong> &#8594;</p>

  <ul>
    <li class="fragment"><code class="highlighter-rouge">call</code> - invoke function that call was called on with specified <code class="highlighter-rouge">this</code> and positional arguments</li>
    <li class="fragment"><code class="highlighter-rouge">apply</code> - invoke function that apply was called on with specified <code class="highlighter-rouge">this</code> and an <code class="highlighter-rouge">Array</code> containing positional arguments</li>
  </ul>

  <p class="fragment"><br />
When invoking a function with <strong><code class="highlighter-rouge">call</code> or <code class="highlighter-rouge">apply</code></strong>:</p>

  <ul>
    <li class="fragment"><strong><code class="highlighter-rouge">this</code> will be bound to the value passed in as the first argument.</strong></li>
    <li class="fragment"><strong>What&#39;s the output of the following code?</strong> &#8594;</li>
  </ul>

  <pre class="fragment"><code data-trim="" contenteditable="">
function greet(person) { console.log(this.greeting, person); }
const obj = { greeting: 'hi' };
greet.call(obj, 'joe');
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
hi joe
</code></pre>

</section>

<section>
  <h2 id="call-and-apply-continued">Call and Apply Continued</h2>

  <p><strong>Aaaand&#8230; of course, call and apply with our cat example (modified a bit). What is the output of this code?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
function speak(how, toWho) {
    const d = {Japanese: "nyans", American: "meows"};
    const noise = d[this.nationality] || "default cat noise";
    console.log(noise, how, 'at', toWho);
}
const cat = {nationality: "American"}

speak.apply(cat, ['loudly', 'you']);
speak.apply({}, ['softly', 'me']);
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
meows loudly at you
default cat noise softly at me
</code></pre>

</section>

<section data-background="#440000">
  <h2 id="when-executing-a-function-with-the-methods-call-or-apply-this-refers-to-the-object-passed-in-as-the-first-argument-to-either-method">When executing a function with the methods <code class="highlighter-rouge">call</code> or <code class="highlighter-rouge">apply</code>, <code>this</code> refers to the object passed in as the first argument to either method</h2>
</section>

<section>
  <h2 id="another-mystery">Another Mystery?</h2>

  <p><strong>What is the output of this code and why?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
const counter = {numbers: [1, 2, 3, 4], animal:'owl'};

counter.count = function() {
    this.numbers.forEach(function(n) {
        console.log(n, this.animal + (n &gt; 1 ? 's' : ''));
    });
};
counter.count();
</code></pre>
  <pre class="fragment"><code data-trim="" contenteditable="">
1 'undefined'
2 'undefineds'
3 'undefineds'
4 'undefineds'
</code></pre>

  <p class="fragment">The anonymous function is being invoked as a <strong>regular function</strong> for every element in the <code class="highlighter-rouge">Array</code>, <code class="highlighter-rouge">counter.numbers</code>. <strong><code class="highlighter-rouge">this</code> refers to global object</strong>, which does not have the property, <code class="highlighter-rouge">animal</code>, resulting in <code class="highlighter-rouge">undefined</code>.</p>
</section>

<section>
  <h2 id="arrow-functions">Arrow Functions</h2>

  <p>In previous slides, we said that the <code class="highlighter-rouge">this</code> value in <strong>arrow functions</strong> is the <code class="highlighter-rouge">this</code> in the scope that the arrow function was created in (that is, it doesn&#39;t have it&#39;s <em>own</em> <code class="highlighter-rouge">this</code>, it just uses the one that&#39;s already there!</p>

  <p><strong>Let&#39;s see how this works:</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
const counter = {numbers: [1, 2, 3, 4], animal:'owl'};

counter.count = function() {
    this.numbers.forEach((n) =&gt; {
        console.log(n, this.animal + (n &gt; 1 ? 's' : ''));
    });
};
counter.count();
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
1 'owl'
2 'owls'
3 'owls'
4 'owls'
</code></pre>

  <p class="fragment">Better! <code class="highlighter-rouge">this</code> is whatever <code class="highlighter-rouge">this</code> refers to in the count method, and because <code class="highlighter-rouge">count</code> was invoked as a method, <code class="highlighter-rouge">this</code> is the object that <code class="highlighter-rouge">count</code> was called on.</p>
</section>
<section>
  <h2 id="arrow-functions-continued">Arrow Functions Continued</h2>

  <p>Of course, that means if we use the following code, what will <code class="highlighter-rouge">this</code> refer to? <strong>What is the output of the following code?</strong> &#8594;</p>

  <pre><code data-trim="" contenteditable="">
function foo() {
    const bar = (x) =&gt; { console.log(this.qux); };
    bar();
}
foo();
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
undefined
</code></pre>

  <p class="fragment"><code class="highlighter-rouge">this</code> references <code class="highlighter-rouge">this</code> in the function, <code class="highlighter-rouge">foo</code>, which was invoked as a regular function. Consequently, <code class="highlighter-rouge">this</code> is the global object.</p>
</section>
<section>
  <h2 id="summary">Summary</h2>

  <p><em>What is this?????</em></p>

  <ol>
    <li class="fragment"><strong>regular function invocation</strong>
      <ul>
        <li class="fragment"><code class="highlighter-rouge">this</code> is the global object</li>
      </ul>
    </li>
    <li class="fragment"><strong>method call</strong>
      <ul>
        <li class="fragment"><code class="highlighter-rouge">this</code> is the object the method was called on</li>
      </ul>
    </li>
    <li class="fragment"><strong>invoked with call or apply</strong>
      <ul>
        <li class="fragment"><code class="highlighter-rouge">this</code> is the first argument passed in to call or apply</li>
      </ul>
    </li>
    <li class="fragment"><strong>arrow function</strong>
      <ul>
        <li class="fragment"><code class="highlighter-rouge">this</code> is <code class="highlighter-rouge">this</code> from the enclosing context</li>
      </ul>
    </li>
  </ol>

</section>
<section>
  <h2 id="a-magic-trick">A Magic Trick</h2>

  <p><strong>Let&#39;s try running this code&#8230;</strong> &#8594;</p>

  <ul>
    <li>have we defined any properties on the object called <code>empty</code>?</li>
    <li>will this produce output or give us an error?</li>
  </ul>

  <pre><code data-trim="" contenteditable="">
const empty = {}; 
console.log(empty.toString);
console.log(empty.toString());
</code></pre>

  <pre class="fragment"><code data-trim="" contenteditable="">
[Function: toString]
[object Object]
</code></pre>

  <div class="img fragment">
    <p>Magic!<br />
<img src="../../resources/img/magic.gif" alt="magic" /></p>
  </div>
</section>

<section>
  <h2 id="inherited-properties">Inherited Properties</h2>

  <p><strong>If we started off with an empty object in the previous slide, where did the toString method come from?</strong></p>

  <ul class="fragment">
    <li>&quot;in addition to their set of properties, almost all objects also have a <strong>prototype</strong>&quot;</li>
    <li>&quot;a <strong>prototype</strong> is another object that is used as a fallback source of properties&quot;</li>
    <li>&quot;when an object gets a request for a property that it does not have&#8230;&quot;</li>
    <li>&quot;its prototype will be searched for the property, then the prototype’s prototype, and so on&quot;</li>
  </ul>

</section>

:ET